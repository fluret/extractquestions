
        \question
        Créer une liste de carrés de nombres de 1 à 10

Exemple de sortie

[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q500.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le code que vous avez fourni est écrit en Python et utilise une compréhension de liste pour créer une liste appelée squares qui contient les carrés des nombres de 1 à 10. Voici une explication pas à pas du code :

    carrés = [x**2 for x in range(1, 11)] : Cette ligne de code initialise une variable nommée carrés et lui affecte le résultat d'une compréhension de liste.
        for x in range(1, 11) : Cette partie met en place une boucle qui parcourt les nombres de 1 à 10 (inclus). La fonction range(1, 11) génère une séquence de nombres commençant par 1 et se terminant par 10.
        x**2 : pour chaque valeur de x dans la plage, cette expression calcule le carré de x.
        [x**2 for x in range(1, 11)] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les nombres de l'intervalle spécifié (1 à 10) et, pour chaque nombre, calcule son carré. Les carrés obtenus sont rassemblés dans une nouvelle liste.
    print(carrés) : Cette ligne de code imprime simplement la liste des carrés sur la console.
        \end{solution}
        

        \question
        Créer une liste de nombres pairs de 1 à 20

Exemple de résultat

[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q501.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée une liste appelée evens à l'aide d'une compréhension de liste, qui contient les nombres pairs de 1 à 20. Voici un aperçu du fonctionnement du code :

    evens = [x for x in range(1, 21) if x % 2 == 0] : Cette ligne de code initialise une variable nommée evens et lui affecte le résultat d'une compréhension de liste.
        for x in range(1, 21) : Cette partie met en place une boucle qui parcourt les nombres de 1 à 20 (inclus). La fonction range(1, 21) génère une séquence de nombres commençant par 1 et se terminant par 20.
        if x % 2 == 0 : il s'agit d'une condition qui filtre les nombres. Elle vérifie si la valeur actuelle de x est paire. L'opérateur % calcule le reste lorsque x est divisé par 2. Si le reste est égal à 0, cela signifie que x est pair.
        [x for x in range(1, 21) if x % 2 == 0] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les nombres de l'intervalle spécifié (1 à 20) et, pour chaque nombre, vérifie s'il est pair. Si le nombre est pair, il est inclus dans la nouvelle liste.
    print(evens) : Cette ligne de code imprime la liste evens sur la console.
        \end{solution}
        

        \question
        Générer une liste de caractères à partir d'une chaîne de caractères

Exemple de sortie

['H', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd']
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q502.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée une liste appelée chars en utilisant une compréhension de liste pour extraire les caractères alphabétiques de la chaîne donnée "Hello, world !". Voici comment fonctionne ce code :

    string = "Hello, world !": Cette ligne initialise une variable nommée string et lui affecte la valeur "Hello, world !", qui est une chaîne contenant des lettres, des espaces et de la ponctuation.
    chars = [char for char in string if char.isalpha()] : Cette ligne de code initialise une variable nommée chars et lui affecte le résultat d'une compréhension de liste.
        for char in string : Cette partie met en place une boucle qui parcourt chaque caractère (char) de la chaîne.
        if char.isalpha() : Il s'agit d'une condition qui vérifie si le caractère courant char est alphabétique. La méthode .isalpha() est une méthode de chaîne qui renvoie True si le caractère est une lettre de l'alphabet et False s'il ne l'est pas.
        [char for char in string if char.isalpha()] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt chaque caractère de la chaîne et, pour chaque caractère alphabétique, l'inclut dans la nouvelle liste.
    print(chars) : Cette ligne de code imprime la liste des caractères sur la console.
        \end{solution}
        

        \question
        Créer une liste de longueurs de mots dans une phrase

Exemple de sortie

Voici un exemple de phrase.

[4, 2, 1, 6, 9]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q503.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python analyse une phrase et crée une liste appelée word_lengths en utilisant une compréhension de liste pour stocker les longueurs de chaque mot dans la phrase. Voici comment fonctionne le code :

    sentence = "Ceci est un exemple de phrase" : Cette ligne initialise une variable nommée sentence et lui attribue la valeur "Ceci est un exemple de phrase".
    word_lengths = [len(word) for word in sentence.split()] : Cette ligne de code initialise une variable nommée word_lengths et lui affecte le résultat d'une compréhension de liste.
        sentence.split() : Cette partie du code divise la phrase en une liste de mots. Par défaut, la phrase est divisée sur les espaces blancs, ce qui permet de séparer les mots.
        for word in sentence.split() : Cette partie met en place une boucle qui parcourt chaque mot de la liste de mots.
        len(word) : Pour chaque mot de la liste, cette expression calcule la longueur du mot à l'aide de la fonction len().
        [len(word) for word in sentence.split()] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt la liste de mots et, pour chaque mot, calcule sa longueur et l'inclut dans la nouvelle liste.
    print(phrase) : Cette ligne de code imprime la phrase originale sur la console.
    print(longueur_des_mots) : Cette ligne de code imprime la liste des longueurs de mots sur la console.
        \end{solution}
        

        \question
        Générer une liste de tuples contenant un nombre et son carré

Exemple de sortie

[(1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q504.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée une liste appelée num_squares en utilisant une compréhension de liste pour générer des paires de nombres et leurs carrés pour des valeurs de x allant de 1 à 5. Voici comment fonctionne le code :

    num_squares = [(x, x**2) for x in range(1, 6)] : Cette ligne de code initialise une variable nommée num_squares et lui affecte le résultat d'une compréhension de liste.
        for x in range(1, 6) : Cette partie met en place une boucle qui parcourt les valeurs de x de 1 à 5 (inclus). La fonction range(1, 6) génère une séquence de nombres commençant par 1 et se terminant par 5.
        (x, x**2) : Pour chaque valeur de x dans l'intervalle, cette expression crée un tuple contenant deux éléments : la valeur originale x et son carré x**2.
        [(x, x**2) for x in range(1, 6)] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les valeurs de x dans l'intervalle spécifié (1 à 5) et, pour chaque valeur, génère un tuple contenant x et x**2. Ces n-uplets sont rassemblés dans une nouvelle liste.
    print(num_squares) : Cette ligne de code affiche la liste num_squares sur la console.
        \end{solution}
        

        \question
        Créer une liste de lettres minuscules

Exemple de résultat

['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q505.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée une liste appelée lowercase_letters en utilisant une compréhension de liste pour générer des lettres minuscules de l'alphabet anglais. Voici comment fonctionne ce code :

    lowercase_letters = [chr(x) for x in range(ord('a'), ord('z')+1)] : Cette ligne de code initialise une variable nommée lowercase_letters et lui affecte le résultat d'une compréhension de liste.
        range(ord('a'), ord('z')+1) : Cette partie du code génère une plage de valeurs entières correspondant aux points de code Unicode des lettres minuscules de l'alphabet anglais. ord('a') renvoie le point de code Unicode de la lettre 'a', et ord('z') renvoie le point de code Unicode de la lettre 'z'. L'ajout de 1 permet de s'assurer que la lettre 'z' est incluse dans la plage.
        chr(x) : Pour chaque entier x de la plage, cette expression le convertit en caractère à l'aide de la fonction chr(). chr(x) renvoie le caractère correspondant au point de code Unicode x.
        [chr(x) for x in range(ord('a'), ord('z')+1)] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt la gamme des points de code Unicode pour les lettres minuscules et convertit chaque point de code en son caractère correspondant. Ces caractères (lettres minuscules) sont rassemblés dans une nouvelle liste.
    print(lettres minuscules) : Cette ligne de code imprime la liste des lettres minuscules sur la console.
        \end{solution}
        

        \question
        Générer une liste de lettres majuscules

Exemple de sortie

['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q506.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée une liste appelée uppercase_letters en utilisant une compréhension de liste pour générer des lettres majuscules de l'alphabet anglais. Voici comment fonctionne ce code :

    uppercase_letters = [chr(x) for x in range(ord('A'), ord('Z')+1)] : Cette ligne de code initialise une variable nommée uppercase_letters et lui affecte le résultat d'une compréhension de liste.
        range(ord('A'), ord('Z')+1) : Cette partie du code génère une plage de valeurs entières correspondant aux points de code Unicode des lettres majuscules de l'alphabet anglais. ord('A') renvoie le point de code Unicode de la lettre 'A', et ord('Z') renvoie le point de code Unicode de la lettre 'Z'. En ajoutant 1, on s'assure que la lettre 'Z' est incluse dans la plage.
        chr(x) : Pour chaque entier x de la plage, cette expression le convertit en caractère à l'aide de la fonction chr(). chr(x) renvoie le caractère correspondant au point de code Unicode x.
        [chr(x) for x in range(ord('A'), ord('Z')+1)] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt la gamme des points de code Unicode pour les lettres majuscules et convertit chaque point de code en son caractère correspondant. Ces caractères (lettres majuscules) sont rassemblés dans une nouvelle liste.
    print(lettres_majuscules) : Cette ligne de code imprime la liste des lettres majuscules sur la console.
        \end{solution}
        

        \question
        Créer une liste de nombres pairs au carré et de nombres impairs au cube de 1 à 10

Exemple de résultat

[1, 4, 27, 16, 125, 36, 343, 64, 729, 100]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q507.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée une liste appelée result en utilisant une compréhension de liste pour calculer le carré ou le cube des nombres de 1 à 10 selon qu'ils sont pairs ou impairs. Voici comment fonctionne ce code :

    result = [x**2 if x % 2 == 0 else x**3 for x in range(1, 11)] : Cette ligne de code initialise une variable nommée result et lui affecte le résultat d'une compréhension de liste.
        for x in range(1, 11) : Cette partie met en place une boucle qui parcourt les nombres de 1 à 10 (inclus). La fonction range(1, 11) génère une séquence de nombres commençant par 1 et se terminant par 10.
        x**2 if x % 2 == 0 else x**3 : Pour chaque valeur de x dans la plage, cette expression calcule le carré (x**2) ou le cube (x**3) du nombre selon que x est pair (x % 2 == 0) ou non. Si x est pair, elle calcule le carré ; sinon, elle calcule le cube.
        [x**2 if x % 2 == 0 else x**3 for x in range(1, 11)] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les nombres de l'intervalle spécifié (1 à 10) et, pour chaque nombre, calcule son carré ou son cube selon qu'il est pair ou impair. Les résultats sont rassemblés dans une nouvelle liste.
    print(result) : Cette ligne de code imprime la liste des résultats sur la console.
        \end{solution}
        

        \question
        Générer une liste de multiples communs de 3 et 5 jusqu'à 100

Exemple de résultat

[15, 30, 45, 60, 75, 90]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q508.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée une liste appelée common_multiples en utilisant une compréhension de liste pour trouver et stocker les nombres de 1 à 100 qui sont des multiples de 3 et de 5. Voici comment fonctionne le code :

    common_multiples = [x for x in range(1, 101) if x % 3 == 0 and x % 5 == 0] : Cette ligne de code initialise une variable nommée common_multiples et lui affecte le résultat d'une compréhension de liste.
        for x in range(1, 101) : Cette partie met en place une boucle qui parcourt les nombres de 1 à 100 (inclus). La fonction range(1, 101) génère une séquence de nombres commençant par 1 et se terminant par 100.
        if x % 3 == 0 and x % 5 == 0 : cette condition vérifie si la valeur actuelle de x est un multiple de 3 et de 5. L'opérateur % calcule le reste lorsque x est divisé par 3 et 5. Si le reste est égal à 0 pour les deux divisions, cela signifie que x est un multiple de 3 et de 5.
        [x for x in range(1, 101) if x % 3 == 0 and x % 5 == 0] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les nombres de l'intervalle spécifié (1 à 100) et, pour chaque nombre qui est un multiple de 3 et de 5, l'inclut dans la nouvelle liste.
    print(common_multiples) : Cette ligne de code imprime la liste common_multiples sur la console.
        \end{solution}
        

        \question
        Créer une liste de chaînes inversées à partir d'une autre liste

Exemple de résultat

['pomme', 'banane', 'cerise']

['elppa', 'ananab', 'yrrehc']
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q509.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de mots, inverse chaque mot de la liste et stocke les mots inversés dans une nouvelle liste appelée mots_inversés. Voici comment fonctionne ce code :

    mots = ["pomme", "banane", "cerise"] : Cette ligne initialise une variable nommée words et lui affecte une liste contenant trois mots : "pomme", "banane" et "cerise".
    mots_inversés = [mot[::-1] pour mot dans mots] : Cette ligne de code initialise une variable nommée mots_inversés et lui affecte le résultat de la compréhension d'une liste.
        for word in words : Cette partie met en place une boucle qui parcourt chaque mot de la liste des mots.
        word[::-1] : Pour chaque mot de la liste, cette expression utilise le découpage ([::-1]) pour inverser les caractères du mot. La notation de tranche [::-1] inverse l'ordre des caractères dans une chaîne.
        [mot[::-1] pour mot dans mots] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les mots de la liste words et, pour chaque mot, l'inverse et inclut le mot inversé dans la nouvelle liste.
    print(mots) : Cette ligne de code imprime la liste de mots originale sur la console.
    print(mots_inversés) : Cette ligne de code affiche la liste des mots inversés sur la console.
        \end{solution}
        

        \question
        Générer une liste de nombres premiers de 1 à 50

Exemple de sortie

[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q510.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le code Python fourni définit une fonction is_prime(n) qui vérifie si un entier donné n est un nombre premier ou non. Elle crée ensuite une liste appelée nombres_premiers en utilisant une compréhension de liste pour trouver et stocker les nombres premiers entre 1 et 50. Voici comment fonctionne le code :

    def is_prime(n) : Cette ligne définit une fonction nommée is_prime qui prend un entier n comme argument.
        if n <= 1: : Cette ligne vérifie si n est inférieur ou égal à 1. Si n est inférieur ou égal à 1, la fonction renvoie False, car 1 et tout nombre négatif ne sont pas premiers.
        for i in range(2, int(n**0.5) + 1): : Cette ligne met en place une boucle qui itère de 2 à la racine carrée de n (incluse) en utilisant la fonction range(). La vérification jusqu'à la racine carrée est une optimisation visant à réduire le nombre de divisions nécessaires pour déterminer la primalité.
        if n % i == 0: : À l'intérieur de la boucle, cette ligne vérifie si n est divisible par la valeur actuelle de i. Si c'est le cas, cela signifie que n n'est pas premier, et la fonction renvoie donc False.
        Si aucune des conditions ci-dessus n'est remplie, cela signifie que n n'est divisible par aucun nombre de la plage, et la fonction renvoie donc True, indiquant que n est un nombre premier.
    nombres_premiers = [x for x in range(1, 51) if is_prime(x)] : Cette ligne de code initialise une variable nommée nombres_premiers et lui affecte le résultat d'une compréhension de liste.
        for x in range(1, 51) : Cette partie met en place une boucle qui parcourt les nombres de 1 à 50 (inclus). La fonction range(1, 51) génère une séquence de nombres commençant par 1 et se terminant par 50.
        if is_prime(x) : Cette condition vérifie si la valeur actuelle de x est un nombre premier en appelant la fonction is_prime(). Si c'est le cas, elle l'inclut dans la liste des nombres premiers.
    print(nombres_premiers) : Cette ligne de code imprime la liste des nombres premiers sur la console.
        \end{solution}
        

        \question
        Créer une liste de carrés de nombres pairs et de cubes de nombres impairs de -5 à 5

Exemple de résultat

[-125, 16, -27, 4, -1, 0, 1, 4, 27, 16, 125]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q511.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée une liste appelée result en utilisant une compréhension de liste pour calculer le carré des nombres pairs et le cube des nombres impairs dans l'intervalle de -5 à 5. Voici comment le code fonctionne :

    result = [x**2 if x % 2 == 0 else x**3 for x in range(-5, 6)] : Cette ligne de code initialise une variable nommée result et lui affecte le résultat d'une compréhension de liste.
        for x in range(-5, 6) : Cette partie met en place une boucle qui parcourt les nombres de -5 à 5 (inclus). La fonction range(-5, 6) génère une séquence de nombres commençant par -5 et se terminant par 5.
        x**2 if x % 2 == 0 else x**3 : Pour chaque valeur de x dans l'intervalle, cette expression calcule le carré (x**2) ou le cube (x**3) du nombre selon que x est pair (x % 2 == 0) ou impair.
        [x**2 if x % 2 == 0 else x**3 for x in range(-5, 6)] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les nombres de l'intervalle spécifié (-5 à 5) et, pour chaque nombre, calcule son carré ou son cube selon qu'il est pair ou impair. Les résultats sont rassemblés dans une nouvelle liste.
    print(result) : Cette ligne de code imprime la liste des résultats sur la console.
        \end{solution}
        

        \question
        Générer une liste de chaînes de caractères avec leurs longueurs à partir d'une autre liste

Exemple de sortie

['pomme', 'banane', 'cerise']

[('pomme', 5), ('banane', 6), ('cerise', 6)]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q512.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée une liste appelée word_lengths en utilisant une compréhension de liste pour associer chaque mot de la liste des mots à sa longueur correspondante (nombre de caractères). Voici comment fonctionne le code :

    mots = ["pomme", "banane", "cerise"] : Cette ligne initialise une variable nommée words et lui affecte une liste contenant trois mots : "pomme", "banane" et "cerise".
    word_lengths = [(word, len(word)) for word in words] : Cette ligne de code initialise une variable nommée word_lengths et lui affecte le résultat de la compréhension d'une liste.
        for word in words : Cette partie met en place une boucle qui parcourt chaque mot de la liste des mots.
        (mot, len(mot)) : Pour chaque mot de la liste, cette expression crée un tuple contenant deux éléments : le mot original et la longueur du mot len(word).
        [(mot, len(mot)) pour mot dans mots] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les mots de la liste words et, pour chaque mot, l'associe à sa longueur et inclut cette paire (tuple) dans la nouvelle liste.
    print(words) : Cette ligne de code imprime la liste de mots originale sur la console.
    print(word_lengths) : Cette ligne de code affiche la liste des mots_longueurs sur la console.
        \end{solution}
        

        \question
        Créer une liste de premiers caractères à partir d'une liste de mots

Exemple de sortie

['apple', 'banana', 'cherry']

['a', 'b', 'c']
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q513.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée une liste appelée first_chars en utilisant une compréhension de liste pour extraire le premier caractère de chaque mot de la liste words. Voici comment fonctionne ce code :

    words = ["apple", "banana", "cherry"] : Cette ligne initialise une variable nommée words et lui assigne une liste contenant trois mots : "pomme", "banane" et "cerise".
    first_chars = [word[0] for word in words] : Cette ligne de code initialise une variable nommée first_chars et lui affecte le résultat de la compréhension d'une liste.
        for word in words : Cette partie met en place une boucle qui parcourt chaque mot de la liste des mots.
        word[0] : Pour chaque mot de la liste, cette expression récupère le premier caractère du mot en utilisant l'indexation [0]. Cette indexation permet d'extraire le caractère situé à la position 0 de la chaîne, qui est le premier caractère.
        [mot[0] pour mot dans mots] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les mots de la liste des mots et, pour chaque mot, extrait son premier caractère et l'inclut dans la nouvelle liste.
    print(words) : Cette ligne de code imprime la liste de mots originale sur la console.
    print(first_chars) : Cette ligne de code imprime la liste first_chars sur la console.
        \end{solution}
        

        \question
        Générer une liste de nombres avec leurs carrés si le nombre est pair

Exemple de sortie

[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

[4, 16, 36, 64, 100]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q514.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée une liste appelée squared_evens en utilisant une compréhension de liste pour calculer le carré des nombres pairs à partir de la liste des nombres. Voici comment fonctionne le code :

    nombres = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] : Cette ligne initialise une variable nommée numbers et lui affecte une liste contenant des nombres de 1 à 10.
    squared_evens = [x**2 for x in numbers if x % 2 == 0] : Cette ligne de code initialise une variable nommée squared_evens et lui affecte le résultat d'une compréhension de liste.
        for x in numbers : Cette partie met en place une boucle qui parcourt chaque nombre de la liste des nombres.
        if x % 2 == 0 : cette condition vérifie si le nombre x actuel est pair. S'il est pair (c'est-à-dire que son reste lorsqu'il est divisé par 2 est égal à 0), on passe à la partie suivante.
        x**2 : Pour chaque nombre pair, cette expression calcule son carré (x**2).
        [x**2 for x in numbers if x % 2 == 0] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les nombres de la liste des nombres et, pour chaque nombre pair, calcule son carré et l'inclut dans la nouvelle liste.
    print(nombres) : Cette ligne de code imprime la liste originale des nombres sur la console.
    print(nombres_pairs_carrés) : Cette ligne de code affiche sur la console la liste squared_evens.
        \end{solution}
        

        \question
        Créer une liste de mots en majuscules à partir d'une phrase

Exemple de sortie

Voici un exemple de phrase.

['CECI', 'EST', 'UN', 'ÉCHANTILLON', 'PHRASE'].
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q515.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une phrase, la divise en mots et convertit chaque mot en majuscules à l'aide d'une compréhension de liste. Voici comment fonctionne ce code :

    sentence = "Ceci est un exemple de phrase" : Cette ligne initialise une variable nommée sentence et lui attribue la valeur "Ceci est un exemple de phrase".
    uppercase_words = [word.upper() for word in sentence.split()] : Cette ligne de code initialise une variable nommée uppercase_words et lui affecte le résultat d'une compréhension de liste.
        sentence.split() : Cette partie du code divise la phrase en une liste de mots. Par défaut, la phrase est divisée sur les espaces blancs, ce qui permet de séparer les mots.
        for word in sentence.split() : Cette partie met en place une boucle qui parcourt chaque mot de la liste de mots.
        word.upper() : Pour chaque mot de la liste, cette expression le convertit en majuscules à l'aide de la méthode .upper(). Cette méthode convertit tous les caractères de la chaîne en majuscules.
        [word.upper() for word in sentence.split()] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt la liste des mots, convertit chaque mot en majuscule et inclut le mot en majuscule dans la nouvelle liste.
    print(phrase) : Cette ligne de code imprime la phrase originale sur la console.
    print(mots_en_majuscules) : Cette ligne de code affiche la liste des mots en majuscules sur la console.
        \end{solution}
        

        \question
        Générer une liste de chaînes de caractères dont les voyelles ont été supprimées

Exemple de sortie

['pomme', 'banane', 'cerise']

['ppl', 'bnn', 'chrry']
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q516.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de chaînes de caractères, supprime les voyelles de chaque chaîne et stocke les chaînes modifiées dans une nouvelle liste appelée no_vowels. Voici comment fonctionne ce code :

    strings = ["apple", "banana", "cherry"] : Cette ligne initialise une variable nommée strings et lui assigne une liste contenant trois mots : "pomme", "banane" et "cerise".
    no_vowels = [''.join([char for char in word if char.lower() not in 'aeiou']) for word in strings] : Cette ligne de code initialise une variable nommée no_vowels et lui affecte le résultat d'une compréhension de liste.
        for word in strings : Cette partie met en place une boucle qui parcourt chaque mot de la liste des chaînes de caractères.
        for char in word if char.lower() not in 'aeiou' : Cette boucle interne parcourt chaque caractère (char) du mot actuel, mais uniquement si la version minuscule de char ne se trouve pas dans la chaîne "aeiou" (c'est-à-dire qu'elle filtre les voyelles). La méthode .lower() est utilisée pour traiter les voyelles majuscules et minuscules.
        ''.join(...) : Cette partie réunit les caractères filtrés pour former un mot modifié dont les voyelles ont été supprimées. ''.join(...) est utilisé pour concaténer les caractères sans espace ni séparateur.
        [''.join([char for char in word if char.lower() not in 'aeiou']) for word in strings] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les mots de la liste strings, supprime les voyelles de chaque mot et inclut les mots modifiés dans la nouvelle liste.
    print(strings) : Cette ligne de code imprime la liste originale des chaînes de caractères sur la console.
    print(no_vowels) : Cette ligne de code affiche la liste no_vowels sur la console.
        \end{solution}
        

        \question
        Créer une liste de nombres divisibles par 3 et 5 de 1 à 100

Exemple de résultat

[15, 30, 45, 60, 75, 90]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q517.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée une liste appelée divisible_par_3_et_5 en utilisant une compréhension de liste pour trouver et stocker les nombres entre 1 et 100 qui sont divisibles à la fois par 3 et par 5. Voici comment fonctionne le code :

    divisible_par_3_et_5 = [x for x in range(1, 101) if x % 3 == 0 and x % 5 == 0] : Cette ligne de code initialise une variable nommée divisible_par_3_et_5 et lui affecte le résultat d'une compréhension de liste.
        for x in range(1, 101) : Cette partie met en place une boucle qui parcourt les nombres de 1 à 100 (inclus). La fonction range(1, 101) génère une séquence de nombres commençant par 1 et se terminant par 100.
        if x % 3 == 0 and x % 5 == 0 : Cette condition vérifie si la valeur actuelle de x est divisible à la fois par 3 et par 5. L'opérateur % calcule le reste lorsque x est divisé par 3 et 5. Si le reste est égal à 0 pour les deux divisions, cela signifie que x est divisible à la fois par 3 et par 5.
        [x for x in range(1, 101) if x % 3 == 0 and x % 5 == 0] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les nombres de l'intervalle spécifié (1 à 100) et, pour chaque nombre qui est divisible par 3 et 5, l'inclut dans la nouvelle liste.
    print(divisible_par_3_et_5) : Cette ligne de code imprime la liste divisible_par_3_et_5 sur la console.
        \end{solution}
        

        \question
        Générer une liste de nombres dont les signes sont inversés

Exemple de sortie

[-2, 3, -5, 7, -11]

[2, -3, 5, -7, 11]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q518.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de nombres, annule chaque nombre (change son signe en son opposé) et stocke les nombres annulés dans une nouvelle liste appelée signes_opposés. Voici comment fonctionne ce code :

    nombres = [-2, 3, -5, 7, -11] : Cette ligne initialise une variable nommée numbers et lui affecte une liste contenant cinq nombres, dont certains sont négatifs.
    Signes_opposés = [-x for x in numbers] : Cette ligne de code initialise une variable nommée opposite_signs et lui affecte le résultat de la compréhension d'une liste.
        for x in numbers : Cette partie met en place une boucle qui parcourt chaque nombre x de la liste des nombres.
        -x : Pour chaque nombre de la liste, cette expression l'annule en plaçant un signe moins devant lui. Le signe de chaque nombre est donc inversé.
        [-x for x in numbers] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les nombres de la liste des nombres et, pour chaque nombre, l'annule et inclut le nombre annulé dans la nouvelle liste.
    print(nombres) : Cette ligne de code imprime la liste originale des nombres sur la console.
    print(signes_opposés) : Cette ligne de code imprime la liste des signes_opposés sur la console.
        \end{solution}
        

        \question
        Créer une liste de mots avec leur longueur à partir d'une phrase

Exemple de sortie

Voici un exemple de phrase.

[('This', 4), ('is', 2), ('a', 1), ('sample', 6), ('sentence.', 9)]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q519.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une phrase, la divise en mots et associe chaque mot à sa longueur correspondante (nombre de caractères). Il stocke ensuite ces paires dans une nouvelle liste appelée word_lengths. Voici comment fonctionne le code :

    sentence = "Ceci est un exemple de phrase" : Cette ligne initialise une variable nommée sentence et lui attribue la valeur "Ceci est un exemple de phrase."
    word_lengths = [(word, len(word)) for word in sentence.split()] : Cette ligne de code initialise une variable nommée word_lengths et lui affecte le résultat d'une compréhension de liste.
        sentence.split() : Cette partie du code divise la phrase en une liste de mots. Par défaut, la phrase est divisée sur les espaces blancs, ce qui permet de séparer les mots.
        for word in sentence.split() : Cette partie met en place une boucle qui parcourt chaque mot de la liste de mots.
        (mot, len(mot)) : Pour chaque mot de la liste, cette expression crée un tuple contenant deux éléments : le mot original et la longueur du mot len(word) .
        [(word, len(word)) for word in sentence.split()] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les mots de la liste de phrases, associe chaque mot à sa longueur et inclut ces paires (tuples) dans la nouvelle liste.
    print(phrase) : Cette ligne de code imprime la phrase originale sur la console.
    print(longueur_des_mots) : Cette ligne de code imprime la liste des longueurs de mots sur la console.
        \end{solution}
        

        \question
        Générer une liste de nombres positifs à partir d'une autre liste

Exemple de sortie

[1, -2, 3, -4, 5, -6]

[1, 3, 5]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q520.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de nombres, filtre les nombres positifs et les stocke dans une nouvelle liste appelée nombres_positifs. Voici comment fonctionne ce code :

    nombres = [1, -2, 3, -4, 5, -6] : Cette ligne initialise une variable nommée nombres et lui affecte une liste contenant six nombres, dont certains sont négatifs.
    nombres_positifs = [x for x in numbers if x > 0] : Cette ligne de code initialise une variable nommée nombres_positifs et lui affecte le résultat de la compréhension d'une liste.
        for x in numbers : Cette partie met en place une boucle qui parcourt chaque nombre x de la liste des nombres.
        if x > 0 : cette condition vérifie si le nombre actuel x est supérieur à 0. Si x est positif, on passe à la partie suivante.
        [x for x in numbers if x > 0] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les nombres de la liste des nombres et, pour chaque nombre positif, l'inclut dans la nouvelle liste.
    print(nombres) : Cette ligne de code imprime la liste originale des nombres sur la console.
    print(nombres_positifs) : Cette ligne de code imprime la liste des nombres positifs sur la console.
        \end{solution}
        

        \question
        Générer une liste de nombres qui sont des carrés parfaits de 1 à 100

Exemple de sortie

[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q521.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée une liste appelée perfect_squares en utilisant une compréhension de liste pour trouver et stocker des nombres carrés parfaits entre 1 et 100. Voici comment fonctionne le code :

    perfect_squares = [x for x in range(1, 101) if int(x**0.5)**2 == x] : Cette ligne de code initialise une variable nommée perfect_squares et lui affecte le résultat d'une compréhension de liste.
        for x in range(1, 101) : Cette partie met en place une boucle qui parcourt les nombres de 1 à 100 (inclus). La fonction range(1, 101) génère une séquence de nombres commençant par 1 et se terminant par 100.
        if int(x**0.5)**2 == x : Il s'agit d'une condition qui vérifie si la valeur actuelle de x est un carré parfait. Pour déterminer si x est un carré parfait, il calcule la racine carrée de x en utilisant x**0,5, l'arrondit à l'entier le plus proche en utilisant int(), élève le résultat au carré et le compare au x original.
        [x for x in range(1, 101) if int(x**0.5)**2 == x] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les nombres de l'intervalle spécifié (1 à 100) et, pour chaque nombre qui est un carré parfait, l'inclut dans la nouvelle liste.
    print(carrés_parfaits) : Cette ligne de code imprime la liste des carrés parfaits sur la console.
        \end{solution}
        

        \question
        Créer une liste de nombres avec leurs valeurs absolues

Exemple de sortie

[-2, 3, -5, 7, -11]

[2, 3, 5, 7, 11]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q522.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de nombres, calcule leurs valeurs absolues et les stocke dans une nouvelle liste appelée absolute_values. Voici comment fonctionne ce code :

    nombres = [-2, 3, -5, 7, -11] : Cette ligne initialise une variable nommée numbers et lui affecte une liste contenant cinq nombres, dont certains sont négatifs.
    valeurs_absolues = [abs(x) for x in numbers] : Cette ligne de code initialise une variable nommée valeurs_absolues et lui affecte le résultat de la compréhension d'une liste.
        for x in numbers : Cette partie met en place une boucle qui parcourt chaque nombre x de la liste des nombres.
        abs(x) : Pour chaque nombre de la liste, cette expression calcule sa valeur absolue à l'aide de la fonction abs(). La fonction abs() renvoie la magnitude (valeur positive) d'un nombre, en supprimant le signe négatif si le nombre est négatif.
        [abs(x) for x in numbers] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les nombres de la liste des nombres et, pour chaque nombre, calcule sa valeur absolue et l'inclut dans la nouvelle liste.
    print(nombres) : Cette ligne de code imprime la liste originale des nombres sur la console.
    print(valeurs_absolues) : Cette ligne de code imprime la liste des valeurs absolues sur la console.
        \end{solution}
        

        \question
        Générer une liste de lettres majuscules en utilisant les valeurs ASCII

Exemple de sortie

['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q523.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python génère une liste appelée uppercase_letters en utilisant une compréhension de liste pour créer des lettres majuscules de l'alphabet anglais. Pour ce faire, il utilise la fonction chr() pour convertir les valeurs ASCII en caractères. Voici comment fonctionne le code :

    uppercase_letters = [chr(code) for code in range(65, 91)] : Cette ligne initialise une variable nommée uppercase_letters et lui affecte le résultat d'une compréhension de liste.
        for code in range(65, 91) : Cette partie met en place une boucle qui parcourt les valeurs ASCII comprises entre 65 et 90 (inclus). Dans le tableau ASCII, ces valeurs correspondent aux lettres majuscules "A" à "Z".
        chr(code) : Pour chaque valeur ASCII comprise dans la plage spécifiée, cette expression utilise la fonction chr() pour la convertir en caractère correspondant. chr() prend une valeur ASCII en entrée et renvoie le caractère associé à cette valeur.
        [chr(code) for code in range(65, 91)] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les valeurs ASCII des lettres majuscules et inclut les caractères correspondants dans la nouvelle liste.
    print(lettres_majuscules) : Cette ligne de code imprime la liste des lettres majuscules sur la console.
        \end{solution}
        

        \question
        Créer une liste de mots dont la longueur est supérieure à 3 à partir d'une phrase

Exemple de sortie

Voici un exemple de phrase.

['Ceci', 'échantillon', 'phrase.']
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q524.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une phrase, la divise en mots et crée une nouvelle liste appelée mots_longs contenant uniquement des mots de plus de 3 caractères. Voici comment fonctionne le code :

    sentence = "Ceci est un exemple de phrase" : Cette ligne initialise une variable nommée sentence et lui attribue la valeur "Ceci est un exemple de phrase".
    mots_longs = [word for word in sentence.split() if len(word) > 3] : Cette ligne de code initialise une variable nommée mots_longs et lui affecte le résultat d'une compréhension de liste.
        sentence.split() : Cette partie du code divise la phrase en une liste de mots. Par défaut, la phrase est divisée sur les espaces blancs, ce qui permet de séparer les mots.
        for word in sentence.split() : Cette partie met en place une boucle qui parcourt chaque mot de la liste de mots.
        if len(word) > 3 : il s'agit d'une condition qui vérifie si la longueur (nombre de caractères) du mot actuel est supérieure à 3.
        [word for word in sentence.split() if len(word) > 3] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les mots de la liste de phrases, n'inclut que les mots dont la longueur est supérieure à 3 et les inclut dans la nouvelle liste.
    print(phrase) : Cette ligne de code imprime la phrase originale sur la console.
    print(mots_longs) : Cette ligne de code imprime la liste des mots longs sur la console.
        \end{solution}
        

        \question
        Générer une liste de carrés de nombres pairs de 1 à 20

Exemple de sortie

[4, 16, 36, 64, 100, 144, 196, 256, 324, 400]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q525.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée une liste appelée even_squares en utilisant une compréhension de liste pour calculer le carré des nombres pairs de 2 à 20. Voici comment fonctionne le code :

    even_squares = [x**2 for x in range(2, 21, 2)] : Cette ligne de code initialise une variable nommée even_squares et lui affecte le résultat d'une compréhension de liste.
        for x in range(2, 21, 2) : Cette partie met en place une boucle qui parcourt les nombres pairs de 2 à 20 (inclus). La fonction range(2, 21, 2) génère une séquence de nombres pairs commençant à 2 et se terminant à 20, avec un pas de 2.
        x**2 : Pour chaque nombre pair, cette expression calcule son carré (x**2).
        [x**2 for x in range(2, 21, 2)] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les nombres pairs dans l'intervalle spécifié et, pour chaque nombre pair, calcule son carré et l'inclut dans la nouvelle liste.
    print(even_squares) : Cette ligne de code imprime la liste even_squares sur la console.
        \end{solution}
        

        \question
        Créer une liste de caractères et leurs valeurs ASCII

Exemple de sortie

Bonjour à tous !

[('H', 72), ('e', 101), ('l', 108), ('l', 108), ('o', 111), (',', 44), (' ', 32), ('w', 119), ('o', 111), ('r', 114), ('l', 108), ('d', 100), ('!', 33)]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q526.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une chaîne de caractères, parcourt ses caractères et associe chaque caractère à sa valeur ASCII à l'aide d'une liste de compréhension. Voici comment fonctionne ce code :

    string = "Hello, world !": Cette ligne initialise une variable nommée string et lui affecte la valeur "Hello, world !".
    char_ascii = [(char, ord(char)) for char in string] : Cette ligne de code initialise une variable nommée char_ascii et lui affecte le résultat d'une compréhension de liste.
        for char in string : Cette partie met en place une boucle qui parcourt chaque caractère char de la chaîne.
        (char, ord(char)) : Pour chaque caractère de la chaîne, cette expression crée un tuple contenant deux éléments : le caractère original char et sa valeur ASCII obtenue à l'aide de la fonction ord(). La fonction ord() prend un caractère en entrée et renvoie la valeur ASCII correspondante.
        [(char, ord(char)) for char in string] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les caractères de la chaîne, associe chaque caractère à sa valeur ASCII et inclut ces paires (tuples) dans la nouvelle liste.
    print(string) : Cette ligne de code imprime la chaîne originale sur la console.
    print(char_ascii) : cette ligne de code imprime la liste char_ascii sur la console.
        \end{solution}
        

        \question
        Générer une liste de tuples contenant deux nombres dont la somme est paire

Exemple de sortie

[(1, 1), (1, 3), (1, 5), (1, 7), (1, 9), (2, 2), (2, 4), (2, 6), (2, 8), (2, 10), (3, 1), (3, 3), (3, 5), (3, 7), (3, 9), (4, 2), (4, 4), (4, 6), (4, 8), (4, 10), (5, 1), (5, 3), (5, 5), (5, 7), (5, 9), (6, 2), (6, 4), (6, 6), (6, 8), (6, 10), (7, 1), (7, 3), (7, 5), (7, 7), (7, 9), (8, 2), (8, 4), (8, 6), (8, 8), (8, 10), (9, 1), (9, 3), (9, 5), (9, 7), (9, 9), (10, 2), (10, 4), (10, 6), (10, 8), (10, 10)]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q527.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée une liste appelée even_sum_tuples en utilisant une compréhension de liste imbriquée pour générer des tuples de paires de nombres entre 1 et 10 dont la somme est paire. Voici comment fonctionne le code :

    even_sum_tuples = [(x, y) for x in range(1, 11) for y in range(1, 11) if (x + y) % 2 == 0] : Cette ligne de code initialise une variable appelée even_sum_tuples et lui affecte le résultat d'une compréhension de liste.
        for x in range(1, 11) : Cette partie du code met en place la boucle extérieure, qui parcourt les nombres de 1 à 10 (inclus). Elle génère des valeurs pour x.
        for y in range(1, 11) : Cette partie met en place la boucle interne, qui parcourt également les nombres de 1 à 10 (inclus). Elle génère des valeurs pour y.
        if (x + y) % 2 == 0 : il s'agit d'une condition qui vérifie si la somme de x et de y est paire. Si la somme est paire (c'est-à-dire que le reste de la somme divisée par 2 est égal à 0), on passe à la partie suivante.
        [(x, y) for x in range(1, 11) for y in range(1, 11) if (x + y) % 2 == 0] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt toutes les paires possibles de nombres (x, y) de 1 à 10 et inclut dans la nouvelle liste les paires pour lesquelles la somme de x et de y est paire.
    print(even_sum_tuples) : Cette ligne de code affiche la liste even_sum_tuples sur la console.
        \end{solution}
        

        \question
        Générer une liste de paires de nombres où la somme de chaque paire est première.

Exemple de résultat

[(1, 1), (1, 2), (1, 4), (1, 6), (1, 10), (2, 1), (2, 3), (2, 5), (2, 9), (3, 2), (3, 4), (3, 8), (3, 10), (4, 1), (4, 3), (4, 7), (4, 9), (5, 2), (5, 6), (5, 8), (6, 1), (6, 5), (6, 7), (7, 4), (7, 6), (7, 10), (8, 3), (8, 5), (8, 9), (9, 2), (9, 4), (9, 8), (9, 10), (10, 1), (10, 3), (10, 7), (10, 9)]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q528.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python définit une fonction is_prime(n) pour vérifier si un nombre donné n est premier ou non. Il crée ensuite une liste appelée prime_sum_pairs à l'aide d'une compréhension de liste imbriquée pour générer des paires de nombres entre 1 et 10 dont la somme est un nombre premier. Voici comment fonctionne le code :

    def is_prime(n) : Cette ligne définit une fonction nommée is_prime qui prend un entier n en entrée et renvoie True si n est premier et False sinon. La fonction vérifie d'abord si n est inférieur ou égal à 1 et renvoie False dans ce cas. Elle parcourt ensuite les nombres compris entre 2 et la racine carrée de n et vérifie si n est divisible par l'un de ces nombres. S'il trouve un diviseur, il renvoie False. Si aucun diviseur n'est trouvé, il renvoie True, indiquant que n est premier.
    prime_sum_pairs = [(x, y) for x in range(1, 11) for y in range(1, 11) if is_prime(x + y)] : Cette ligne de code initialise une variable nommée prime_sum_pairs et lui affecte le résultat de la compréhension d'une liste imbriquée.
        for x in range(1, 11) : Cette partie du code met en place la boucle extérieure, qui parcourt les nombres de 1 à 10 (inclus). Elle génère des valeurs pour x.
        for y in range(1, 11) : Cette partie met en place la boucle interne, qui parcourt également les nombres de 1 à 10 (inclus). Elle génère des valeurs pour y.
        if is_prime(x + y) : Il s'agit d'une condition qui vérifie si la somme de x et de y est première en appelant la fonction is_prime avec x + y comme argument.
        [(x, y) for x in range(1, 11) for y in range(1, 11) if is_prime(x + y)] : Il s'agit de la compréhension de la liste imbriquée elle-même. Elle parcourt toutes les paires possibles de nombres (x, y) de 1 à 10 et inclut dans la nouvelle liste les paires pour lesquelles la somme de x et de y est première.
    print(prime_sum_pairs) : Cette ligne de code imprime la liste des paires prime_sum_pairs sur la console.
        \end{solution}
        

        \question
        Créer une liste de chaînes de caractères dont les premières lettres sont en majuscules

Exemple de sortie

['apple', 'banana', 'cherry']

['Pomme', 'Banane', 'Cerise']
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q529.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de chaînes de caractères, met en majuscule la première lettre de chaque mot de chaque chaîne et stocke les mots en majuscules dans une nouvelle liste appelée mots_capitalisés. Voici comment fonctionne ce code :

    strings = ["apple", "banana", "cherry"] : Cette ligne initialise une variable nommée strings et lui affecte une liste contenant trois chaînes.
    mots_capitalisés = [word.capitalize() for word in strings] : Cette ligne de code initialise une variable nommée mots_capitalisés et lui affecte le résultat de la compréhension d'une liste.
        for word in strings : Cette partie met en place une boucle qui parcourt chaque mot de la liste strings.
        word.capitalize() : Pour chaque chaîne de la liste, cette expression utilise la méthode capitalize() pour mettre en majuscule la première lettre de la chaîne. La méthode capitalize() met le premier caractère de la chaîne en majuscule et tous les autres caractères de la chaîne en minuscule.
        [word.capitalize() for word in strings] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les chaînes de la liste strings, met en majuscules la première lettre de chaque mot de chaque chaîne et inclut les mots en majuscules dans la nouvelle liste.
    print(strings) : Cette ligne de code imprime la liste originale des chaînes sur la console.
    print(mots_capitalisés) : Cette ligne de code affiche la liste des mots capitalisés sur la console.
        \end{solution}
        

        \question
        Générer une liste de tuples contenant des nombres et leurs carrés

Exemple de sortie

[(1, 1), (2, 4), (3, 9), (4, 16), (5, 25), (6, 36), (7, 49), (8, 64), (9, 81), (10, 100)]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q530.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée une liste appelée num_squares en utilisant une compréhension de liste pour générer des paires de nombres et leurs carrés. Voici comment fonctionne le code :

    num_squares = [(x, x**2) for x in range(1, 11)] : Cette ligne de code initialise une variable nommée num_squares et lui affecte le résultat d'une compréhension de liste.
        for x in range(1, 11) : Cette partie met en place une boucle qui parcourt les nombres de 1 à 10 (inclus). Elle génère des valeurs pour x.
        (x, x**2) : Pour chaque valeur de x, cette expression crée un tuple contenant deux éléments : la valeur originale x et son carré, calculé comme x**2.
        [(x, x**2) for x in range(1, 11)] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les nombres de l'intervalle spécifié (1 à 10) et associe chaque nombre à son carré, en incluant ces paires (tuples) dans la nouvelle liste.
    print(num_squares) : Cette ligne de code imprime la liste num_squares sur la console.
        \end{solution}
        

        \question
        Créer une liste de nombres où chaque nombre est doublé

Exemple de résultat

[1, 2, 3, 4, 5]

[2, 4, 6, 8, 10]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q531.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de nombres, multiplie chaque nombre par 2 et stocke les nombres doublés dans une nouvelle liste appelée nombres_doublés. Voici comment fonctionne ce code :

    nombres = [1, 2, 3, 4, 5] : Cette ligne initialise une variable nommée nombres et lui affecte une liste contenant cinq nombres.
    nombres_doublés = [x * 2 pour x dans nombres] : Cette ligne de code initialise une variable nommée nombres_doublés et lui affecte le résultat d'une compréhension de liste.
        for x in numbers : Cette partie met en place une boucle qui parcourt chaque nombre x de la liste des nombres.
        x * 2 : pour chaque nombre de la liste, cette expression calcule son double en multipliant x par 2.
        [x * 2 for x in numbers] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les nombres de la liste des nombres, double chaque nombre et inclut les nombres doublés dans la nouvelle liste.
    print(nombres) : Cette ligne de code imprime la liste originale des nombres sur la console.
    print(nombres_doublés) : Cette ligne de code affiche la liste des nombres doublés sur la console.
        \end{solution}
        

        \question
        Créer une liste de caractères non alphanumériques à partir d'une chaîne de caractères

Exemple de sortie

Bonjour à tous !

[',', ' ', '!']
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q532.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une chaîne, parcourt ses caractères et crée une nouvelle liste appelée non_alphanumeric contenant les caractères qui ne sont pas alphanumériques (ni lettres ni chiffres). Voici comment fonctionne ce code :

    string = "Hello, world !": Cette ligne initialise une variable nommée string et lui affecte la valeur "Hello, world !".
    non_alphanumeric = [char for char in string if not char.isalnum()] : Cette ligne de code initialise une variable nommée non_alphanumérique et lui affecte le résultat d'une compréhension de liste.
        for char in string : Cette partie met en place une boucle qui parcourt chaque caractère char de la chaîne.
        if not char.isalnum() : Il s'agit d'une condition qui vérifie si le caractère courant char n'est pas alphanumérique. La méthode char.isalnum() renvoie True si char est un caractère alphanumérique (une lettre ou un chiffre) et False dans le cas contraire. Le mot-clé not annule cette condition et sélectionne donc les caractères qui ne sont pas alphanumériques.
        [char for char in string if not char.isalnum()] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les caractères de la chaîne, n'inclut que ceux qui ne sont pas alphanumériques et les inclut dans la nouvelle liste.
    print(string) : Cette ligne de code imprime la chaîne originale sur la console.
    print(non_alphanumeric) : Cette ligne de code affiche la liste des caractères non alphanumériques sur la console.
        \end{solution}
        

        \question
        Générer une liste de nombres qui sont des puissances de 2 de 1 à 10

Exemple de sortie

[2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q533.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python génère une liste appelée powers_of_2 en utilisant une compréhension de liste pour calculer les puissances de 2 de 2^1 à 2^10. Voici comment fonctionne le code :

    puissances_de_2 = [2**x for x in range(1, 11)] : Cette ligne de code initialise une variable nommée puissances_de_2 et lui affecte le résultat d'une compréhension de liste.
        for x in range(1, 11) : Cette partie met en place une boucle qui parcourt les nombres de 1 à 10 (inclus). Elle génère des valeurs pour x.
        2**x : Pour chaque valeur de x, cette expression calcule 2 élevé à la puissance de x, ce qui est équivalent à 2^x.
        [2**x for x in range(1, 11)] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les valeurs de x dans l'intervalle spécifié (1 à 10) et calcule 2^x pour chaque valeur, en incluant les résultats dans la nouvelle liste.
    print(puissances_de_2) : Cette ligne de code imprime la liste des puissances_de_2 sur la console.
        \end{solution}
        

        \question
        Créer une liste de chaînes dont les caractères sont en majuscules

Exemple de sortie

['apple', 'banana', 'cherry']

['POMME', 'BANANE', 'CERISE']
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q534.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de chaînes de caractères et crée une nouvelle liste appelée uppercase_strings à l'aide d'une compréhension de liste. La nouvelle liste contient les mêmes mots, mais chaque mot est converti en majuscules à l'aide de la méthode upper(). Voici comment fonctionne le code :

    strings = ["apple", "banana", "cherry"] : Cette ligne initialise une variable nommée strings et lui affecte une liste contenant trois strings.
    uppercase_strings = [word.upper() for word in strings] : Cette ligne de code initialise une variable nommée uppercase_strings et lui affecte le résultat de la compréhension d'une liste.
        for word in strings : Cette partie met en place une boucle qui parcourt chaque mot de la liste des chaînes.
        word.upper() : Pour chaque chaîne de la liste, cette expression utilise la méthode upper() pour convertir toute la chaîne en majuscules. La méthode upper() convertit tous les caractères minuscules de la chaîne en leurs équivalents majuscules.
        [word.upper() for word in strings] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les chaînes de la liste strings, convertit chaque chaîne en majuscules et inclut les chaînes en majuscules dans la nouvelle liste.
    print(strings) : Cette ligne de code imprime la liste originale des chaînes de caractères sur la console.
    print(chaînes_en_majuscules) : Cette ligne de code affiche la liste des chaînes en majuscules sur la console.
        \end{solution}
        

        \question
        Générer une liste de tuples contenant des nombres pairs et impairs de 1 à 10

Exemple de sortie

[(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q535.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée une liste appelée even_odd_pairs en utilisant une compréhension de liste pour générer des paires de nombres consécutifs dont l'un est pair et l'autre impair. Voici comment fonctionne ce code :

    even_odd_pairs = [(x, x + 1) for x in range(1, 11, 2)] : Cette ligne de code initialise une variable nommée even_odd_pairs et lui affecte le résultat d'une compréhension de liste.
        for x in range(1, 11, 2) : Cette partie met en place une boucle qui parcourt les nombres impairs de 1 à 10 (inclus) avec un pas de 2. Elle génère des valeurs pour x.
        (x, x + 1) : Pour chaque nombre impair x, cette expression crée un tuple contenant deux éléments : le nombre impair original x et le nombre consécutif suivant x + 1.
        [(x, x + 1) for x in range(1, 11, 2)] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les nombres impairs dans l'intervalle spécifié (1 à 10) et associe chaque nombre impair à son nombre pair consécutif, en incluant ces paires (tuples) dans la nouvelle liste.
    print(even_odd_pairs) : Cette ligne de code affiche la liste even_odd_pairs sur la console.
        \end{solution}
        

        \question
        Créer une liste de mots avec leur longueur à partir d'une autre liste

Exemple de résultat

['apple', 'banana', 'cherry']

[5, 6, 6]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q536.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de mots et crée une nouvelle liste appelée word_lengths à l'aide d'une compréhension de liste. La nouvelle liste contient les longueurs des mots de la liste originale. Voici comment fonctionne le code :

    mots = ["pomme", "banane", "cerise"] : Cette ligne initialise une variable nommée words et lui affecte une liste contenant trois mots.
    word_lengths = [len(word) for word in words] : Cette ligne de code initialise une variable nommée word_lengths et lui affecte le résultat de la compréhension d'une liste.
        for word in words : Cette partie met en place une boucle qui parcourt chaque mot de la liste des mots.
        len(word) : Pour chaque mot de la liste, cette expression calcule la longueur du mot à l'aide de la fonction len(). La fonction len() renvoie le nombre de caractères (lettres) d'une chaîne.
        [len(word) for word in words] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les mots de la liste, calcule la longueur de chaque mot et inclut ces longueurs dans la nouvelle liste.
    print(words) : Cette ligne de code imprime la liste de mots originale sur la console.
    print(word_lengths) : Cette ligne de code affiche la liste word_lengths sur la console.
        \end{solution}
        

        \question
        Générer une liste de tuples contenant des nombres et leurs signes

Exemple de sortie

[-2, 3, -5, 7, -11]

[(-2, "négatif"), (3, "positif"), (-5, "négatif"), (7, "positif"), (-11, "négatif")]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q537.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de nombres et crée une nouvelle liste appelée num_signs à l'aide d'une compréhension de liste. La nouvelle liste contient des paires de nombres et leur signe associé ("positif" ou "négatif") selon que le nombre est supérieur ou non à zéro. Voici comment fonctionne le code :

    nombres = [-2, 3, -5, 7, -11] : Cette ligne initialise une variable nommée numbers et lui affecte une liste contenant cinq nombres, dont certains sont négatifs.
    num_signs = [(x, 'positif') if x > 0 else (x, 'négatif') for x in numbers] : Cette ligne de code initialise une variable nommée num_signs et lui affecte le résultat de la compréhension d'une liste.
        for x in numbers : Cette partie met en place une boucle qui parcourt chaque nombre x dans la liste des nombres.
        (x, "positif") si x > 0 sinon (x, "négatif") : Pour chaque nombre de la liste, cette expression vérifie si x est supérieur à 0. Si x est supérieur à 0, elle crée un tuple contenant le nombre x et la chaîne "positive". Si x n'est pas supérieur à 0 (c'est-à-dire qu'il est nul ou négatif), elle crée un tuple contenant le nombre x et la chaîne "negative".
        [(x, 'positif') if x > 0 else (x, 'négatif') for x in numbers] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les nombres de la liste des nombres, détermine le signe de chaque nombre et associe chaque nombre au signe qui lui est associé, en incluant ces paires (tuples) dans la nouvelle liste.
    print(nombres) : Cette ligne de code imprime la liste originale des nombres sur la console.
    print(num_signs) : Cette ligne de code affiche la liste num_signs sur la console.
        \end{solution}
        

        \question
        Créer une liste de chaînes de caractères dont les voyelles sont remplacées par des astérisques.

Exemple de résultat

['apple', 'banana', 'cherry']

['*ppl*', 'b*n*n*', 'ch*rry']
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q538.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            
        \end{solution}
        

        \question
        Générer une liste de chaînes de caractères dont les premières lettres ont été supprimées

Exemple de sortie

['apple', 'banana', 'cherry']

['pple', 'anana', 'herry']
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q539.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de chaînes de caractères et crée une nouvelle liste appelée without_first_letters à l'aide d'une compréhension de liste. La nouvelle liste contient les mêmes mots que la liste originale, mais sans les premières lettres. Voici comment fonctionne le code :

    strings = ["apple", "banana", "cherry"] : Cette ligne initialise une variable nommée strings et lui affecte une liste contenant trois mots.
    without_first_letters = [word[1 :] for word in strings] : Cette ligne de code initialise une variable nommée without_first_letters et lui affecte le résultat d'une compréhension de liste.
        for word in strings : Cette partie met en place une boucle qui parcourt chaque mot de la liste des chaînes de caractères.
        word[1 :]: Pour chaque mot de la liste, cette expression découpe le mot à partir du deuxième caractère (index 1) et inclut tous les caractères après le premier.
        [word[1 :] for word in strings] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les mots de la liste strings, supprime la première lettre de chaque mot et inclut les mots modifiés dans la nouvelle liste.
    print(strings) : Cette ligne de code imprime la liste originale des chaînes de caractères sur la console.
    print(sans_premières_lettres) : Cette ligne de code affiche la liste sans_premières_lettres sur la console.
        \end{solution}
        

        \question
        Créer une liste de nombres avec leurs valeurs réciproques

Exemple de résultat

[2, 3, 4, 5, 6]

[0.5, 0.3333333333333333, 0.25, 0.2, 0.16666666666666666]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q540.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de nombres et crée une nouvelle liste appelée reciprocal_values à l'aide d'une compréhension de liste. La nouvelle liste contient les valeurs réciproques (inverses) des nombres de la liste originale. Voici comment fonctionne le code :

    nombres = [2, 3, 4, 5, 6] : Cette ligne initialise une variable nommée numbers et lui affecte une liste contenant cinq nombres.
    valeurs_réciproques = [1/x pour x dans nombres] : Cette ligne de code initialise une variable nommée valeurs_réciproques et lui affecte le résultat d'une compréhension de liste.
        for x in numbers : Cette partie met en place une boucle qui parcourt chaque nombre x dans la liste des nombres.
        1/x : Pour chaque nombre de la liste, cette expression calcule la valeur réciproque (inverse) en divisant 1 par x.
        [1/x for x in numbers] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les nombres de la liste, calcule la valeur réciproque de chaque nombre et inclut ces valeurs réciproques dans la nouvelle liste.
    print(nombres) : Cette ligne de code imprime la liste originale des nombres sur la console.
    print(valeurs_réciproques) : Cette ligne de code imprime la liste des valeurs réciproques sur la console.
        \end{solution}
        

        \question
        Générer une liste de tuples contenant des nombres et leurs carrés si le nombre est premier.

Exemple de sortie

[(2, 4), (3, 9), (5, 25), (7, 49)]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q541.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python définit une fonction is_prime(n) qui vérifie si un nombre donné n est premier ou non. Il utilise ensuite une compréhension de liste pour générer des paires de nombres premiers et leurs carrés dans un intervalle spécifié. Voici comment fonctionne le code :

    def is_prime(n) : Cette ligne définit une fonction nommée is_prime qui prend un seul argument n et renvoie True si n est premier et False sinon.
        if n <= 1: : Cette ligne vérifie si n est inférieur ou égal à 1. Si c'est le cas, la fonction renvoie immédiatement False car 1 et tous les nombres négatifs ne sont pas premiers par définition.
        for i in range(2, int(n**0.5) + 1) : Cette ligne met en place une boucle qui parcourt les nombres de 2 jusqu'à la racine carrée de n (incluse).
        if n % i == 0: : À l'intérieur de la boucle, la fonction vérifie si n est divisible par i (c'est-à-dire si n modulo i est égal à 0). Si c'est le cas, la fonction renvoie immédiatement False car n n'est pas premier s'il a un diviseur autre que 1 et lui-même.
        Si la boucle se termine sans trouver d'autres diviseurs que 1 et n, la fonction renvoie True, indiquant que n est premier.
    prime_num_squares = [(x, x**2) for x in range(1, 11) if is_prime(x)] : Cette ligne de code initialise une variable nommée prime_num_squares et lui affecte le résultat d'une compréhension de liste.
        for x in range(1, 11) : Cette partie met en place une boucle qui parcourt les nombres de 1 à 10 (inclus). Elle génère des valeurs pour x.
        (x, x**2) : Pour chaque valeur de x, cette expression crée un tuple contenant deux éléments : la valeur originale x et son carré, calculé comme x**2.
        if is_prime(x) : Cette condition vérifie si la valeur actuelle de x est première en appelant la fonction is_prime. Si x est premier, la paire (x, x^2) est incluse dans la nouvelle liste.
    print(prime_num_squares) : Cette ligne de code affiche la liste prime_num_squares sur la console.
        \end{solution}
        

        \question
        Créer une liste de mots avec leurs caractères triés.

Exemple de sortie

['apple', 'banana', 'cherry']

['aelpp', 'aaabnn', 'cehrry']
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q542.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de mots et crée une nouvelle liste appelée sorted_chars à l'aide d'une compréhension de liste. La nouvelle liste contient les mêmes mots que la liste originale, mais avec leurs caractères triés par ordre alphabétique. Voici comment fonctionne le code :

    mots = ["pomme", "banane", "cerise"] : Cette ligne initialise une variable nommée words et lui affecte une liste contenant trois mots.
    sorted_chars = [''.join(sorted(word)) for word in words] : Cette ligne de code initialise une variable nommée sorted_chars et lui affecte le résultat d'une compréhension de liste.
        for word in words : Cette partie met en place une boucle qui parcourt chaque mot de la liste des mots.
        sorted(word) : Pour chaque mot de la liste, cette expression trie ses caractères par ordre alphabétique à l'aide de la fonction sorted(). La fonction sorted() renvoie une liste de caractères triés.
        ''.join(sorted(word)) : Cette partie réunit les caractères triés en une seule chaîne de caractères à l'aide de la méthode join(). Le résultat est un mot dont les caractères sont triés par ordre alphabétique.
        [''.join(sorted(word)) for word in words] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les mots de la liste words, trie les caractères de chaque mot et inclut les mots triés dans la nouvelle liste.
    print(words) : Cette ligne de code imprime la liste de mots originale sur la console.
    print(sorted_chars) : Cette ligne de code affiche la liste des caractères triés sur la console.
        \end{solution}
        

        \question
        Générer une liste de tuples contenant des nombres et leurs cubes

Exemple de sortie

[(1, 1), (2, 8), (3, 27), (4, 64), (5, 125), (6, 216), (7, 343), (8, 512), (9, 729), (10, 1000)]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q543.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension de liste pour générer des paires de nombres et leurs cubes pour des valeurs de x allant de 1 à 10. Voici comment fonctionne le code :

    num_cubes = [(x, x**3) for x in range(1, 11)] : Cette ligne de code initialise une variable nommée num_cubes et lui affecte le résultat d'une compréhension de liste.
        for x in range(1, 11) : Cette partie met en place une boucle qui parcourt les nombres de 1 à 10 (inclus). Elle génère des valeurs pour x.
        (x, x**3) : Pour chaque valeur de x, cette expression crée un tuple contenant deux éléments : la valeur originale x et son cube, calculé comme x**3.
        [(x, x**3) for x in range(1, 11)] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les valeurs de x dans l'intervalle spécifié (1 à 10) et associe chaque valeur à son cube, en incluant ces paires (tuples) dans la nouvelle liste.
    print(num_cubes) : Cette ligne de code imprime la liste num_cubes sur la console.
        \end{solution}
        

        \question
        Créer une liste de voyelles minuscules à partir d'une chaîne de caractères

Exemple de résultat

Bonjour à tous !

['e', 'o', 'o']
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q544.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une chaîne et crée une nouvelle liste appelée voyelles en utilisant une compréhension de liste. La nouvelle liste contient toutes les voyelles (minuscules et majuscules) de la chaîne originale. Voici comment fonctionne le code :

    string = "Hello, world !": Cette ligne initialise une variable nommée string et lui affecte une chaîne contenant le texte "Hello, world !"
    voyelles = [char for char in string if char.lower() in 'aeiou'] : Cette ligne de code initialise une variable nommée voyelles et lui affecte le résultat d'une compréhension de liste.
        for char in string : Cette partie met en place une boucle qui parcourt chaque caractère char de la chaîne.
        char.lower() in 'aeiou' : Pour chaque caractère de la chaîne, cette expression convertit d'abord le caractère en minuscules à l'aide de la méthode lower() afin de garantir l'insensibilité à la casse. Elle vérifie ensuite si le caractère minuscule se trouve dans la chaîne "aeiou", qui contient toutes les voyelles minuscules.
        [char for char in string if char.lower() in 'aeiou'] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les caractères de la chaîne, vérifie si chaque caractère est une voyelle minuscule et inclut les voyelles dans la nouvelle liste.
    print(string) : Cette ligne de code imprime la chaîne originale sur la console.
    print(voyelles) : Cette ligne de code imprime la liste des voyelles sur la console.
        \end{solution}
        

        \question
        Créer une liste de nombres avec leurs racines carrées

Exemple de résultat

[1, 4, 9, 16, 25]

[1.0, 2.0, 3.0, 4.0, 5.0]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q545.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python calcule la racine carrée de chaque nombre d'une liste à l'aide de la fonction math.sqrt() et stocke les résultats dans une nouvelle liste. Voici comment fonctionne le code :

    import math : Cette ligne importe le module math, qui contient diverses fonctions et constantes mathématiques, dont la fonction sqrt() pour le calcul des racines carrées.
    numbers = [1, 4, 9, 16, 25] : Cette ligne initialise une variable nommée numbers et lui affecte une liste contenant cinq nombres.
    racines_carrées = [math.sqrt(x) for x in numbers] : Cette ligne de code initialise une variable nommée racines_carrées et lui affecte le résultat de la compréhension d'une liste.
        for x in numbers : Cette partie met en place une boucle qui parcourt chaque nombre x dans la liste des nombres.
        math.sqrt(x) : Pour chaque nombre de la liste, cette expression calcule la racine carrée de x à l'aide de la fonction math.sqrt() du module math.
        [math.sqrt(x) for x in numbers] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les nombres de la liste des nombres, calcule la racine carrée de chaque nombre et inclut ces racines carrées dans la nouvelle liste.
    print(nombres) : Cette ligne de code imprime la liste originale des nombres sur la console.
    print(racines_carrées) : Cette ligne de code affiche la liste des racines carrées sur la console.
        \end{solution}
        

        \question
        Générer une liste de nombres palindromes de 1 à 100

Exemple de sortie

[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q546.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python génère une liste appelée palindromes en utilisant une compréhension de liste. La liste contient des nombres de 1 à 100 qui sont des palindromes lorsque leurs chiffres sont inversés. Voici comment fonctionne le code :

    palindromes = [x for x in range(1, 101) if str(x) == str(x)[::-1]] : Cette ligne de code initialise une variable nommée palindromes et lui affecte le résultat d'une compréhension de liste.
        for x in range(1, 101) : Cette partie met en place une boucle qui parcourt les nombres de 1 à 100 (inclus). Elle génère des valeurs pour x.
        str(x) == str(x)[::-1] : Pour chaque nombre de la plage, cette expression convertit x en chaîne de caractères à l'aide de str(x) , puis vérifie si la représentation de x sous forme de chaîne est égale à son inverse, obtenu par str(x)[::-1]. Cette comparaison détermine si x est un palindrome ou non.
        [x for x in range(1, 101) if str(x) == str(x)[::-1]] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les nombres de l'intervalle spécifié (1 à 100), vérifie si chaque nombre est un palindrome et inclut les nombres palindromiques dans la nouvelle liste.
    print(palindromes) : Cette ligne de code imprime la liste des palindromes sur la console.
        \end{solution}
        

        \question
        Créer une liste de nombres avec leurs valeurs factorielles

Exemple de résultat

[2, 3, 4, 5]

[2, 6, 24, 120]
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q547.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python calcule la factorielle de chaque nombre d'une liste à l'aide de la fonction math.factorial() du module math et stocke les résultats dans une nouvelle liste. Voici comment fonctionne le code :

    import math : Cette ligne importe le module math, qui contient diverses fonctions mathématiques, dont la fonction factorial() pour le calcul des factorielles.
    numbers = [2, 3, 4, 5] : Cette ligne initialise une variable nommée numbers et lui affecte une liste contenant quatre nombres.
    factorielles = [math.factorial(x) for x in numbers] : Cette ligne de code initialise une variable nommée factorials et lui affecte le résultat de la compréhension d'une liste.
        for x in numbers : Cette partie met en place une boucle qui parcourt chaque nombre x de la liste des nombres.
        math.factorial(x) : Pour chaque nombre de la liste, cette expression calcule sa factorielle à l'aide de la fonction math.factorial() du module math.
        [math.factorial(x) for x in numbers] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les nombres de la liste des nombres, calcule la factorielle de chaque nombre et inclut ces factorielles dans la nouvelle liste.
    print(nombres) : Cette ligne de code imprime la liste originale des nombres sur la console.
    print(factorials) : Cette ligne de code imprime la liste des factorielles sur la console.
        \end{solution}
        

        \question
        Générer une liste de chaînes de caractères dont les voyelles ont été supprimées d'une phrase

Exemple de sortie

Voici un exemple de phrase avec quelques voyelles.

['Ths', 's', '', 'smpl', 'sntnc', 'wth', 'sm', 'vwls'].
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q548.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une phrase, la divise en mots et crée une nouvelle phrase dans laquelle toutes les voyelles (minuscules et majuscules) sont supprimées de chaque mot. Voici comment fonctionne le code :

    phrase = "Ceci est un exemple de phrase avec quelques voyelles" : Cette ligne initialise une variable nommée sentence et lui assigne une chaîne contenant la phrase d'entrée.
    no_vowels = [''.join([char for char in word if char.lower() not in 'aeiou']) for word in sentence.split()] : Cette ligne de code initialise une variable nommée no_vowels et lui affecte le résultat d'une compréhension de liste.
        for word in sentence.split() : Cette partie met en place une boucle qui parcourt chaque mot de la phrase. Elle divise la phrase en mots en utilisant sentence.split().
        [char for char in word if char.lower() not in 'aeiou'] : Pour chaque mot de la liste, cette expression parcourt chaque caractère char du mot et l'inclut dans une nouvelle liste uniquement s'il ne s'agit pas d'une voyelle. Elle vérifie que la version minuscule du caractère n'est pas dans la chaîne 'aeiou'.
        ''.join([char for char in word if char.lower() not in 'aeiou']) : Cette partie réunit les caractères de la liste (sans les voyelles) en une seule chaîne, formant ainsi un mot sans les voyelles.
        [''.join([char for char in word if char.lower() not in 'aeiou']) for word in sentence.split()] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les mots de la phrase, supprime les voyelles de chaque mot et inclut les mots modifiés dans la nouvelle liste.
    print(sentence) : Cette ligne de code imprime la phrase originale sur la console.
    print(no_vowels) : Cette ligne de code imprime la liste no_vowels (qui contient les mots modifiés) sur la console.
        \end{solution}
        

        \question
        Créer une liste de caractères qui sont des chiffres à partir d'une chaîne de caractères

Exemple de sortie

12345Bonjour67890

['1', '2', '3', '4', '5', '6', '7', '8', '9', '0']
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q549.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une chaîne et crée une nouvelle liste appelée digits en utilisant une compréhension de liste. La nouvelle liste ne contient que les chiffres de la chaîne originale. Voici comment fonctionne le code :

    string = "12345Hello67890" : Cette ligne initialise une variable nommée chaîne et lui attribue une chaîne contenant un mélange de chiffres et de caractères autres que des chiffres.
    digits = [char for char in string if char.isdigit()] : Cette ligne de code initialise une variable nommée digits et lui affecte le résultat d'une compréhension de liste.
        for char in string : Cette partie met en place une boucle qui parcourt chaque caractère char de la chaîne.
        char.isdigit() : Pour chaque caractère de la chaîne, cette expression vérifie si le caractère est un chiffre en utilisant la méthode isdigit(), qui renvoie True si le caractère est un chiffre et False dans le cas contraire.
        [char for char in string if char.isdigit()] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les caractères de la chaîne et n'inclut dans la nouvelle liste que les caractères qui sont des chiffres.
    print(string) : Cette ligne de code imprime la chaîne originale sur la console.
    print(chiffres) : Cette ligne de code imprime la liste des chiffres (qui contient les caractères numériques) sur la console.
        \end{solution}
        

        \question
        Liste d'éléments avec leur fréquence dans une liste

Exemple de sortie

[1, 2, 2, 3, 4, 4, 4, 5]

\{1 : 1, 2 : 2, 3 : 1, 4 : 3, 5 : 1\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q550.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python calcule la fréquence de chaque élément d'une liste et stocke les résultats dans un dictionnaire appelé element_frequencies. Voici comment fonctionne le code :

    nombres = [1, 2, 2, 3, 4, 4, 4, 5] : Cette ligne initialise une variable nommée numbers et lui assigne une liste contenant plusieurs nombres, y compris quelques doublons.
    element_frequencies = {num : numbers.count(num) for num in set(numbers)} : Cette ligne de code initialise une variable nommée fréquences_éléments et lui affecte le résultat de la compréhension d'un dictionnaire.
        set(numbers) : Cette partie convertit la liste des nombres en un ensemble, ce qui permet de supprimer les éléments en double et de ne conserver que les éléments uniques. Cette étape garantit que chaque élément unique n'est compté qu'une seule fois.
        {num : numbers.count(num) for num in set(numbers)} : Il s'agit de la compréhension du dictionnaire proprement dite. Elle parcourt les éléments uniques de l'ensemble et, pour chaque élément (num), compte le nombre de fois qu'il apparaît dans la liste originale numbers à l'aide de la méthode numbers.count(num). Le résultat est une paire clé-valeur dans le dictionnaire, où la clé est l'élément et la valeur est sa fréquence.
    print(numbers) : Cette ligne de code imprime la liste originale des nombres sur la console.
    print(element_frequencies) : Cette ligne de code imprime le dictionnaire element_frequencies (qui contient les fréquences des éléments) sur la console.
        \end{solution}
        

        \question
        Liste de mots dont la première et la dernière lettre ont été interverties

Exemple de sortie

['apple', 'banana', 'cherry', 'date']

['eppla', 'aananb', 'yherrc', 'eatd']
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q551.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de mots et crée une nouvelle liste appelée swapped_words à l'aide d'une compréhension de liste. Dans la nouvelle liste, la première et la dernière lettre de chaque mot sont interverties. Voici comment fonctionne le code :

    mots = ["pomme", "banane", "cerise", "date"] : Cette ligne initialise une variable nommée words et lui affecte une liste contenant quatre mots.
    swapped_words = [word[-1] + word[1:-1] + word[0] for word in words] : Cette ligne de code initialise une variable nommée swapped_words et lui affecte le résultat de la compréhension d'une liste.
        for word in words : Cette partie met en place une boucle qui parcourt chaque mot de la liste des mots.
        word[-1] : Cette partie extrait le dernier caractère du mot en utilisant l'indexation négative (-1).
        mot[1:-1] : Cette partie extrait les caractères du mot à partir du deuxième caractère (index 1) jusqu'au dernier caractère (index -1).
        word[0] : Cette partie extrait le premier caractère du mot en utilisant l'indexation (0).
        mot[-1] + mot[1:-1] + mot[0] : Ces parties combinent le dernier caractère, les caractères du milieu et le premier caractère pour former un nouveau mot dont la première et la dernière lettre sont interverties.
        [mot[-1] + mot[1:-1] + mot[0] pour mot dans mots] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les mots de la liste des mots et crée de nouveaux mots dont la première et la dernière lettre sont interverties, en incluant ces mots modifiés dans la nouvelle liste.
    print(mots) : Cette ligne de code imprime la liste de mots originale sur la console.
    print(mots_échangés) : Cette ligne de code imprime la liste swapped_words (qui contient les mots modifiés) sur la console.
        \end{solution}
        

        \question
        Liste des nombres avec leurs diviseurs

Exemple de sortie

[10, 15, 20, 25]

\{10 : [1, 2, 5, 10], 15 : [1, 3, 5, 15], 20 : [1, 2, 4, 5, 10, 20], 25 : [1, 5, 25]\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q552.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un dictionnaire appelé diviseurs où chaque paire clé-valeur représente un nombre de la liste des nombres et ses diviseurs. Voici comment fonctionne le code :

    nombres = [10, 15, 20, 25] : Cette ligne initialise une variable nommée numbers et lui affecte une liste contenant quatre nombres.
    diviseurs = {num : [x for x in range(1, num+1) if num % x == 0] for num in numbers} : Cette ligne de code initialise une variable nommée diviseurs et lui affecte le résultat d'une compréhension du dictionnaire.
        for num in numbers : Cette partie met en place une boucle qui parcourt chaque nombre num dans la liste des nombres.
        range(1, num+1) : Cette partie crée une plage de nombres allant de 1 à num (inclus). Il s'agit des diviseurs potentiels de num.
        [x for x in range(1, num+1) if num % x == 0] : Cette liste de compréhension parcourt les nombres de la plage et n'inclut que les nombres qui sont des diviseurs de num. Elle vérifie si num est divisible par x (c'est-à-dire si num % x == 0).
        {num : [x for x in range(1, num+1) if num % x == 0] for num in numbers} : Il s'agit de la compréhension du dictionnaire proprement dite. Il parcourt les nombres de la liste des nombres, calcule les diviseurs de chaque nombre et les stocke sous forme de paires clé-valeur dans le dictionnaire des diviseurs.
    print(nombres) : Cette ligne de code imprime la liste originale des nombres sur la console.
    print(diviseurs) : Cette ligne de code imprime le dictionnaire des diviseurs (qui contient les diviseurs de chaque nombre) sur la console.
        \end{solution}
        

        \question
        Liste des caractères qui sont des voyelles ou des consonnes

Exemple de sortie

['a', 'b', 'c', 'e', 'f', 'i', 'o']

['a', 'e', 'i', 'o']

['b', 'c', 'f']
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q553.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de caractères et les sépare en deux listes : l'une contenant les voyelles et l'autre les consonnes. Voici comment fonctionne le code :

    characters = ['a', 'b', 'c', 'e', 'f', 'i', 'o'] : Cette ligne initialise une variable nommée characters et lui affecte une liste contenant plusieurs caractères, dont des voyelles et des consonnes.
    voyelles = [char for char in characters if char.lower() in 'aeiou'] : Cette ligne de code initialise une variable nommée voyelles et lui affecte le résultat de la compréhension d'une liste.
        for char in characters : Cette partie met en place une boucle qui parcourt chaque caractère char dans la liste des caractères.
        char.lower() in 'aeiou' : Pour chaque caractère de la liste, cette expression convertit char en minuscules à l'aide de char.lower() pour garantir l'insensibilité à la casse et vérifie si le caractère minuscule se trouve dans la chaîne "aeiou", qui contient toutes les voyelles minuscules.
        [char for char in characters if char.lower() in 'aeiou'] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les caractères de la liste des caractères et n'inclut que les caractères qui sont des voyelles dans la nouvelle liste.
    consonnes = [char for char in characters if char.lower() not in 'aeiou'] : Cette ligne de code initialise une variable nommée consonnes et lui affecte le résultat d'une compréhension de liste.
        for char in characters : Cette partie met en place une boucle qui parcourt chaque caractère char de la liste des caractères.
        char.lower() not in 'aeiou' : Pour chaque caractère de la liste, cette expression convertit char en minuscules à l'aide de char.lower() pour garantir l'insensibilité à la casse et vérifie si le caractère minuscule ne se trouve pas dans la chaîne "aeiou", qui contient toutes les voyelles minuscules.
        [char for char in characters if char.lower() not in 'aeiou'] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les caractères de la liste characters et n'inclut dans la nouvelle liste que les caractères qui ne sont pas des voyelles.
    print(characters) : Cette ligne de code imprime la liste originale des caractères sur la console.
    print(voyelles) : Cette ligne de code imprime la liste des voyelles (qui contient les voyelles) sur la console.
    print(consonnes) : Cette ligne de code imprime la liste des consonnes (qui contient les consonnes) sur la console.
        \end{solution}
        

        \question
        Suppression des espaces dans les chaînes de caractères d'une liste

Exemple de sortie

[' hello ', ' world ', ' python ']

['hello', 'world', 'python']
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q554.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de chaînes et crée une nouvelle liste appelée trimmed, dans laquelle les espaces blancs de début et de fin (y compris les espaces, les tabulations et les caractères de retour à la ligne) sont supprimés de chaque chaîne. Voici comment fonctionne ce code :

    strings = [" hello ", " world ", " python "] : Cette ligne initialise une variable nommée strings et lui affecte une liste contenant trois chaînes, chacune d'entre elles comportant des espaces avant et arrière.
    trimmed = [string.strip() for string in strings] : Cette ligne de code initialise une variable nommée trimmed et lui affecte le résultat d'une compréhension de liste.
        for string in strings : Cette partie met en place une boucle qui parcourt chaque chaîne de la liste strings.
        string.strip() : Pour chaque chaîne de la liste, la méthode strip() est appelée pour supprimer les espaces blancs de début et de fin de la chaîne. Le résultat est une chaîne dont les espaces blancs ont été supprimés.
        [string.strip() for string in strings] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les chaînes de la liste strings, supprime les espaces de chaque chaîne et inclut les chaînes modifiées dans la nouvelle liste.
    print(strings) : Cette ligne de code imprime la liste originale des chaînes sur la console.
    print(trimmed) : Cette ligne de code imprime sur la console la liste élaguée (qui contient les chaînes modifiées avec les espaces blancs de début et de fin supprimés).
        \end{solution}
        

        \question
        Créer une liste de caractères qui ne sont pas des voyelles à partir d'une chaîne de caractères

Exemple de sortie

Bonjour à tous !

['H', 'l', 'l', ',', ' ', 'w', 'r', 'l', 'd', '!']
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q555.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une chaîne et crée une nouvelle liste appelée non_voyelles, qui contient tous les caractères de la chaîne originale qui ne sont pas des voyelles (les voyelles minuscules et majuscules sont prises en compte). Voici comment fonctionne le code :

    string = "Hello, world !": Cette ligne initialise une variable nommée string et lui assigne une chaîne contenant une phrase.
    non_voyelles = [char for char in string if char.lower() not in 'aeiou'] : Cette ligne de code initialise une variable nommée non_voyelles et lui affecte le résultat d'une compréhension de liste.
        for char in string : Cette partie met en place une boucle qui parcourt chaque caractère char de la chaîne.
        char.lower() not in 'aeiou' : Pour chaque caractère de la chaîne, cette expression convertit char en minuscules à l'aide de char.lower() pour garantir l'insensibilité à la casse et vérifie si le caractère minuscule ne se trouve pas dans la chaîne "aeiou", qui contient toutes les voyelles minuscules.
        [char for char in string if char.lower() not in 'aeiou'] : Il s'agit de la compréhension de la liste elle-même. Elle parcourt les caractères de la chaîne et n'inclut que les caractères qui ne sont pas des voyelles (minuscules et majuscules) dans la nouvelle liste.
    print(string) : Cette ligne de code imprime la chaîne originale sur la console.
    print(non_voyelles) : Cette ligne de code imprime la liste des non_voyelles (qui contient les caractères qui ne sont pas des voyelles) sur la console.
        \end{solution}
        

        \question
        DEBUT DES tuples
Carrés de nombres de 1 à 10 en tant que tuples

Exemple de sortie

(1, 4, 9, 16, 25, 36, 49, 64, 81, 100)
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q556.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python génère un tuple appelé carrés à l'aide d'une expression de générateur. Le tuple contient les carrés des nombres de 1 à 10. Voici comment fonctionne le code :

    carrés = tuple(x**2 for x in range(1, 11)) : Cette ligne de code initialise une variable nommée squares et lui affecte un tuple créé à l'aide d'une expression génératrice.
        x**2 for x in range(1, 11) : Cette partie du code utilise une expression génératrice pour générer les carrés des nombres compris entre 1 et 10.
            for x in range(1, 11) : Cette partie du code met en place une boucle qui parcourt les nombres de 1 à 10 en utilisant l'itérable range(1, 11).
            x**2 : Pour chaque valeur de x dans l'intervalle, il calcule le carré de x à l'aide de l'expression x**2.
        tuple(...) : Cette expression entoure l'expression du générateur et convertit les valeurs générées en un tuple.
    print(squares) : Cette ligne de code imprime le tuple squares sur la console.
        \end{solution}
        

        \question
        Les nombres pairs de 1 à 20 sous forme de tuples

Exemple de sortie

(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q557.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python génère un tuple appelé evens à l'aide d'une expression de générateur. Le tuple contient les nombres pairs de 1 à 20. Voici comment fonctionne le code :

    evens = tuple(x for x in range(1, 21) if x % 2 == 0) : Cette ligne de code initialise une variable nommée evens et lui affecte un tuple créé à l'aide d'une expression génératrice.
        x for x in range(1, 21) if x % 2 == 0 : Cette partie du code utilise une expression de générateur pour générer des nombres pairs de 1 à 20.
            for x in range(1, 21) : Cette partie du code met en place une boucle qui parcourt les nombres de 1 à 20 à l'aide de l'itérable range(1, 21).
            if x % 2 == 0 : pour chaque valeur de x dans l'intervalle, on vérifie si x est pair en évaluant x % 2 == 0, ce qui est vrai pour les nombres pairs et faux pour les nombres impairs.
        tuple(...) : Cette expression entoure l'expression du générateur et convertit les valeurs générées (nombres pairs) en un tuple.
    print(evens) : Cette ligne de code imprime le tuple evens sur la console.
        \end{solution}
        

        \question
        Tuple de caractères dans une chaîne

Exemple de sortie

bonjour

('h', 'e', 'l', 'l', 'o')
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q558.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python convertit une chaîne de caractères en un tuple appelé char_tuple, où chaque élément du tuple correspond à un caractère de la chaîne originale. Voici comment fonctionne le code :

    string = "hello" : Cette ligne initialise une variable nommée string et lui affecte la chaîne "hello".
    char_tuple = tuple(char for char in string) : Cette ligne de code initialise une variable nommée char_tuple et lui affecte un tuple créé à l'aide d'un générateur d'expressions.
        char for char in string : Cette partie du code utilise une expression de générateur pour parcourir chaque caractère char de la chaîne.
        tuple(...) : Cette partie du code entoure l'expression du générateur et convertit les caractères générés en un tuple.
    print(string) : Cette ligne de code imprime la chaîne de caractères originale sur la console.
    print(char_tuple) : Cette ligne de code imprime le n-uplet char_tuple (qui contient les caractères individuels de la chaîne) sur la console.
        \end{solution}
        

        \question
        Longueur des mots d'une phrase sous forme de tuples

Exemple de sortie

Voici un exemple de phrase

(4, 2, 1, 6, 8)
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q559.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python divise une phrase en mots et crée un tuple appelé word_lengths, où chaque élément du tuple correspond à la longueur d'un mot dans la phrase. Voici comment fonctionne le code :

    sentence = "Ceci est un exemple de phrase" : Cette ligne initialise une variable nommée sentence et lui affecte la chaîne de caractères "Ceci est un exemple de phrase".
    word_lengths = tuple(len(word) for word in sentence.split()) : Cette ligne de code initialise une variable nommée word_lengths et lui affecte un tuple créé à l'aide d'un générateur d'expressions.
        for word in sentence.split() : Cette partie du code utilise une expression de générateur pour parcourir chaque mot de la phrase. Pour ce faire, elle divise la phrase en mots à l'aide de sentence.split(), qui divise la phrase en fonction des espaces (le séparateur par défaut).
        len(word) : Pour chaque mot de la phrase, il calcule la longueur du mot à l'aide de la fonction len().
        tuple(...) : Cette fonction entoure l'expression du générateur et convertit les longueurs de mots générées en un tuple.
    print(phrase) : Cette ligne de code imprime la phrase originale sur la console.
    print(longueur_des_mots) : Cette ligne de code imprime le tuple word_lengths (qui contient les longueurs des mots de la phrase) sur la console.
        \end{solution}
        

        \question
        Les voyelles dans une phrase en tant que tuples

Exemple de sortie

Bonjour, comment allez-vous ?

('e', 'o', 'o', 'a', 'e', 'o', 'u')
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q560.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une phrase et crée un tuple appelé voyelles, qui contient tous les caractères voyelles de la phrase originale (les voyelles minuscules et majuscules sont prises en compte). Voici comment fonctionne le code :

    sentence = "Hello, how are you ?": Cette ligne initialise une variable nommée sentence et lui affecte la chaîne "Hello, how are you ?"
    voyelles = tuple(char for char in sentence if char.lower() in 'aeiou') : Cette ligne de code initialise une variable nommée vowels et lui affecte un tuple créé à l'aide d'un générateur d'expressions.
        for char in sentence : Cette partie met en place une boucle qui parcourt chaque caractère char dans la phrase.
        char.lower() in 'aeiou' : Pour chaque caractère de la phrase, cette expression convertit char en minuscules à l'aide de char.lower() pour garantir l'insensibilité à la casse et vérifie si le caractère minuscule se trouve dans la chaîne "aeiou", qui contient toutes les voyelles minuscules.
        tuple(...) : Cette fonction entoure l'expression du générateur et convertit les voyelles générées en un tuple.
    print(phrase) : Cette ligne de code imprime la phrase originale sur la console.
    print(voyelles) : Cette ligne de code imprime le n-uplet de voyelles (qui contient les voyelles de la phrase) sur la console.
        \end{solution}
        

        \question
        Tuple de facteurs premiers distincts de nombres dans une liste

Exemple de sortie

[10, 15, 20, 25]

(2, 5, 3, 5, 2, 5, 5)
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q561.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python calcule et crée un tuple appelé prime_factors, qui contient les facteurs premiers de chaque nombre de la liste des nombres. Voici comment fonctionne le code :

    nombres = [10, 15, 20, 25] : Cette ligne initialise une variable nommée numbers et lui affecte une liste contenant quatre nombres.
    prime_factors = tuple(factor for num in numbers for factor in range(2, num+1) if num % factor == 0 and all(factor % divisor != 0 for divisor in range(2, factor))) : Cette ligne de code initialise une variable nommée prime_factors et lui affecte un tuple créé à l'aide d'une expression de générateur imbriqué.
        for num in numbers : Cette partie extérieure du code met en place une boucle qui parcourt chaque nombre num de la liste des nombres.
        for factor in range(2, num+1) : Cette partie interne du code met en place une boucle imbriquée qui parcourt chaque facteur de 2 à num (inclus).
        if num % factor == 0 : dans la boucle imbriquée, on vérifie si num est divisible par factor en évaluant num % factor == 0.
        all(factor % divisor != 0 for divisor in range(2, factor)) : A l'intérieur de la condition, il utilise all() pour vérifier si le facteur est un nombre premier. Pour ce faire, il parcourt tous les nombres compris entre 2 et facteur - 1 (inclus) et vérifie que facteur n'est pas divisible par l'un d'entre eux (c'est-à-dire que facteur % diviseur != 0 pour tous les diviseurs de cet intervalle).
        facteur : Si toutes les conditions sont remplies (c'est-à-dire que num est divisible par factor et que factor est un nombre premier), factor est inclus dans l'expression du générateur.
        tuple(...) : Cette fonction entoure l'expression imbriquée du générateur et convertit les facteurs premiers générés en un tuple.
    print(nombres) : Cette ligne de code imprime la liste originale des nombres sur la console.
    print(facteurs_premiers) : Cette ligne de code imprime le tuple prime_factors (qui contient les facteurs premiers des nombres) sur la console.
        \end{solution}
        

        \question
        Tuple de caractères distincts dans une liste de chaînes de caractères

Exemple de sortie

['apple', 'banana', 'cherry']

('a', 'p', 'p', 'l', 'e', 'b', 'a', 'n', 'a', 'n', 'a', 'c', 'h', 'e', 'r', 'r', 'y')
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q562.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un tuple appelé distinct_chars, qui contient tous les caractères distincts des chaînes de la liste des chaînes. Voici comment fonctionne ce code :

    strings = ["apple", "banana", "cherry"] : Cette ligne initialise une variable nommée strings et lui affecte une liste contenant trois chaînes.
    distinct_chars = tuple(char for string in strings for char in string) : Cette ligne de code initialise une variable nommée distinct_chars et lui affecte un tuple créé à l'aide d'une expression de générateur imbriqué.
        for string in strings : Cette partie extérieure du code met en place une boucle qui parcourt chaque chaîne de caractères de la liste strings.
        for char in string : Cette partie interne du code met en place une boucle imbriquée qui parcourt chaque caractère char de la chaîne actuelle.
        char : Pour chaque caractère de chaque chaîne, il inclut le caractère dans l'expression du générateur.
        tuple(...) : Cette expression entoure l'expression imbriquée du générateur et convertit les caractères générés en un tuple.
    print(strings) : Cette ligne de code imprime la liste originale des chaînes sur la console.
    print(distinct_chars) : Cette ligne de code imprime le tuple distinct_chars (qui contient les caractères distincts des chaînes) sur la console.
        \end{solution}
        

        \question
        Tuple de valeurs ASCII pour les caractères d'une chaîne de caractères

Exemple de sortie

bonjour

(104, 101, 108, 108, 111)
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q563.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un tuple appelé ascii_values, qui contient les valeurs ASCII (valeurs ordinales) de chaque caractère de la chaîne de caractères. Voici comment fonctionne ce code :

    string = "hello" : Cette ligne initialise une variable nommée string et lui affecte la chaîne "hello".
    ascii_values = tuple(ord(char) for char in string) : Cette ligne de code initialise une variable nommée ascii_values et lui affecte un tuple créé à l'aide d'un générateur d'expressions.
        for char in string : Cette partie du code met en place une boucle qui parcourt chaque caractère de la chaîne.
        ord(char) : Pour chaque caractère de la chaîne, la fonction ord() est utilisée pour obtenir sa valeur ASCII (valeur ordinale).
        tuple(...) : Cette fonction entoure l'expression du générateur et convertit les valeurs ASCII générées en un tuple.
    print(string) : Cette ligne de code imprime la chaîne originale sur la console.
    print(ascii_values) : Cette ligne de code imprime le tuple ascii_values (qui contient les valeurs ASCII des caractères de la chaîne) sur la console.
        \end{solution}
        

        \question
        Tuple de lettres communes entre deux mots

Exemple de sortie

pomme

banane

('a',)
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q564.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un tuple appelé common_letters, qui contient les caractères communs aux deux mots, word1 et word2. Voici comment fonctionne ce code :

    mot1 = "pomme" : Cette ligne initialise une variable nommée word1 et lui affecte la chaîne "apple".
    mot2 = "banane" : Cette ligne initialise une variable nommée word2 et lui affecte la chaîne "banana".
    common_letters = tuple(char for char in word1 if char in word2) : Cette ligne de code initialise une variable nommée common_letters et lui affecte un tuple créé à l'aide d'un générateur d'expressions.
        pour char dans word1 : Cette partie du code met en place une boucle qui parcourt chaque caractère char dans word1.
        if char in word2 : Pour chaque caractère dans word1, on vérifie si le caractère est également présent dans word2.
        char : Si un caractère est présent à la fois dans word1 et word2, il est inclus dans l'expression du générateur.
        tuple(...) : Cette fonction entoure l'expression du générateur et convertit les caractères communs générés en un tuple.
    print(mot1) : Cette ligne de code imprime le mot1 original sur la console.
    print(mot2) : Cette ligne de code imprime le mot2 original sur la console.
    print(lettres_communs) : Cette ligne de code imprime le tuple common_letters (qui contient les caractères communs entre les deux mots) sur la console.
        \end{solution}
        

        \question
        Tuple de carrés pairs jusqu'à 100

Exemple de sortie

(0, 4, 16, 36, 64, 100)
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q565.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un tuple appelé even_squares, qui contient les carrés des nombres pairs de 0 à 10 (inclus). Voici comment fonctionne ce code :

    even_squares = tuple(x**2 for x in range(11) if x**2 % 2 == 0) : Cette ligne de code initialise une variable nommée even_squares et lui affecte un tuple créé à l'aide d'une expression génératrice.
        for x in range(11) : Cette partie du code met en place une boucle qui parcourt les nombres de 0 à 10 en utilisant l'itérable range(11).
        if x**2 % 2 == 0 : pour chaque valeur de x dans l'intervalle, il calcule le carré de x en utilisant x**2 et vérifie si le carré est un nombre pair en évaluant x**2 % 2 == 0.
        x**2 : Si le carré de x est pair, il l'inclut dans l'expression du générateur.
        tuple(...) : Cette fonction entoure l'expression du générateur et convertit les carrés pairs générés en un tuple.
    print(even_squares) : Cette ligne de code imprime le tuple even_squares (qui contient les carrés pairs des nombres de 0 à 10) sur la console.
        \end{solution}
        

        \question
        Tuple de nombres positifs provenant d'une liste

Exemple de sortie

[-5, 10, -15, 20, -25]

(10, 20)
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q566.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un tuple appelé positif, qui contient tous les nombres non négatifs (c'est-à-dire positifs ou nuls) de la liste des nombres. Voici comment fonctionne ce code :

    nombres = [-5, 10, -15, 20, -25] : Cette ligne initialise une variable nommée numbers et lui affecte une liste contenant cinq nombres, dont certains sont négatifs.
    positif = tuple(x for x in numbers if x >= 0) : Cette ligne de code initialise une variable nommée positive et lui affecte un tuple créé à l'aide d'une expression génératrice.
        pour x dans les nombres : Cette partie du code met en place une boucle qui parcourt chaque nombre x de la liste des nombres.
        if x >= 0 : pour chaque nombre de la liste, il vérifie si x est supérieur ou égal à zéro en évaluant x >= 0.
        x : Si le nombre est non négatif (positif ou nul), il est inclus dans l'expression du générateur.
        tuple(...) : Cette expression entoure l'expression du générateur et convertit les nombres non négatifs générés en un tuple.
    print(nombres) : Cette ligne de code imprime la liste originale des nombres sur la console.
    print(positive) : Cette ligne de code imprime le tuple positif (qui contient les nombres non négatifs de la liste) sur la console.
        \end{solution}
        

        \question
        Tuple de consonnes distinctes dans une phrase

Exemple de sortie

Bonjour, comment allez-vous ?

('h', 'l', 'l', 'h', 'w', 'r', 'y')
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q567.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un tuple appelé consonnes, qui contient tous les caractères consonantiques minuscules de la chaîne de phrases. Voici comment fonctionne ce code :

    sentence = "Hello, how are you ?": Cette ligne initialise une variable nommée sentence et lui affecte la chaîne de caractères "Hello, how are you ?"
    consonnes = tuple(char.lower() for char in sentence if char.lower() not in 'aeiou' and char.isalpha()) : Cette ligne de code initialise une variable nommée consonnes et lui affecte un tuple créé à l'aide d'un générateur d'expressions.
        for char in sentence : Cette partie du code met en place une boucle qui parcourt chaque caractère char de la phrase.
        if char.lower() not in 'aeiou' : Pour chaque caractère de la chaîne, le code vérifie si la version minuscule de char ne se trouve pas dans la chaîne "aeiou", ce qui permet d'identifier les consonnes.
        et char.isalpha() : Il vérifie également si le caractère est une lettre de l'alphabet (c'est-à-dire qu'il ne s'agit pas d'un signe de ponctuation ou d'un espace) à l'aide de la méthode char.isalpha().
        char.lower() : Si le caractère remplit les deux conditions (il s'agit d'une consonne et d'une lettre de l'alphabet), il est converti en minuscule à l'aide de la méthode char.lower() et inclus dans l'expression du générateur.
        tuple(...) : Il entoure l'expression du générateur et convertit les consonnes minuscules générées en un tuple.
    print(phrase) : Cette ligne de code imprime la phrase originale sur la console.
    print(consonnes) : Cette ligne de code imprime le n-uplet consonnes (qui contient les consonnes minuscules de la phrase) sur la console.
        \end{solution}
        

        \question
        Tuple d'éléments communs entre deux listes

Exemple de sortie

[1, 2, 3, 4, 5]

[4, 5, 6, 7, 8]

(4, 5)
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q568.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un tuple appelé common, qui contient les éléments communs à list1 et list2. Voici comment fonctionne ce code :

    list1 = [1, 2, 3, 4, 5] : Cette ligne initialise une variable nommée list1 et lui affecte une liste contenant cinq nombres.
    list2 = [4, 5, 6, 7, 8] : Cette ligne initialise une variable nommée list2 et lui attribue une liste contenant cinq nombres.
    common = tuple(x for x in list1 if x in list2) : Cette ligne de code initialise une variable nommée common et lui affecte un tuple créé à l'aide d'une expression génératrice.
        for x in list1 : Cette partie du code met en place une boucle qui parcourt chaque élément x de la liste1.
        if x in list2 : Pour chaque élément de la liste 1, le code vérifie si l'élément est également présent dans la liste 2 en évaluant x dans la liste 2.
        x : Si un élément est présent à la fois dans list1 et list2, il est inclus dans l'expression du générateur.
        tuple(...) : Cette fonction entoure l'expression du générateur et convertit les éléments communs générés en un tuple.
    print(list1) : Cette ligne de code imprime la liste originale list1 sur la console.
    print(list2) : Cette ligne de code imprime la liste 2 originale sur la console.
    print(common) : Cette ligne de code imprime le tuple commun (qui contient les éléments communs entre list1 et list2) sur la console.
        \end{solution}
        

        \question
        Tuple de voyelles distinctes dans une liste de mots

Exemple de sortie

['apple', 'banana', 'cherry', 'date']

('a', 'e', 'a', 'a', 'a', 'e', 'a', 'e')
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q569.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un tuple appelé distinct_voyelles, qui contient tous les caractères voyelles minuscules distincts des mots de la liste des mots. Voici comment fonctionne ce code :

    words = ["apple", "banana", "cherry", "date"] : Cette ligne initialise une variable nommée words et lui attribue une liste contenant quatre mots.
    distinct_vowels = tuple(char.lower() for word in words for char in word if char.lower() in 'aeiou') : Cette ligne de code initialise une variable nommée distinct_vowels et lui affecte un tuple créé à l'aide d'un générateur d'expressions.
        for word in words : Cette partie du code met en place la boucle externe qui parcourt chaque mot de la liste des mots.
        for char in word : à l'intérieur de la boucle externe, cette partie du code met en place une boucle imbriquée qui parcourt chaque caractère char dans le mot actuel.
        if char.lower() in 'aeiou' : Pour chaque caractère de chaque mot, il vérifie si la version minuscule de char se trouve dans la chaîne "aeiou", ce qui permet d'identifier les voyelles minuscules.
        char.lower() : Si un caractère voyelle minuscule est trouvé, il est inclus dans l'expression du générateur.
        tuple(...) : Cette fonction entoure l'expression du générateur et convertit les voyelles minuscules générées en un tuple.
    print(words) : Cette ligne de code imprime la liste originale des mots sur la console.
    print(voyelles_distinctes) : Cette ligne de code imprime le tuple distinct_voyelles (qui contient les caractères voyelles minuscules distincts des mots) sur la console.
        \end{solution}
        

        \question
        Tuple de mots distincts commençant par des voyelles dans une phrase

Exemple de sortie

Bonjour, comment allez-vous ?

('are',)
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q570.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un tuple appelé vowel_start_words, qui contient les mots de la chaîne de phrases qui commencent par une voyelle minuscule. Voici comment fonctionne ce code :

    sentence = "Hello, how are you ?": Cette ligne initialise une variable nommée sentence et lui affecte la chaîne "Bonjour, comment allez-vous ?"
    vowel_start_words = tuple(word for word in sentence.split() if word[0].lower() in 'aeiou') : Cette ligne de code initialise une variable nommée vowel_start_words et lui affecte un tuple créé à l'aide d'un générateur d'expressions.
        for word in sentence.split() : Cette partie du code met en place une boucle qui parcourt chaque mot de la phrase, séparé par des espaces à l'aide de sentence.split().
        if word[0].lower() in 'aeiou' : Pour chaque mot de la phrase scindée, il vérifie si la version minuscule du premier caractère du mot, obtenue en utilisant word[0].lower(), se trouve dans la chaîne 'aeiou', identifiant ainsi les mots qui commencent par une voyelle minuscule.
        word : Si un mot commence par une voyelle minuscule, il est inclus dans l'expression du générateur.
        tuple(...) : Ce paramètre entoure l'expression du générateur et convertit les mots générés en un tuple.
    print(phrase) : Cette ligne de code imprime la phrase originale sur la console.
    print(mots_de_début_de_voyelle) : Cette ligne de code imprime le tuple mots_voyelles_début (qui contient les mots commençant par une voyelle minuscule) sur la console.
        \end{solution}
        

        \question
        Tuple de sommes de chiffres dans les nombres

Exemple de sortie

[123, 456, 789]

(6, 15, 24)
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q571.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un tuple appelé digit_sums, qui contient la somme des chiffres pour chaque nombre de la liste des nombres. Voici comment fonctionne ce code :

    numbers = [123, 456, 789] : Cette ligne initialise une variable nommée numbers et lui affecte une liste contenant trois nombres.
    digit_sums = tuple(sum(int(digit) for digit in str(num)) for num in numbers) : Cette ligne de code initialise une variable nommée digit_sums et lui affecte un tuple créé à l'aide d'un générateur d'expressions.
        for num in numbers : Cette partie du code met en place une boucle qui parcourt chaque numéro de la liste des numéros.
        str(num) : Elle convertit chaque nombre en une chaîne de caractères à l'aide de str(num) afin que nous puissions travailler avec des chiffres individuels.
        for digit in str(num) : À l'intérieur de la boucle, il met en place une boucle imbriquée qui parcourt chaque chiffre de la chaîne de caractères représentant le nombre.
        int(digit) : Pour chaque chiffre, il le reconvertit en un entier à l'aide de int(digit) afin que nous puissions en faire la somme.
        sum(...) : Cette fonction calcule la somme des chiffres pour chaque nombre.
        tuple(...) : Cette expression entoure l'expression du générateur et convertit les sommes générées en un tuple.
    print(nombres) : Cette ligne de code imprime la liste originale des nombres sur la console.
    print(digit_sums) : Cette ligne de code imprime le tuple digit_sums (qui contient la somme des chiffres pour chaque numéro de la liste) sur la console.
        \end{solution}
        

        \question
        Tuple de mots d'une longueur supérieure à 3 dans une phrase

Exemple de sortie

Voici un exemple de phrase

('Ceci', 'échantillon', 'phrase')
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q572.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un tuple appelé long_words, qui contient les mots de la chaîne de phrases qui ont plus de 3 caractères. Voici comment fonctionne ce code :

    sentence = "Ceci est un exemple de phrase" : Cette ligne initialise une variable nommée sentence et lui attribue la chaîne de caractères "Ceci est un exemple de phrase".
    long_words = tuple(word for word in sentence.split() if len(word) > 3) : Cette ligne de code initialise une variable nommée mots_longs et lui affecte un tuple créé à l'aide d'un générateur d'expressions.
        for word in sentence.split() : Cette partie du code met en place une boucle qui parcourt chaque mot de la phrase, séparé par des espaces à l'aide de sentence.split().
        if len(word) > 3 : pour chaque mot de la phrase scindée, le code vérifie si la longueur du mot (c'est-à-dire le nombre de caractères qu'il contient) est supérieure à 3 en utilisant len(word) > 3.
        word : Si un mot a plus de 3 caractères, il est inclus dans l'expression du générateur.
        tuple(...) : Cette fonction entoure l'expression du générateur et convertit les mots générés en un tuple.
    print(phrase) : Cette ligne de code imprime la phrase originale sur la console.
    print(mots_longs) : Cette ligne de code imprime le tuple mots_longs (qui contient des mots de plus de 3 caractères) sur la console.
        \end{solution}
        

        \question
        Tuple de paires d'éléments et de leurs carrés

Exemple de sortie

[1, 2, 3, 4, 5]

((1, 1), (2, 4), (3, 9), (4, 16), (5, 25))
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q573.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un tuple appelé squared_tuples, qui contient des paires de nombres et leurs carrés correspondants de la liste des nombres. Voici comment fonctionne le code :

    nombres = [1, 2, 3, 4, 5] : Cette ligne initialise une variable nommée numbers et lui affecte une liste contenant cinq nombres.
    squared_tuples = tuple((x, x**2) for x in numbers) : Cette ligne de code initialise une variable nommée squared_tuples et lui affecte un tuple créé à l'aide d'une expression de générateur.
        for x in numbers : Cette partie du code met en place une boucle qui parcourt chaque nombre x de la liste des nombres.
        (x, x**2) : Pour chaque nombre, elle crée un tuple contenant le nombre x et son carré x**2.
        tuple(...) : Cette expression entoure l'expression du générateur et convertit les paires de nombres et leurs carrés générés en un tuple.
    print(nombres) : Cette ligne de code imprime la liste originale des nombres sur la console.
    print(tuples_carrés) : Cette ligne de code imprime la liste des nombres carrés sur la console : Cette ligne de code imprime le tuple squared_tuples (qui contient des paires de nombres et leurs carrés) sur la console.
        \end{solution}
        

        \question
        Tuple de nombres négatifs d'une liste

Exemple de sortie

[-5, 10, -15, 20, -25]

(-5, -15, -25)
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q574.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un tuple appelé negative, qui contient tous les nombres négatifs de la liste des nombres. Voici comment fonctionne ce code :

    nombres = [-5, 10, -15, 20, -25] : Cette ligne initialise une variable nommée numbers et lui affecte une liste contenant cinq nombres, dont certains sont négatifs.
    négatif = tuple(x for x in numbers if x < 0) : Cette ligne de code initialise une variable nommée negative et lui affecte un tuple créé à l'aide d'une expression génératrice.
        pour x dans les nombres : Cette partie du code met en place une boucle qui parcourt chaque nombre x de la liste des nombres.
        if x < 0 : pour chaque nombre, il vérifie s'il est inférieur à 0 (c'est-à-dire un nombre négatif) à l'aide de la condition x < 0.
        x : Si un nombre est négatif, il est inclus dans l'expression du générateur.
        tuple(...) : Cette fonction entoure l'expression du générateur et convertit les nombres négatifs générés en un tuple.
    print(nombres) : Cette ligne de code imprime la liste originale des nombres sur la console.
    print(negative) : Cette ligne de code imprime le tuple négatif (qui contient les nombres négatifs de la liste) sur la console.
        \end{solution}
        

        \question
        Tuple de nombres positifs et négatifs provenant d'une liste

Exemple de sortie

[10, -5, 20, -15, 30]

(10, 20, 30)

(-5, -15)
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q575.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée deux tuples : positif et négatif, qui contiennent respectivement les nombres positifs et négatifs de la liste des nombres. Voici comment fonctionne ce code :

    nombres = [10, -5, 20, -15, 30] : Cette ligne initialise une variable nommée numbers et lui affecte une liste contenant cinq nombres, dont certains sont positifs et d'autres négatifs.
    positif = tuple(x for x in numbers if x >= 0) : Cette ligne de code initialise une variable nommée positive et lui affecte un tuple créé à l'aide d'une expression génératrice.
        pour x dans les nombres : Cette partie du code met en place une boucle qui parcourt chaque nombre x de la liste des nombres.
        if x >= 0 : pour chaque nombre, on vérifie s'il est supérieur ou égal à 0 (c'est-à-dire un nombre non négatif) à l'aide de la condition x >= 0.
        x : Si un nombre est non négatif, il est inclus dans l'expression du générateur.
        tuple(...) : Cette expression entoure l'expression du générateur et convertit les nombres non négatifs générés en un tuple.
    negative = tuple(x for x in numbers if x < 0) : Cette ligne de code initialise une variable nommée negative et lui affecte un tuple créé à l'aide d'une expression du générateur.
        pour x dans nombres : Comme pour l'expression génératrice précédente, cette boucle parcourt chaque nombre x de la liste des nombres.
        if x < 0 : pour chaque nombre, elle vérifie s'il est inférieur à 0 (c'est-à-dire un nombre négatif) en utilisant la condition x < 0.
        x : Si un nombre est négatif, il est inclus dans l'expression du générateur.
        tuple(...) : Cette fonction entoure l'expression du générateur et convertit les nombres négatifs générés en un tuple.
    print(nombres) : Cette ligne de code imprime la liste originale des nombres sur la console.
    print(positive) : Cette ligne de code imprime le tuple positif (qui contient les nombres non négatifs de la liste) sur la console.
    print(negative) : Cette ligne de code imprime le tuple négatif (qui contient les nombres négatifs de la liste) sur la console.
        \end{solution}
        

        \question
        Tuple de paires de mots et de leur longueur

Exemple de sortie

['apple', 'banana', 'cherry', 'date']

(('pomme', 5), ('banane', 6), ('cerise', 6), ('date', 4))
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q576.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un tuple appelé word_lengths, qui contient des paires de mots et leurs longueurs correspondantes dans la liste des mots. Voici comment fonctionne ce code :

    words = ["apple", "banana", "cherry", "date"] : Cette ligne initialise une variable nommée words et lui affecte une liste contenant quatre mots.
    word_lengths = tuple((word, len(word)) for word in words) : Cette ligne de code initialise une variable nommée word_lengths et lui affecte un tuple créé à l'aide d'une expression de générateur.
        for word in words : Cette partie du code met en place une boucle qui parcourt chaque mot de la liste des mots.
        (mot, len(mot)) : Pour chaque mot, le code crée un tuple contenant le mot lui-même et sa longueur len(word).
        tuple(...) : Cette expression entoure l'expression du générateur et convertit les paires de mots générées et leurs longueurs en un tuple.
    print(mots) : Cette ligne de code affiche la liste originale des mots sur la console.
    print(longueur_des_mots) : Cette ligne de code imprime le tuple word_lengths (qui contient les paires de mots et leurs longueurs) sur la console.
        \end{solution}
        

        \question
        Tuple de caractères et leurs valeurs ASCII correspondantes

Exemple de sortie

['a', 'b', 'c', 'd', 'e']

(('a', 97), ('b', 98), ('c', 99), ('d', 100), ('e', 101))
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q577.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un tuple appelé char_ascii_pairs, qui contient des paires de caractères et leurs valeurs ASCII correspondantes à partir de la liste des caractères. Voici comment fonctionne ce code :

    characters = ['a', 'b', 'c', 'd', 'e'] : Cette ligne initialise une variable nommée characters et lui affecte une liste contenant cinq caractères.
    char_ascii_pairs = tuple((char, ord(char)) for char in characters) : Cette ligne de code initialise une variable nommée char_ascii_pairs et lui affecte un tuple créé à l'aide d'une expression de générateur.
        for char in characters : Cette partie du code met en place une boucle qui parcourt chaque caractère char de la liste des caractères.
        (char, ord(char)) : Pour chaque caractère, elle crée un tuple contenant le caractère lui-même char et sa valeur ASCII correspondante obtenue à l'aide de la fonction ord(char).
        tuple(...) : Cette expression entoure l'expression du générateur et convertit les paires de caractères générées et leurs valeurs ASCII en un tuple.
    print(characters) : Cette ligne de code imprime la liste originale des caractères sur la console.
    print(char_ascii_pairs) : Cette ligne de code imprime le tuple char_ascii_pairs (qui contient des paires de caractères et leurs valeurs ASCII) sur la console.
        \end{solution}
        

        \question
        Tuple de paires de nombres et leur somme à partir de deux listes

Exemple de sortie

[1, 2, 3]

[4, 5, 6]

((1, 4, 5), (1, 5, 6), (1, 6, 7), (2, 4, 6), (2, 5, 7), (2, 6, 8), (3, 4, 7), (3, 5, 8), (3, 6, 9))
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q578.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un tuple appelé sum_tuples, qui contient des triplets d'éléments de list1, list2 et leurs sommes. Voici comment fonctionne ce code :

    list1 = [1, 2, 3] : Cette ligne initialise une variable nommée list1 et lui affecte une liste contenant trois nombres.
    list2 = [4, 5, 6] : Cette ligne initialise une variable nommée list2 et lui attribue une liste contenant trois nombres.
    sum_tuples = tuple((x, y, x + y) for x in list1 for y in list2) : Cette ligne de code initialise une variable nommée sum_tuples et lui affecte un tuple créé à l'aide d'une expression génératrice.
        for x in list1 : Cette partie du code met en place une boucle imbriquée qui parcourt chaque nombre x dans la liste1.
        for y in list2 : Pour chaque x de la liste 1, cette partie du code met en place une autre boucle imbriquée qui parcourt chaque nombre y de la liste 2.
        (x, y, x + y) : Pour chaque paire de x et de y, il crée un triplet contenant x, y et leur somme x + y.
        tuple(...) : Cette expression entoure l'expression du générateur et convertit les triplets générés en un tuple.
    print(list1) : Cette ligne de code imprime la liste originale list1 sur la console.
    print(list2) : Cette ligne de code imprime la liste 2 originale sur la console.
    print(sum_tuples) : Cette ligne de code imprime le tuple sum_tuples (qui contient des triplets d'éléments et leurs sommes) sur la console.
        \end{solution}
        

        \question
        Tuple de nombres impairs de 1 à 20

Exemple de sortie

(1, 3, 5, 7, 9, 11, 13, 15, 17, 19)
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q579.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un tuple appelé odds, qui contient tous les nombres impairs de 1 à 20. Voici comment fonctionne le code :

    odds = tuple(x for x in range(1, 21) if x % 2 != 0) : Cette ligne de code initialise une variable nommée odds et lui affecte un tuple créé à l'aide d'une expression génératrice.
        for x in range(1, 21) : Cette partie du code met en place une boucle qui parcourt chaque nombre x dans l'intervalle de 1 à 20 (inclus).
        if x % 2 != 0 : Pour chaque nombre, on vérifie s'il n'est pas divisible par 2 (c'est-à-dire un nombre impair) en utilisant la condition x % 2 != 0.
        x : Si un nombre est impair, il l'inclut dans l'expression du générateur.
        tuple(...) : Ceci entoure l'expression du générateur et convertit les nombres impairs générés en un tuple.
    print(odds) : Cette ligne de code imprime le tuple odds (qui contient tous les nombres impairs de 1 à 20) sur la console.
        \end{solution}
        

        \question
        Tuple de nombres premiers jusqu'à 50

Exemple de sortie

(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47)
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q580.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python définit une fonction is_prime(n) pour vérifier si un nombre n est premier, puis il crée un tuple appelé primes contenant tous les nombres premiers de 2 à 50. Voici comment fonctionne le code :

    def is_prime(n) : Cette ligne définit une fonction nommée is_prime qui prend un entier n comme argument.
        if n <= 1: : Cette ligne vérifie si le nombre saisi est inférieur ou égal à 1, auquel cas elle renvoie False car les nombres premiers sont supérieurs à 1.
        for i in range(2, int(n**0.5) + 1): : Cette ligne met en place une boucle qui parcourt les nombres compris entre 2 et la racine carrée de n (arrondie à l'entier le plus proche) plus 1. Cette boucle est utilisée pour vérifier si n est divisible par un nombre de cet intervalle.
            if n % i == 0: : Pour chaque i de la boucle, on vérifie si n est divisible par i (c'est-à-dire si le reste de la division est égal à 0). Si n est divisible par n'importe quel nombre de l'intervalle, cela signifie que n n'est pas premier et il renvoie False.
        Si la boucle se termine sans trouver de diviseur, la fonction renvoie True, indiquant que le nombre saisi est premier.
    primes = tuple(x for x in range(2, 51) if is_prime(x)) : Cette ligne de code initialise une variable nommée primes et lui affecte un tuple créé à l'aide d'une expression génératrice.
        for x in range(2, 51) : Cette partie du code met en place une boucle qui parcourt les nombres compris entre 2 et 50.
        if is_prime(x) : Pour chaque nombre x, il vérifie s'il est premier en appelant la fonction is_prime. Si x est premier, il est inclus dans l'expression du générateur.
        tuple(...) : Cette fonction entoure l'expression du générateur et convertit les nombres premiers générés en un tuple.
    print(primes) : Cette ligne de code imprime le tuple primes (qui contient tous les nombres premiers de 2 à 50) sur la console.
        \end{solution}
        

        \question
        Tuple de facteurs de nombres dans une liste

Exemple de sortie

[10, 15, 20, 25]

((10, [1, 2, 5, 10]), (15, [1, 3, 5, 15]), (20, [1, 2, 4, 5, 10, 20]), (25, [1, 5, 25]))
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q581.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un tuple appelé facteurs, qui contient des paires de nombres et leurs facteurs de la liste des nombres. Voici comment fonctionne ce code :

    nombres = [10, 15, 20, 25] : Cette ligne initialise une variable nommée nombres et lui affecte une liste contenant quatre nombres.
    facteurs = tuple((num, [x for x in range(1, num+1) if num % x == 0]) for num in numbers) : Cette ligne de code initialise une variable nommée factors et lui affecte un tuple créé à l'aide d'une expression de générateur.
    print(nombres) : Cette ligne de code imprime la liste originale des nombres sur la console.
    print(facteurs) : Cette ligne de code imprime le tuple factors (qui contient des paires de nombres et leurs facteurs) sur la console.
        \end{solution}
        

        \question
        Tuple de voyelles et de consonnes distinctes provenant d'une liste de mots

Exemple de sortie

['apple', 'banana', 'cherry', 'date']

('a', 'e', 'a', 'a', 'a', 'e', 'a', 'e')

("p", "p", "l", "b", "n", "n", "c", "h", "r", "r", "y", "d", "t")
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q582.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite la liste des mots et crée deux tuples : les voyelles et les consonnes. Le tuple des voyelles contient toutes les voyelles des mots de la liste, et le tuple des consonnes contient toutes les consonnes. Voici comment fonctionne le code :

    mots = ["pomme", "banane", "cerise", "date"] : Cette ligne initialise une variable nommée words et lui affecte une liste contenant quatre mots.
    voyelles = tuple(char for word in words for char in word if char.lower() in 'aeiou') : Cette ligne initialise une variable nommée vowels et lui affecte un tuple créé à l'aide d'un générateur d'expressions.
        for word in words : Cette partie du code met en place une boucle imbriquée qui parcourt chaque mot de la liste des mots.
        for char in word : Pour chaque mot, cette partie du code met en place une autre boucle imbriquée qui parcourt chaque caractère char du mot.
        if char.lower() in 'aeiou' : Pour chaque caractère, il vérifie si le caractère (converti en minuscules) est une voyelle (c'est-à-dire s'il se trouve dans la chaîne "aeiou"). S'il s'agit d'une voyelle, il inclut le caractère dans l'expression du générateur.
        tuple(...) : Cette fonction entoure l'expression du générateur et convertit les voyelles générées en un tuple.
    consonnes = tuple(char for word in words for char in word if char.lower() not in 'aeiou') : Cette ligne initialise une variable nommée consonants et lui affecte un tuple créé à l'aide d'une expression du générateur.
        for word in words : Cette partie du code met en place une boucle imbriquée qui parcourt chaque mot de la liste des mots.
        for char in word : Pour chaque mot, cette partie du code met en place une autre boucle imbriquée qui parcourt chaque caractère char du mot.
        if char.lower() not in 'aeiou' : Pour chaque caractère, il vérifie si le caractère (converti en minuscule) n'est pas une voyelle (c'est-à-dire s'il n'est pas dans la chaîne 'aeiou'). S'il s'agit d'une consonne, il inclut le caractère dans l'expression du générateur.
        tuple(...) : Cette fonction entoure l'expression du générateur et convertit les caractères consonants générés en un tuple.
    print(words) : Cette ligne de code imprime la liste originale des mots sur la console.
    print(voyelles) : Cette ligne de code imprime le tuple vowels (qui contient tous les caractères voyelles) sur la console.
    print(consonnes) : Cette ligne de code imprime le tuple consonnes (qui contient tous les caractères consonnes) sur la console.
        \end{solution}
        

        \question
        Tuple de tuples avec le mot et son nombre de voyelles dans une phrase

Exemple de sortie

Bonjour, comment allez-vous ?

(('Hello,', 2), ('how', 1), ('are', 2), ('you?', 2))
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q583.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite la phrase et crée un tuple appelé vowel_count_tuples. Chaque élément de ce tuple est une paire contenant un mot de la phrase et le nombre de voyelles dans ce mot. Voici comment fonctionne le code :

    sentence = "Hello, how are you ?": Cette ligne initialise une variable nommée sentence et lui affecte une chaîne contenant la phrase d'entrée.
    vowel_count_tuples = tuple((word, sum(1 for char in word if char.lower() in 'aeiou')) for word in sentence.split()) : Cette ligne initialise une variable nommée vowel_count_tuples et lui affecte un tuple créé à l'aide d'une expression de générateur.
        for word in sentence.split() : Cette partie du code met en place une boucle qui parcourt chaque mot de la phrase. Pour ce faire, elle divise la phrase en mots en utilisant les espaces blancs comme délimiteurs.
        (word, sum(1 for char in word if char.lower() in 'aeiou')) : Pour chaque mot, il crée une paire composée du mot lui-même et du nombre de voyelles dans le mot. Le nombre est calculé à l'aide de l'expression sum(1 for char in word if char.lower() in 'aeiou'), qui parcourt chaque caractère du mot, vérifie s'il s'agit d'une voyelle (insensible à la casse) et ajoute 1 au nombre pour chaque voyelle trouvée.
        tuple(...) : Cette expression entoure l'expression du générateur et convertit les paires générées en un tuple.
    print(phrase) : Cette ligne de code imprime la phrase originale sur la console.
    print(vowel_count_tuples) : Cette ligne de code imprime le tuple vowel_count_tuples (qui contient des paires de mots et leur nombre de voyelles) sur la console.
        \end{solution}
        

        \question
        Tuple de diviseurs distincts de nombres dans une liste

Exemple de sortie

[10, 15, 20, 25]

(\{1, 2, 10, 5\}, \{1, 3, 5, 15\}, \{1, 2, 4, 5, 10, 20\}, \{1, 5, 25\})
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q584.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite la liste des nombres et crée un tuple appelé distinct_divisors. Chaque élément de ce tuple est un ensemble de diviseurs distincts pour un nombre de la liste des nombres. Voici comment fonctionne le code :

    nombres = [10, 15, 20, 25] : Cette ligne initialise une variable nommée numbers et lui affecte une liste contenant quatre nombres.
    distinct_diviseurs = tuple({diviseur pour diviseur dans l'intervalle(1, num+1) si num % diviseur == 0} pour num dans nombres) : Cette ligne initialise une variable nommée distinct_divisors et lui affecte un tuple créé à l'aide d'une expression de générateur.
        for num in numbers : Cette partie du code met en place une boucle qui parcourt chaque nombre num dans la liste des nombres.
        {Pour chaque nombre, il crée un ensemble de diviseurs et lui attribue un tuple créé à l'aide de l'expression du générateur : Pour chaque nombre, elle crée un ensemble de diviseurs distincts. Pour ce faire, il utilise une compréhension de l'ensemble qui parcourt les nombres de 1 à num, en vérifiant si num est divisible par chaque diviseur en utilisant la condition num % diviseur == 0.
        tuple(...) : Cette expression entoure l'expression du générateur et convertit les ensembles générés de diviseurs distincts en un tuple.
    print(nombres) : Cette ligne de code imprime la liste originale des nombres sur la console.
    print(diviseurs_distincts) : Cette ligne de code imprime le tuple distinct_diviseurs (qui contient les ensembles de diviseurs distincts pour chaque nombre) sur la console.
        \end{solution}
        

        \question
        Tuple de mots avec au moins une voyelle dans une phrase

Exemple de sortie

Bonjour, comment allez-vous ?

('Hello,', 'how', 'are', 'you?')
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q585.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite la phrase et crée un tuple appelé mots_voyelles. Le tuple mots_voyelles contient les mots de la phrase qui contiennent au moins une voyelle. Voici comment fonctionne le code :

    sentence = "Hello, how are you ?": Cette ligne initialise une variable nommée sentence et lui affecte une chaîne contenant la phrase d'entrée.
    vowel_words = tuple(word for word in sentence.split() if any(char.lower() in 'aeiou' for char in word)) : Cette ligne initialise une variable nommée mots_voyelles et lui affecte un tuple créé à l'aide d'un générateur d'expressions.
        for word in sentence.split() : Cette partie du code met en place une boucle qui parcourt chaque mot de la phrase. Pour ce faire, elle divise la phrase en mots en utilisant les espaces blancs comme délimiteurs.
        if any(char.lower() in 'aeiou' for char in word) : Pour chaque mot, il vérifie si le mot contient au moins un caractère qui est une voyelle. Pour ce faire, il utilise la fonction any() avec une expression génératrice. L'expression du générateur vérifie si chaque caractère char (converti en minuscule) dans le mot est une voyelle (c'est-à-dire qu'il se trouve dans la chaîne 'aeiou').
        tuple(...) : Cette fonction entoure l'expression du générateur et convertit les mots qui remplissent la condition en un tuple.
    print(phrase) : Cette ligne de code imprime la phrase originale sur la console.
    print(mots_voyelles) : Cette ligne de code imprime le tuple mots_voyelles (qui contient des mots avec au moins une voyelle) sur la console.
        \end{solution}
        

        \question
        Tuple de lettres communes entre des mots de longueurs différentes

Exemple de sortie

pomme

cerise

('e',)
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q586.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            
        \end{solution}
        

        \question
        Tuple de tuples avec un mot et sa forme inversée

Exemple de sortie

['apple', 'banana', 'cherry', 'date']

(('pomme', 'elppa'), ('banane', 'ananab'), ('cerise', 'yrrehc'), ('date', 'etad')))
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q587.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite la liste des mots et crée un n-uplet appelé n-uplets_inversés. Chaque élément de ce tuple est une paire contenant un mot de la liste et son inverse. Voici comment fonctionne le code :

    mots = ["pomme", "banane", "cerise", "date"] : Cette ligne initialise une variable nommée words et lui affecte une liste contenant quatre mots.
    reversed_tuples = tuple((word, word[::-1]) for word in words) : Cette ligne initialise une variable nommée reversed_tuples et lui affecte un tuple créé à l'aide d'une expression de générateur.
        for word in words : Cette partie du code met en place une boucle qui parcourt chaque mot de la liste des mots.
        (mot, mot[::-1]) : Pour chaque mot, le code crée une paire composée du mot original et de son inverse. L'inverse est obtenu en utilisant le découpage en tranches avec word[::-1], qui inverse les caractères du mot.
        tuple(...) : Cette fonction entoure l'expression du générateur et convertit les paires générées en un tuple.
    print(words) : Cette ligne de code imprime la liste originale des mots sur la console.
    print(reversed_tuples) : Cette ligne de code affiche sur la console le n-uplet tuples_inversés (qui contient les paires de mots et leurs inversions).
        \end{solution}
        

        \question
        Tuple de sous-chaînes distinctes d'un mot

Exemple de sortie

bonjour

('h', 'he', 'hel', 'hell', 'hello', 'e', 'el', 'ell', 'ello', 'l', 'll', 'llo', 'l', 'lo', 'o')
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q588.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite un seul mot, word, et crée un tuple appelé substrings. Le tuple substrings contient toutes les sous-chaînes possibles du mot. Voici comment fonctionne le code :

    word = "hello" : Cette ligne initialise une variable nommée word et lui affecte la chaîne de caractères "hello".
    substrings = tuple(word[i:j+1] for i in range(len(word)) for j in range(i, len(word)) : Cette ligne initialise une variable nommée substrings et lui affecte un tuple créé à l'aide d'une expression de générateur imbriqué.
        for i in range(len(word)) : La boucle externe itère à travers l'index de départ i pour substrings. Il est compris entre 0 et la longueur du mot.
        for j in range(i, len(word)) : La boucle interne parcourt l'indice de fin j pour les sous-chaînes. Il est compris entre la valeur actuelle de i et la longueur du mot.
        word[i:j+1] : Pour chaque combinaison de i et j, elle découpe le mot de l'index i à l'index j+1, créant ainsi une sous-chaîne.
        tuple(...) : Cette fonction entoure l'expression imbriquée du générateur et convertit les sous-chaînes générées en un tuple.
    print(word) : Cette ligne de code imprime le mot original sur la console.
    print(substrings) : Cette ligne de code imprime le n-uplet substrings (qui contient toutes les sous-chaînes possibles du mot) sur la console.
        \end{solution}
        

        \question
        Tuple de tuples avec un élément et sa factorielle

Exemple de sortie

[1, 2, 3, 4, 5]

((1, 1), (2, 2), (3, 6), (4, 24), (5, 120))
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q589.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite la liste des nombres et crée un tuple appelé factorial_tuples. Chaque élément de ce tuple est une paire contenant un nombre de la liste et sa factorielle calculée à l'aide de la fonction math.factorial. Voici comment fonctionne le code :

    import math : Cette ligne importe le module math, qui fournit des fonctions mathématiques, dont la fonction factorielle.
    numbers = [1, 2, 3, 4, 5] : Cette ligne initialise une variable nommée numbers et lui affecte une liste contenant cinq nombres.
    factorial_tuples = tuple((x, math.factorial(x)) for x in numbers) : Cette ligne initialise une variable nommée factorial_tuples et lui affecte un tuple créé à l'aide d'une expression de générateur.
    print(nombres) : Cette ligne de code imprime la liste originale des nombres sur la console.
    print(factorial_tuples) : Cette ligne de code imprime la liste des nombres originaux sur la console : Cette ligne de code imprime le tuple factorial_tuples (qui contient des paires de nombres et leurs factorielles) sur la console.
        \end{solution}
        

        \question
        Tuple de paires de mots et de leurs lettres communes

Exemple de sortie

pomme

cerise

(('e', 'e'),)
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q590.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite deux mots, word1 et word2, et crée un tuple appelé common_letter_tuples. Chaque élément de ce tuple est une paire contenant un caractère commun aux deux mots. Voici comment fonctionne le code :

    word1 = "apple" : Cette ligne initialise une variable nommée word1 et lui affecte la chaîne "apple".
    mot2 = "cerise" : Cette ligne initialise une variable nommée word2 et lui affecte la chaîne "cherry".
    common_letter_tuples = tuple((char, char) for char in word1 if char in word2) : Cette ligne initialise une variable nommée common_letter_tuples et lui affecte un tuple créé à l'aide d'un générateur d'expressions.
        for char in word1 : Cette partie du code met en place une boucle qui parcourt chaque caractère char de la chaîne word1.
        if char in word2 : pour chaque caractère, il vérifie si le caractère est présent dans la chaîne word2.
        (char, char) : Si un caractère est commun aux deux mots, il crée une paire avec ce caractère. La paire contient deux fois le même caractère.
        tuple(...) : Cette expression entoure l'expression du générateur et convertit les paires de caractères générées en un tuple.
    print(mot1) : Cette ligne de code imprime le mot1 original sur la console.
    print(mot2) : Cette ligne de code imprime le mot2 original sur la console.
    print(common_letter_tuples) : Cette ligne de code imprime le tuple common_letter_tuples (qui contient des paires de caractères communs) sur la console.
        \end{solution}
        

        \question
        Tuple de mots contenant "a" ou "e" dans une phrase

Exemple de sortie

Voici un exemple de phrase contenant plusieurs mots.

('a', 'sample', 'sentence', 'various')
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q591.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite la phrase et crée un tuple appelé ae_words. Le tuple ae_words contient les mots de la phrase qui contiennent au moins un des caractères "a" ou "e". Voici comment fonctionne le code :

    sentence = "Ceci est un exemple de phrase avec plusieurs mots" : Cette ligne initialise une variable nommée sentence et lui attribue la phrase donnée.
    ae_words = tuple(word for word in sentence.split() if 'a' in word or 'e' in word) : Cette ligne initialise une variable nommée ae_words et lui affecte un tuple créé à l'aide d'un générateur d'expressions.
        for word in sentence.split() : Cette partie du code met en place une boucle qui parcourt chaque mot de la phrase après l'avoir divisée par des espaces à l'aide de sentence.split().
        if 'a' in word or 'e' in word : Pour chaque mot, il vérifie si 'a' ou 'e' est présent dans le mot.
        tuple(...) : Cette fonction entoure l'expression du générateur et convertit les mots générés qui remplissent la condition en un tuple.
    print(phrase) : Cette ligne de code imprime la phrase originale sur la console.
    print(ae_words) : Cette ligne de code imprime le tuple ae_words (qui contient les mots de la phrase avec 'a' ou 'e') sur la console.
        \end{solution}
        

        \question
        Tuple de paires de nombres et de leur produit à partir de deux listes

Exemple de résultat

[1, 2, 3]

[4, 5, 6]

((1, 4, 4), (1, 5, 5), (1, 6, 6), (2, 4, 8), (2, 5, 10), (2, 6, 12), (3, 4, 12), (3, 5, 15), (3, 6, 18))
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q592.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite deux listes, list1 et list2, et crée un tuple appelé product_tuples. Chaque élément de ce tuple est un triple contenant deux nombres des listes et leur produit (résultat de la multiplication). Voici comment fonctionne le code :

    list1 = [1, 2, 3] : Cette ligne initialise une variable nommée list1 et lui affecte une liste contenant trois nombres.
    list2 = [4, 5, 6] : Cette ligne initialise une variable nommée list2 et lui attribue une liste contenant trois nombres.
    product_tuples = tuple((x, y, x * y) for x in list1 for y in list2) : Cette ligne initialise une variable nommée product_tuples et lui affecte un tuple créé à l'aide d'une expression de générateur imbriqué.
        for x in list1 : La boucle extérieure parcourt chaque nombre x dans la liste1.
        for y in list2 : La boucle interne parcourt chaque nombre y de la liste2.
        (x, y, x * y) : Pour chaque combinaison de x et de y, il crée un triple composé des deux nombres originaux et de leur produit, qui est calculé comme x * y.
        tuple(...) : Cette expression entoure l'expression imbriquée du générateur et convertit les triples générés en un tuple.
    print(list1) : Cette ligne de code imprime la liste originale list1 sur la console.
    print(list2) : Cette ligne de code imprime la liste 2 originale sur la console.
    print(product_tuples) : Cette ligne de code imprime le tuple product_tuples (qui contient des triples de nombres et leurs produits) sur la console.
        \end{solution}
        

        \question
        Tuple de mots distincts d'une longueur supérieure à 4 dans une phrase

Exemple de sortie

Voici un exemple de phrase avec des mots de différentes longueurs.

('échantillon', 'phrase', 'mots', 'divers', 'longueurs')
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q593.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite la phrase et crée un tuple appelé long_word_tuples. Le tuple long_word_tuples contient les mots de la phrase dont la longueur est supérieure à 4 caractères. Voici comment fonctionne le code :

    phrase = "Ceci est un exemple de phrase avec des mots de différentes longueurs" : Cette ligne initialise une variable nommée sentence et lui attribue la phrase donnée.
    long_word_tuples = tuple(word for word in sentence.split() if len(word) > 4) : Cette ligne initialise une variable nommée long_word_tuples et lui affecte un tuple créé à l'aide d'une expression génératrice.
        for word in sentence.split() : Cette partie du code met en place une boucle qui parcourt chaque mot de la phrase après l'avoir divisée par des espaces à l'aide de sentence.split().
        if len(word) > 4 : pour chaque mot, il vérifie si la longueur du mot est supérieure à 4 caractères.
        tuple(...) : Cette fonction entoure l'expression du générateur et convertit les mots générés qui remplissent la condition en un tuple.
    print(phrase) : Cette ligne de code imprime la phrase originale sur la console.
    print(long_word_tuples) : Cette ligne de code imprime le tuple long_word_tuples (qui contient les mots de la phrase dont la longueur est supérieure à 4 caractères) sur la console.
        \end{solution}
        

        \question
        Éléments uniques d'une liste sous forme de tuple

Exemple de sortie

[1, 2, 2, 3, 4, 4, 5, 5]

(1, 2, 3, 4, 5)
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q594.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite une liste de nombres, numbers, et crée un tuple nommé unique_tuple qui contient les éléments uniques de la liste. Voici comment fonctionne ce code :

    nombres = [1, 2, 2, 3, 4, 4, 5, 5] : Cette ligne initialise une variable nommée numbers et lui attribue une liste de nombres, y compris quelques doublons.
    unique_tuple = tuple(set(numbers)) : Cette ligne initialise une variable nommée unique_tuple et lui affecte un tuple contenant les éléments uniques de la liste numbers.
        set(nombres) : Cette partie du code convertit la liste des nombres en un ensemble. En Python, les ensembles ne stockent que les éléments uniques, de sorte que cette opération supprime effectivement les doublons.
        tuple(...) : Cette partie du code entoure l'ensemble et le reconvertit en tuple.
    print(nombres) : Cette ligne de code imprime la liste originale, nombres, sur la console.
    print(unique_tuple) : Cette ligne de code imprime le tuple unique_tuple (qui contient les éléments uniques de la liste) sur la console.
        \end{solution}
        

        \question
        Caractères uniques d'une chaîne sous forme de tuple

Exemple de sortie

bonjour

('o', 'e', 'l', 'h')
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q595.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite une chaîne, string, et crée un tuple nommé unique_chars_tuple qui contient les caractères uniques de la chaîne. Voici comment fonctionne ce code :

    string = "hello" : Cette ligne initialise une variable nommée string et lui affecte la chaîne donnée.
    unique_chars_tuple = tuple(set(string)) : Cette ligne initialise une variable nommée unique_chars_tuple et lui affecte un tuple contenant les caractères uniques de la chaîne.
        set(string) : Cette partie du code convertit la chaîne de caractères en un ensemble. En Python, les ensembles ne stockent que des éléments uniques. Cette opération permet donc de supprimer les caractères en double.
        tuple(...) : Cette opération entoure l'ensemble et le reconvertit en tuple.
    print(string) : Cette ligne de code imprime la chaîne originale, string, sur la console.
    print(unique_chars_tuple) : Cette ligne de code imprime le tuple unique_chars_tuple (qui contient les caractères uniques de la chaîne) sur la console.
        \end{solution}
        

        \question
        Mots uniques dans une phrase sous forme de tuple

Exemple de sortie

Voici un exemple de phrase avec des mots répétés

('Ceci', 'mots', 'échantillon', 'avec', 'a', 'répété', 'phrase', 'est')
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q596.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite une phrase, sentence, et crée un tuple nommé unique_words_tuple qui contient les mots uniques de la phrase. Voici comment fonctionne le code :

    sentence = "Ceci est un exemple de phrase avec des mots répétés est" : Cette ligne initialise une variable nommée sentence et lui assigne la phrase donnée.
    unique_words_tuple = tuple(set(sentence.split())) : Cette ligne initialise une variable nommée unique_words_tuple et lui affecte un tuple contenant les mots uniques de la phrase.
        sentence.split() : Cette partie du code divise la phrase en une liste de mots en utilisant les espaces blancs comme séparateurs.
        set(...) : Cette fonction convertit la liste de mots en un ensemble. En Python, les ensembles ne stockent que des éléments uniques, de sorte que cette opération supprime tous les mots en double.
        tuple(...) : Cette opération entoure l'ensemble et le reconvertit en tuple.
    print(phrase) : Cette ligne de code imprime la phrase originale, phrase, sur la console.
    print(unique_words_tuple) : Cette ligne de code imprime le tuple unique_words_tuple (qui contient les mots uniques de la phrase) sur la console.
        \end{solution}
        

        \question
        Éléments distincts de plusieurs listes tout en préservant l'ordre sous forme de tuple

Exemple de sortie

[1, 2, 3, 4, 5]

[4, 5, 6, 7, 8]

(1, 2, 3, 4, 5, 6, 7, 8)
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q597.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python combine deux listes, list1 et list2, en un seul itérable et crée ensuite un tuple nommé unique_ordered_elements_tuple contenant les éléments uniques des deux listes tout en préservant leur ordre. Voici comment fonctionne le code :

    from itertools import chain : Cette ligne importe la fonction chain du module itertools. La fonction chain est utilisée pour combiner deux itérables ou plus en un seul itérable.
    list1 = [1, 2, 3, 4, 5] : Cette ligne initialise une variable nommée list1 et lui affecte une liste contenant cinq entiers.
    list2 = [4, 5, 6, 7, 8] : Cette ligne initialise une variable nommée list2 et lui affecte une autre liste contenant cinq entiers.
    unique_ordered_elements_tuple = tuple(set(chain(list1, list2)) : Cette ligne combine list1 et list2 à l'aide de la fonction chain. Ensuite, elle convertit l'itérable combiné en un ensemble, ce qui supprime les éléments en double. Enfin, elle reconvertit l'ensemble en tuple.
        chain(list1, list2) : La fonction chain prend list1 et list2 comme arguments, les combinant effectivement en un seul itérable.
        set(...) : Cette partie convertit l'itérable combiné en un ensemble, en supprimant les éléments en double.
        tuple(...) : Cette partie entoure l'ensemble et le reconvertit en tuple.
    print(list1) : Cette ligne de code imprime la liste originale list1 sur la console.
    print(list2) : Cette ligne de code imprime la liste 2 originale sur la console.
    print(unique_ordered_elements_tuple) : Cette ligne de code imprime le tuple unique_ordered_elements_tuple (qui contient les éléments uniques des deux listes tout en préservant leur ordre) sur la console.
        \end{solution}
        

        \question
        Paires de mots distincts et leurs formes inversées dans une phrase sous forme de tuple

Exemple de sortie

Bonjour, comment allez-vous ?

(('are', 'era'), ('you?', '?uoy'), ('Hello,', ',olleH'), ('how', 'woh'))
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q598.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite une phrase, sentence, et crée un tuple nommé distinct_reversed_word_tuples. Le tuple contient des paires de mots de la phrase, un élément étant le mot original et l'autre élément étant la version inversée du mot. Voici comment fonctionne le code :

    phrase = "Bonjour, comment allez-vous ?": Cette ligne initialise une variable nommée sentence et lui attribue la phrase donnée.
    distinct_reversed_word_tuples = tuple((word, word[::-1]) for word in set(sentence.split())) : Cette ligne initialise une variable nommée distinct_reversed_word_tuples et lui affecte un tuple créé à l'aide d'une expression génératrice.
        for word in set(sentence.split()) : Cette partie du code met en place une boucle qui parcourt chaque mot distinct de la phrase après l'avoir divisée par des espaces à l'aide de sentence.split(). La fonction set() est utilisée pour s'assurer que seuls les mots distincts sont pris en compte.
        (mot, mot[::-1]) : Pour chaque mot, un tuple est créé contenant le mot original et son inverse obtenu en le découpant avec word[::-1].
        tuple(...) : Cette expression entoure l'expression du générateur et convertit les paires générées en un tuple.
    print(phrase) : Cette ligne de code affiche la phrase originale sur la console.
    print(distinct_reversed_word_tuples) : Cette ligne de code imprime le tuple distinct_reversed_word_tuples sur la console.
        \end{solution}
        

        \question
        Éléments distincts d'une liste de types de données mixtes sous forme de tuple

Exemple de sortie

[1, 'apple', 2.5, 'banana', 3, 'cherry']

(1, 2.5, 3, 'cerise', 'pomme', 'banane')
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q599.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite une liste, mixed_data, qui contient un mélange de différents types de données, et crée un tuple nommé distinct_mixed_elements_tuple contenant les éléments uniques de la liste. Voici comment fonctionne ce code :

    mixed_data = [1, 'apple', 2.5, 'banana', 3, 'cherry'] : Cette ligne initialise une variable nommée mixed_data et lui affecte une liste contenant un mélange d'entiers, de flottants et de chaînes de caractères.
    distinct_mixed_elements_tuple = tuple(set(item for item in mixed_data)) : Cette ligne initialise une variable nommée distinct_mixed_elements_tuple et lui affecte un tuple créé à l'aide d'une expression de générateur.
        set(item for item in mixed_data) : Cette partie du code convertit les éléments de mixed_data en un ensemble, qui supprime tout élément dupliqué. Pour ce faire, elle parcourt chaque élément de mixed_data.
        tuple(...) : Cette fonction entoure l'ensemble et le reconvertit en tuple.
    print(mixed_data) : Cette ligne de code imprime la liste originale de mixed_data sur la console.
    print(distinct_mixed_elements_tuple) : Cette ligne de code imprime le tuple distinct_mixed_elements_tuple sur la console.
        \end{solution}
        

        \question
        Paires d'éléments distincts et leur somme de chiffres, en utilisant divmod(), à partir de deux listes sous la forme d'un tuple

Exemple de résultat

[123, 456, 789]

[234, 567, 890]

((123, 234, 42), (456, 890, 140), (789, 890, 176), (456, 567, 114), (456, 234, 78), (123, 890, 104), (123, 567, 78), (789, 234, 114), (789, 567, 150))
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q600.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python combine deux listes, list1 et list2, puis crée un tuple nommé digit_sum_tuples contenant des paires uniques d'éléments des deux listes. Chaque paire se compose d'un élément de la liste 1 et d'un élément de la liste 2, ainsi que de la somme de leurs chiffres (sommes des chiffres individuels). Voici comment fonctionne le code :

    list1 = [123, 456, 789] : Cette ligne initialise une variable nommée list1 et lui attribue une liste contenant trois entiers.
    list2 = [234, 567, 890] : Cette ligne initialise une variable nommée list2 et lui affecte une autre liste contenant trois entiers.
    digit_sum_tuples = tuple(set((x, y, sum(divmod(x, 10)) + sum(divmod(y, 10))) for x in list1 for y in list2)) : Cette ligne initialise une variable nommée digit_sum_tuples et lui affecte un tuple créé à l'aide d'une expression du générateur.
        for x in list1 for y in list2 : Cette partie du code met en place des boucles imbriquées, parcourant les éléments de la liste 1 (x) et les éléments de la liste 2 (y).
        (x, y, sum(divmod(x, 10)) + sum(divmod(y, 10)) : Pour chaque paire d'éléments (x, y), cette partie crée un tuple contenant x, y et la somme de leurs chiffres.
            divmod(x, 10) : Cette fonction calcule le quotient et le reste lorsque x est divisé par 10. Elle décompose effectivement le nombre x en ses chiffres individuels.
            sum(...) : Cette fonction calcule la somme des chiffres obtenus à partir de divmod(x, 10) et divmod(y, 10).
        set(...) : Cette partie convertit les tuples générés en un ensemble, en supprimant les tuples en double.
        tuple(...) : Cette partie entoure l'ensemble et le reconvertit en tuple.
    print(list1) : Cette ligne de code affiche la liste originale list1 sur la console.
    print(list2) : Cette ligne de code imprime la liste 2 originale sur la console.
    print(digit_sum_tuples) : Cette ligne de code imprime le tuple digit_sum_tuples sur la console.
        \end{solution}
        

        \question
        Éléments distincts de plusieurs listes à l'aide de la différence symétrique ensembliste, sous la forme d'un tuple

Exemple de résultat

[1, 2, 3, 4]

[3, 4, 5, 6]

[5, 6, 7, 8]

(1, 2, 7, 8)
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q601.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite trois listes, list1, list2 et list3, et crée un tuple nommé distinct_elements_symmetric_diff. Ce tuple contient les éléments distincts présents dans l'une des trois listes. Voici comment fonctionne le code :

    list1 = [1, 2, 3, 4] : Cette ligne initialise une variable nommée list1 et lui affecte une liste contenant quatre entiers.
    list2 = [3, 4, 5, 6] : Cette ligne initialise une variable nommée list2 et lui affecte une autre liste contenant quatre entiers.
    list3 = [5, 6, 7, 8] : Cette ligne initialise une variable nommée list3 et lui affecte une troisième liste contenant quatre entiers.
    distinct_elements_symmetric_diff = tuple(set(list1) ^ set(list2) ^ set(list3)) : Cette ligne initialise une variable nommée distinct_elements_symmetric_diff et lui affecte un tuple créé en appliquant l'opération de différence symétrique (^) sur les ensembles d'éléments de list1, list2 et list3.
        set(list1) ^ set(list2) ^ set(list3) : Cette partie du code calcule la différence symétrique des ensembles créés à partir de list1, list2 et list3. La différence symétrique inclut les éléments qui sont uniques à chaque ensemble, c'est-à-dire les éléments qui sont présents dans exactement un des trois ensembles.
        tuple(...) : Cette fonction entoure l'ensemble et le reconvertit en tuple.
    print(list1) : Cette ligne de code imprime la liste originale list1 sur la console.
    print(list2) : Cette ligne de code imprime la liste 2 originale sur la console.
    print(list3) : Cette ligne de code imprime la liste 3 originale sur la console.
    print(distinct_elements_symmetric_diff) : Cette ligne de code imprime le tuple distinct_éléments_symétrique_diff sur la console.
        \end{solution}
        

        \question
        Paires de nombres et leur somme, les paires paires paires et impaires étant séparées, à partir de deux listes sous forme de tuple

Exemple de résultat

[1, 2, 3]

[4, 5, 6]

(((1, 5, 6), (2, 4, 6), (2, 6, 8), (3, 5, 8)), ((1, 4, 5), (1, 6, 7), (2, 5, 7), (3, 4, 7), (3, 6, 9)))
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q602.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite deux listes, list1 et list2, et crée un tuple de tuples nommé even_odd_sum_tuples. Ce tuple contient deux tuples internes : un pour les sommes paires et un pour les sommes impaires des paires d'éléments des deux listes. Voici comment fonctionne le code :

    list1 = [1, 2, 3] : Cette ligne initialise une variable nommée list1 et lui affecte une liste contenant trois entiers.
    list2 = [4, 5, 6] : Cette ligne initialise une variable nommée list2 et lui affecte une autre liste contenant trois entiers.
    even_odd_sum_tuples = (..., ...) : Cette ligne initialise une variable nommée even_odd_sum_tuples et lui affecte un tuple contenant deux tuples internes.
        tuple((x, y, x + y) for x in list1 for y in list2 if (x + y) % 2 == 0) : Le premier tuple interne contient des paires d'éléments de list1 et list2 (x, y) dont la somme (x + y) est paire. Il utilise une expression génératrice pour créer des tuples de la forme (x, y, x + y) pour les sommes paires.
        tuple((x, y, x + y) for x in list1 for y in list2 if (x + y) % 2 != 0) : Le deuxième tuple intérieur est similaire au premier, mais il inclut les paires dont la somme (x + y) est impaire.
    print(list1) : Cette ligne de code imprime la liste originale list1 sur la console.
    print(list2) : Cette ligne de code imprime la liste 2 originale sur la console.
    print(even_odd_sum_tuples) : Cette ligne de code imprime le tuple even_odd_sum_tuples sur la console.
        \end{solution}
        

        \question
        Paires d'éléments distincts et leur somme de chiffres provenant de deux listes sous forme de tuple

Exemple de résultat

[123, 456, 789]

[234, 567, 890]

((123, 234, 15), (123, 567, 24), (123, 890, 23), (456, 234, 24), (456, 567, 33), (456, 890, 32), (789, 234, 33), (789, 567, 42), (789, 890, 41))
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q603.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite deux listes, list1 et list2, et crée un tuple de tuples nommé digit_sum_tuples. Le tuple contient des paires d'éléments des deux listes et la somme de leurs chiffres. Voici comment fonctionne le code :

    list1 = [123, 456, 789] : Cette ligne initialise une variable nommée list1 et lui affecte une liste contenant trois entiers.
    list2 = [234, 567, 890] : Cette ligne initialise une variable nommée list2 et lui affecte une autre liste contenant trois entiers.
    digit_sum_tuples = tuple(...) : Cette ligne initialise une variable nommée digit_sum_tuples et lui affecte un tuple créé à l'aide d'une expression génératrice.
        (... for x in list1 for y in list2) : L'expression du générateur parcourt toutes les paires d'éléments (x, y) de list1 et list2.
        (x, y, sum(int(digit) for digit in str(x)) + sum(int(digit) for digit in str(y))) : Pour chaque paire d'éléments (x, y), il calcule la somme des chiffres dans x et y en les convertissant en chaînes, en divisant les chaînes en chiffres et en additionnant ces chiffres. Il crée ensuite un tuple de la forme (x, y, somme_des_chiffres).
    print(list1) : Cette ligne de code imprime la liste originale list1 sur la console.
    print(list2) : Cette ligne de code imprime la liste 2 originale sur la console.
    print(digit_sum_tuples) : Cette ligne de code imprime le tuple digit_sum_tuples sur la console.
        \end{solution}
        

        \question
        Caractères distincts de plusieurs chaînes avec insensibilité à la casse sous forme de tuple

Exemple de sortie

['apple', 'Banana', 'Cherry']

('e', 'h', 'b', 'n', 'c', 'r', 'p', 'y', 'a', 'l')
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q604.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite une liste de chaînes de caractères, strings, et crée un tuple nommé distinct_case_insensitive_chars. Ce tuple contient des caractères distincts (insensibles à la casse) de toutes les chaînes de la liste. Voici comment fonctionne le code :

    chaînes = ["pomme", "banane", "cerise"] : Cette ligne initialise une variable nommée strings et lui affecte une liste de trois chaînes de caractères, y compris les caractères majuscules et minuscules.
    distinct_case_insensitive_chars = tuple(...) : Cette ligne initialise une variable nommée distinct_case_insensitive_chars et lui affecte un tuple créé à l'aide d'un générateur d'expressions.
        (... for string in strings for char in string) : L'expression du générateur parcourt chaque chaîne de la liste des chaînes, puis chaque caractère de chaque chaîne.
        char.lower() for ... : Pour chaque caractère char, il convertit le caractère en minuscules à l'aide de la méthode lower(). Cela permet de s'assurer que les caractères sont traités sans tenir compte de la casse.
    set(...) : La fonction set(...) est utilisée pour s'assurer que seuls les caractères distincts sont conservés. Étant donné que les ensembles n'autorisent pas les éléments en double, cette opération élimine automatiquement les caractères en double.
    tuple(...) : Enfin, l'ensemble de caractères insensibles à la casse est converti en un tuple.
    print(strings) : Cette ligne de code imprime la liste originale des chaînes de caractères sur la console.
    print(caractères_insensibles_à la casse distincts) : Cette ligne de code imprime le n-uplet distinct_case_insensitive_chars sur la console.
        \end{solution}
        

        \question
        Paires de mots distincts et leur longueur, à l'exclusion des mots dont la longueur n'est pas divisible par 3, dans une phrase sous forme de tuple

Exemple de résultat

Bonjour, comment allez-vous ?

(('how', 3), ('Hello,', 6), ('are', 3))
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q605.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite une phrase et crée un tuple nommé divisible_by_3_length_word_length_tuples. Le tuple contient des paires mot-longueur pour les mots de la phrase dont la longueur est divisible par 3. Voici comment fonctionne le code :

    sentence = "Hello, how are you ?": Cette ligne initialise une variable nommée sentence et lui affecte une chaîne de caractères contenant une phrase.
    divisible_by_3_length_word_length_tuples = tuple(...) : Cette ligne initialise une variable nommée divisible_by_3_length_word_length_tuples et lui affecte un tuple créé à l'aide d'une expression génératrice.
        (... for word in set(sentence.split())) : L'expression du générateur parcourt chaque mot unique de la phrase en la divisant en mots à l'aide de split() et en convertissant le résultat en un ensemble afin d'éliminer les mots en double.
        (mot, len(mot)) pour ... : Pour chaque mot unique, il crée un tuple contenant le mot lui-même et sa longueur (nombre de caractères).
        if len(word) % 3 == 0 : La condition if len(word) % 3 == 0 vérifie si la longueur du mot est divisible par 3.
    print(phrase) : Cette ligne de code imprime la phrase originale sur la console.
    print(divisible_par_3_longueur_de_mots) : Cette ligne de code affiche sur la console le tuple divisible_par_3_longueur_de_mots_longueur_de_tuples.
        \end{solution}
        

        \question
        DEPART DES Ensembles
Générer un ensemble de carrés de nombres de 1 à 10

Exemple de sortie

\{64, 1, 4, 36, 100, 9, 16, 49, 81, 25\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q606.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Crée un ensemble nommé carrés qui contient les carrés des nombres de 1 à 10. Voici comment fonctionne le code :

    {x**2 for x in range(1, 11)} : Il s'agit d'une compréhension d'ensemble. Elle parcourt les nombres de 1 à 10 (inclus) en utilisant range(1, 11) et calcule le carré de chaque nombre x en utilisant x**2. La compréhension de l'ensemble rassemble ces valeurs au carré dans un ensemble.
    print(carrés) : Cette ligne de code affiche les carrés de l'ensemble sur la console.
        \end{solution}
        

        \question
        Créer un ensemble de nombres pairs de 1 à 20

Exemple de résultat

\{2, 4, 6, 8, 10, 12, 14, 16, 18, 20\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q607.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python génère un ensemble nommé evens contenant des nombres pairs compris entre 2 et 20 (inclus). Voici comment fonctionne le code :

    evens = {x for x in range(2, 21, 2)} : Cette ligne utilise une compréhension d'ensemble pour créer l'ensemble des pairs. Elle parcourt les nombres compris entre 2 et 20 (inclus) avec un pas de 2. Cette plage comprend tous les nombres pairs de cette plage.
    La compréhension de l'ensemble {...} rassemble ces nombres pairs et forme un ensemble avec des éléments distincts. Comme les ensembles n'autorisent pas les valeurs dupliquées, seuls les nombres pairs distincts sont inclus dans l'ensemble.
    print(evens) : Cette ligne affiche l'ensemble evens sur la console.
        \end{solution}
        

        \question
        Générer un ensemble de caractères à partir d'une chaîne de caractères

Exemple de sortie

Bonjour à tous !

\{'e', 'r', 'o', 'H', 'w', 'l', 'd'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q608.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite une chaîne, string, et crée un ensemble, chars, contenant des caractères alphabétiques uniques (lettres) de la chaîne. Voici comment fonctionne ce code :

    string = "Hello, world !": Cette ligne initialise une variable nommée string et lui affecte la chaîne "Hello, world !"
    chars = {char for char in string if char.isalpha()} : Cette ligne initialise une variable nommée chars et lui affecte un ensemble créé à l'aide d'une compréhension d'ensemble. Elle itère sur chaque caractère char dans la chaîne et l'ajoute à l'ensemble s'il s'agit d'un caractère alphabétique (une lettre).
        {...} : Cette notation est utilisée pour créer un ensemble.
        char pour char dans la chaîne : Cette partie de la compréhension itère sur chaque caractère de la chaîne.
        if char.isalpha() : Cette vérification conditionnelle permet de s'assurer que seuls les caractères alphabétiques (lettres) sont inclus dans l'ensemble. Elle utilise la méthode isalpha() pour déterminer si un caractère est une lettre.
    print(string) : Cette ligne de code imprime la chaîne de caractères originale sur la console.
    print(chars) : Cette ligne de code imprime le jeu de caractères sur la console.
        \end{solution}
        

        \question
        Créer un ensemble de longueurs de mots dans une phrase

Exemple de sortie

Voici un exemple de phrase.

\{1, 2, 4, 6, 9\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q609.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite une phrase, sentence, et crée un ensemble, word_lengths, contenant les longueurs des mots dans la phrase. Voici comment fonctionne le code :

    sentence = "Ceci est un exemple de phrase" : Cette ligne initialise une variable nommée sentence et lui affecte la chaîne de caractères "Ceci est un exemple de phrase".
    word_lengths = {len(word) for word in sentence.split()} : Cette ligne initialise une variable nommée word_lengths et lui affecte un ensemble créé à l'aide d'une compréhension d'ensemble. Elle divise la phrase en mots à l'aide de split() et itère sur chaque mot, en ajoutant sa longueur (nombre de caractères) à l'ensemble.
        {...} : Cette notation est utilisée pour créer un ensemble.
        len(word) for word in sentence.split() : Cette partie de la compréhension passe en revue chaque mot de la phrase après l'avoir divisée et calcule la longueur de chaque mot à l'aide de len(word).
    print(sentence) : Cette ligne de code imprime la phrase originale sur la console.
    print(longueur_des_mots) : Cette ligne de code affiche sur la console le jeu de mots_longueurs.
        \end{solution}
        

        \question
        Générer un ensemble de nombres premiers de 1 à 50

Exemple de résultat

\{2, 3, 5, 37, 7, 41, 11, 43, 13, 47, 17, 19, 23, 29, 31\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q610.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python définit une fonction is_prime pour vérifier si un nombre donné est premier ou non. Il utilise ensuite une compréhension d'ensemble pour créer un ensemble appelé prime_numbers contenant tous les nombres premiers de 1 à 50. Voici une explication pas à pas du code :

    def is_prime(n) : Cette ligne définit une fonction nommée is_prime qui prend un entier n comme argument. Elle renvoie True si n est un nombre premier et False dans le cas contraire.
    if n <= 1: : C'est la première condition. Si n est inférieur ou égal à 1, il ne s'agit pas d'un nombre premier. Les nombres premiers sont supérieurs à 1, la fonction renvoie donc False dans ce cas.
    for i in range(2, int(n**0.5) + 1): : Cette boucle itère de 2 à la racine carrée de n (arrondie à l'entier le plus proche) plus 1. Il s'agit d'une optimisation visant à réduire le nombre de diviseurs à vérifier. Les nombres premiers n'ont pas d'autres diviseurs que 1 et eux-mêmes, et nous n'avons besoin de vérifier que jusqu'à la racine carrée de n.
    if n % i == 0: : Cette condition vérifie si n est divisible par i. Si c'est le cas, alors n n'est pas un nombre premier et la fonction renvoie False.
    return True : Si la fonction ne renvoie pas False dans les conditions précédentes, cela signifie que n n'est divisible par aucun nombre dans l'intervalle donné et qu'il s'agit d'un nombre premier. Dans ce cas, la fonction renvoie True.
    nombres_premiers = {x for x in range(1, 51) if is_prime(x)} : Cette ligne crée un ensemble appelé nombres_premiers à l'aide d'une compréhension d'ensemble. Elle parcourt les nombres de 1 à 50 et les inclut dans l'ensemble si la fonction is_prime renvoie True pour ce nombre. Cet ensemble de compréhension rassemble tous les nombres premiers de 1 à 50.
    print(nombres_premiers) : Cette ligne imprime l'ensemble prime_numbers sur la console, en affichant tous les nombres premiers compris entre 1 et 50.
        \end{solution}
        

        \question
        Créer un ensemble de lettres minuscules

Exemple de résultat

\{'a', 'e', 'u', 'z', 'y', 'j', 'k', 't', 'x', 'd', 'r', 'v', 'o', 'h', 'f', 'i', 'c', 'g', 'l', 'p', 'b', 'n', 'm', 'q', 's', 'w'\}.
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q611.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Crée un ensemble nommé lowercase_letters contenant toutes les lettres minuscules de l'alphabet anglais. Voici comment fonctionne le code :

    {chr(x) for x in range(ord('a'), ord('z')+1)} : Il s'agit d'une compréhension d'ensemble qui itère sur une plage de points de code Unicode correspondant aux lettres minuscules anglaises.
        chr(x) : Cette fonction convertit un point de code Unicode x en un caractère correspondant.
        for x in range(ord('a'), ord('z')+1) : Elle parcourt une plage de points de code, en commençant par le point de code 'a' (ord('a')) jusqu'au point de code 'z' (ord('z')), inclus.
    lettres minuscules = {...} : Cette partie du code initialise une variable nommée lettres minuscules et lui assigne l'ensemble créé par la compréhension de l'ensemble.
    print(lettres_case_inférieures) : Cette ligne de code imprime l'ensemble lowercase_letters sur la console.
        \end{solution}
        

        \question
        Générer un ensemble de lettres majuscules

Exemple de résultat

\{'U', 'M', 'F', 'D', 'A', 'I', 'R', 'Y', 'V', 'N', 'T', 'P', 'X', 'O', 'C', 'L', 'W', 'Q', 'K', 'J', 'H', 'Z', 'E', 'G', 'S', 'B' \}.
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q612.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un ensemble nommé uppercase_letters contenant toutes les lettres majuscules de l'alphabet anglais. Voici comment fonctionne ce code :

    {chr(x) for x in range(ord('A'), ord('Z')+1)} : Il s'agit d'une compréhension d'ensemble qui itère sur une plage de points de code Unicode correspondant aux lettres majuscules de l'alphabet anglais.
        chr(x) : Cette fonction convertit un point de code Unicode x en un caractère correspondant.
        for x in range(ord('A'), ord('Z')+1) : Elle parcourt une plage de points de code, en commençant par le point de code 'A' (ord('A')) jusqu'au point de code 'Z' (ord('Z')), inclus.
    lettres_majuscules = {...} : Cette partie du code initialise une variable nommée uppercase_letters et lui assigne l'ensemble créé par la compréhension de l'ensemble.
    print(uppercase_letters) : Cette ligne de code imprime l'ensemble uppercase_letters sur la console.
        \end{solution}
        

        \question
        Créer un ensemble de nombres pairs au carré et de nombres impairs au cube de 1 à 10

Exemple de résultat

\{64, 1, 4, 36, 100, 16, 343, 729, 27, 125\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q613.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un ensemble nommé result. L'ensemble contient les carrés des nombres pairs et les cubes des nombres impairs dans l'intervalle de 1 à 10. Voici comment fonctionne le code :

    result = {x**2 if x % 2 == 0 else x**3 for x in range(1, 11)} : Cette ligne initialise un ensemble nommé result à l'aide d'une compréhension d'ensemble.
        for x in range(1, 11) : Cette partie du code met en place une boucle qui parcourt les nombres de 1 à 10 (inclus).
        {x**2 if x % 2 == 0 else x**3} : Pour chaque nombre x, cette partie calcule le carré (x**2) si x est pair (c'est-à-dire si x % 2 == 0 est vrai) et le cube (x**3) si x est impair.
    print(result) : Cette ligne de code affiche le résultat sur la console.
        \end{solution}
        

        \question
        Générer un ensemble de multiples communs de 3 et 5 jusqu'à 100

Exemple de sortie

\{75, 45, 15, 90, 60, 30\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q614.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un ensemble nommé common_multiples. L'ensemble contient les multiples communs de 3 et 5 dans l'intervalle de 1 à 100. Voici comment fonctionne le code :

    common_multiples = {x for x in range(1, 101) if x % 3 == 0 and x % 5 == 0} : Cette ligne initialise l'ensemble common_multiples à l'aide d'une compréhension de l'ensemble.
        for x in range(1, 101) : Cette partie du code met en place une boucle qui parcourt les nombres de 1 à 100 (inclus).
        {x} : Pour chaque nombre x, cette partie l'inclut dans l'ensemble s'il est un multiple de 3 (x % 3 == 0) et également un multiple de 5 (x % 5 == 0).
    print(common_multiples) : Cette ligne de code affiche l'ensemble common_multiples sur la console.
        \end{solution}
        

        \question
        Créer un ensemble de chaînes inversées à partir d'un autre ensemble

Exemple de sortie

\{'cerise', 'pomme', 'banane'\}

\{'ananab', 'elppa', 'yrrehc'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q615.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise la compréhension d'un ensemble pour créer un ensemble nommé mots_inversés contenant les versions inversées des mots de l'ensemble original mots. Voici comment fonctionne ce code :

    words = {"apple", "banana", "cherry"} : Cette ligne initialise un ensemble nommé words contenant trois mots : "pomme", "banane" et "cerise".
    mots_inversés = {mot[::-1] pour mot dans mots} : Cette ligne initialise l'ensemble reversed_words à l'aide d'une compréhension de l'ensemble.
        pour mot dans mots : Cette partie du code met en place une boucle qui parcourt chaque mot de l'ensemble des mots.
        {word[::-1]} : Pour chaque mot, cette partie inclut son inverse (chaîne inversée) dans l'ensemble mots_inversés. L'opération de découpage word[::-1] est utilisée pour inverser le mot.
    print(words) : Cette ligne de code affiche le jeu de mots original sur la console.
    print(mots_inversés) : Cette ligne de code affiche le jeu de mots inversés sur la console.
        \end{solution}
        

        \question
        Générer un ensemble de racines carrées positives à partir d'un ensemble de nombres positifs

Exemple de résultat

\{16, 1, 4, 9, 25\}

\{1.0, 2.0, 3.0, 4.0, 5.0\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q616.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un ensemble nommé positive_sqrt qui contient les racines carrées des nombres de l'ensemble positive_numbers. Voici comment fonctionne le code :

    nombres_positifs = {1, 4, 9, 16, 25} : Cette ligne initialise un ensemble nommé nombres_positifs contenant cinq entiers positifs.
    positive_sqrt = {math.sqrt(x) for x in positive_numbers} : Cette ligne initialise l'ensemble positive_sqrt à l'aide d'une compréhension de l'ensemble.
        for x in positive_numbers : Cette partie du code met en place une boucle qui parcourt chaque nombre de l'ensemble positive_numbers.
        {math.sqrt(x)} : Pour chaque nombre, cette partie inclut sa racine carrée, calculée à l'aide de la fonction math.sqrt(), dans l'ensemble positive_sqrt.
    print(nombres_positifs) : Cette ligne de code affiche sur la console le jeu de nombres positifs d'origine.
    print(positive_sqrt) : Cette ligne de code affiche l'ensemble positive_sqrt sur la console.
        \end{solution}
        

        \question
        Créer un ensemble de mots en majuscules à partir d'une phrase

Exemple de sortie

Voici un exemple de phrase.

\{'SAMPLE', 'THIS', 'SENTENCE.', 'A', 'IS'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q617.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un ensemble nommé mots_uppercase qui contient les versions en majuscules des mots de la phrase d'entrée. Voici comment fonctionne le code :

    sentence = "Ceci est un exemple de phrase" : Cette ligne initialise une chaîne nommée sentence contenant un exemple de phrase.
    uppercase_words = {word.upper() for word in sentence.split()} : Cette ligne initialise l'ensemble uppercase_words à l'aide d'une compréhension de l'ensemble.
        for word in sentence.split() : Cette partie du code divise la phrase en mots à l'aide de la méthode split() et met en place une boucle pour parcourir les mots.
        {word.upper()} : Pour chaque mot, cette partie inclut sa version en majuscules (convertie à l'aide de la méthode upper()) dans l'ensemble uppercase_words.
    print(sentence) : Cette ligne de code imprime la phrase originale sur la console.
    print(mots_uppercase) : Cette ligne de code imprime le jeu de mots en majuscules sur la console.
        \end{solution}
        

        \question
        Générer un ensemble de caractères non-voyelles à partir d'une chaîne de caractères

Exemple de sortie

Bonjour à tous !

\{' ', '!', 'w', ',', 'r', 'H', 'l', 'd' \}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q618.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un ensemble nommé non_voyelles qui contient les caractères non-voyelles de la chaîne d'entrée. Voici comment fonctionne ce code :

    string = "Hello, world !": Cette ligne initialise une chaîne nommée string contenant le texte "Hello, world !".
    non_voyelles = {char for char in string if char.lower() not in 'aeiou'} : Cette ligne initialise l'ensemble non_voyelles à l'aide d'une compréhension d'ensemble.
        for char in string : Cette partie du code met en place une boucle qui parcourt chaque caractère de la chaîne.
        {char} : Pour chaque caractère, cette partie l'inclut dans l'ensemble non_voyelles s'il ne s'agit pas d'une voyelle. La condition char.lower() not in 'aeiou' vérifie que la version minuscule du caractère ne se trouve pas dans la chaîne 'aeiou', filtrant ainsi les voyelles.
    print(string) : Cette ligne de code imprime la chaîne originale sur la console.
    print(non_voyelles) : Cette ligne de code imprime le jeu de non_voyelles sur la console.
        \end{solution}
        

        \question
        Créer un ensemble de numéros uniques à partir d'une liste

Exemple de sortie

[1, 2, 3, 2, 4, 5, 1]

\{1, 2, 3, 4, 5\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q619.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un ensemble nommé nombres_uniques qui contient les éléments uniques de la liste nombres. Voici comment fonctionne ce code :

    nombres = [1, 2, 3, 2, 4, 5, 1] : Cette ligne initialise une liste nommée numbers contenant plusieurs entiers, dont certaines valeurs répétées.
    nombres_uniques = {x for x in numbers} : Cette ligne initialise l'ensemble unique_numbers à l'aide d'une compréhension d'ensemble.
        pour x dans nombres : Cette partie du code met en place une boucle qui parcourt chaque élément de la liste des nombres.
        {x} : Pour chaque élément, cette partie l'inclut dans l'ensemble unique_numbers. Cependant, comme les ensembles ne permettent pas de dupliquer les éléments, seuls les éléments uniques sont inclus dans l'ensemble résultant.
    print(nombres) : Cette ligne de code imprime la liste originale des nombres sur la console.
    print(nombres_uniques) : Cette ligne de code affiche l'ensemble unique_numbers sur la console.
        \end{solution}
        

        \question
        nérer un ensemble de valeurs ASCII de caractères à partir d'une chaîne de caractères

Exemple de sortie

Bonjour à tous !

\{32, 33, 100, 101, 72, 108, 44, 111, 114, 119\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q620.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un ensemble nommé ascii_values qui contient les valeurs ASCII des caractères de la chaîne d'entrée. Voici comment fonctionne le code :

    string = "Hello, world !": Cette ligne initialise une chaîne nommée string contenant le texte "Hello, world !".
    ascii_values = {ord(char) for char in string} : Cette ligne initialise l'ensemble ascii_values à l'aide d'une compréhension d'ensemble.
        for char in string : Cette partie du code met en place une boucle qui parcourt chaque caractère de la chaîne.
        {ord(char)} : Pour chaque caractère, cette partie inclut sa valeur ASCII, calculée à l'aide de la fonction ord(), dans l'ensemble ascii_values.
    print(string) : Cette ligne de code imprime la chaîne de caractères originale sur la console.
    print(ascii_values) : Cette ligne de code imprime le jeu de valeurs ascii sur la console.
        \end{solution}
        

        \question
        Générer un ensemble de tuples contenant des nombres et leurs carrés

Exemple de sortie

\{(2, 4), (4, 16), (1, 1), (3, 9), (5, 25)\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q621.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un ensemble nommé num_squares qui contient des tuples avec des paires de nombres et leurs carrés. Voici comment fonctionne le code :

    {(x, x**2) for x in range(1, 6)} : Cette compréhension d'ensemble crée un ensemble en itérant à travers les valeurs de x de 1 à 5 (inclus). Pour chaque valeur de x, elle génère un tuple (x, x**2) contenant le nombre original x et son carré x**2. Le résultat est un ensemble de ces tuples.
    print(num_squares) : Cette ligne de code affiche l'ensemble num_squares sur la console.
        \end{solution}
        

        \question
        Créer un ensemble de voyelles à partir d'une chaîne de caractères

Exemple de sortie

Bonjour à tous !

\{'e', 'o'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q622.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un ensemble nommé voyelles qui contient des voyelles minuscules à partir de la chaîne d'entrée. Voici comment fonctionne le code :

    string = "Hello, world !": Cette ligne initialise une chaîne nommée string contenant le texte "Hello, world !".
    voyelles = {char.lower() for char in string if char.lower() in 'aeiou'} : Cette ligne initialise l'ensemble des voyelles à l'aide d'une compréhension de l'ensemble.
        for char in string : Cette partie du code met en place une boucle qui parcourt chaque caractère de la chaîne.
        {char.lower()} : Pour chaque caractère, cette partie inclut sa version minuscule dans l'ensemble des voyelles, mais uniquement s'il s'agit d'une voyelle. La condition char.lower() dans 'aeiou' vérifie si la version minuscule du caractère est l'une des voyelles minuscules.
    print(string) : Cette ligne de code imprime la chaîne de caractères originale sur la console.
    print(voyelles) : Cette ligne de code imprime le jeu de voyelles sur la console.
        \end{solution}
        

        \question
        Générer un ensemble de nombres qui sont des carrés parfaits de 1 à 100

Exemple de sortie

\{64, 1, 4, 36, 100, 9, 16, 49, 81, 25\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q623.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un ensemble nommé perfect_squares qui contient des nombres carrés parfaits compris entre 1 et 100. Voici comment fonctionne le code :

    {x for x in range(1, 101) if int(x**0.5)**2 == x} : Cette compréhension d'ensemble crée un ensemble en parcourant les valeurs de x de 1 à 100 (inclus). Pour chaque valeur de x, elle vérifie si la valeur entière de la racine carrée de x (int(x**0.5)) au carré (**2) est égale à x. Si cette condition est vraie, elle inclut x dans l'ensemble perfect_squares.
    print(perfect_squares) : Cette ligne de code affiche l'ensemble perfect_squares sur la console.
        \end{solution}
        

        \question
        Générer un ensemble de caractères qui sont des chiffres à partir d'une chaîne de caractères

Exemple de sortie

12345Bonjour67890

\{'2', '8', '7', '3', '9', '0', '1', '5', '4', '6'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q624.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un ensemble nommé digits qui contient tous les caractères digitaux uniques de la chaîne d'entrée. Voici comment fonctionne le code :

    string = "12345Hello67890" : Cette ligne initialise une chaîne nommée chaîne contenant un mélange de chiffres et de caractères non numériques.
    digits = {char for char in string if char.isdigit()} : Cette ligne initialise l'ensemble de chiffres à l'aide d'une compréhension de l'ensemble.
        for char in string : Cette partie du code met en place une boucle qui parcourt chaque caractère de la chaîne.
        {char.isdigit()} : Pour chaque caractère, cette partie inclut le caractère dans le jeu de chiffres s'il s'agit d'un chiffre. La condition char.isdigit() vérifie si le caractère est un chiffre ou non.
    print(string) : Cette ligne de code imprime la chaîne de caractères originale sur la console.
    print(digits) : Cette ligne de code imprime le jeu de chiffres sur la console.
        \end{solution}
        

        \question
        Créer un ensemble de nombres qui sont des puissances de 2 de 1 à 10

Exemple de résultat

\{32, 64, 2, 128, 4, 256, 512, 1024, 8, 16\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q625.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un ensemble nommé puissances_de_2 qui contient les puissances de 2 pour x allant de 1 à 10. Voici comment fonctionne le code :

    {2**x for x in range(1, 11)} : Cette compréhension d'ensemble crée un ensemble en parcourant les valeurs de x de 1 à 10 (inclus). Pour chaque valeur de x, elle calcule la puissance de 2 correspondante, 2**x, et l'inclut dans l'ensemble powers_of_2.
    print(puissances_de_2) : Cette ligne de code affiche l'ensemble powers_of_2 sur la console.
        \end{solution}
        

        \question
        Générer un ensemble d'éléments communs à partir de deux listes

Exemple de sortie

[1, 2, 3, 4, 5]

[3, 4, 5, 6, 7]

\{3, 4, 5\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q626.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un ensemble nommé common_elements qui contient les éléments communs à deux listes, list1 et list2. Voici comment fonctionne ce code :

    list1 = [1, 2, 3, 4, 5] et list2 = [3, 4, 5, 6, 7] : Ces lignes initialisent deux listes, list1 et list2, avec des valeurs entières.
    common_elements = {x for x in list1 if x in list2} : Cette ligne initialise l'ensemble common_elements à l'aide d'une compréhension d'ensemble.
        for x in list1 : Cette partie du code met en place une boucle qui parcourt chaque élément x de la liste1.
        {x for x in list1 if x in list2} : Pour chaque élément x dans list1, cette partie inclut x dans l'ensemble common_elements s'il se trouve également dans list2.
    print(list1) : Cette ligne de code affiche list1 sur la console.
    print(list2) : Cette ligne de code affiche la liste 2 sur la console.
    print(common_elements) : Cette ligne de code affiche le jeu d'éléments communs sur la console.
        \end{solution}
        

        \question
        Générer un ensemble de caractères non alphanumériques à partir d'une chaîne de caractères

Exemple de sortie

Bonjour à tous !

\{'!', ' ', ','\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q627.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un ensemble nommé non_alphanumeric qui contient tous les caractères non alphanumériques de la chaîne d'entrée. Voici comment fonctionne ce code :

    string = "Hello, world !": Cette ligne initialise une chaîne nommée string contenant des lettres, des espaces et des signes de ponctuation.
    non_alphanumeric = {char for char in string if not char.isalnum()} : Cette ligne initialise l'ensemble non_alphanumérique à l'aide d'une compréhension d'ensemble.
        for char in string : Cette partie du code met en place une boucle qui parcourt chaque caractère de la chaîne.
        {char.isalnum()} : Pour chaque caractère, cette partie inclut le caractère dans l'ensemble non_alphanumérique s'il n'est pas alphanumérique. La condition char.isalnum() vérifie si le caractère est alphanumérique ou non.
    print(string) : Cette ligne de code imprime la chaîne de caractères originale sur la console.
    print(non_alphanumerique) : Cette ligne de code imprime le jeu de caractères non alphanumériques sur la console.
        \end{solution}
        

        \question
        Créer un ensemble de caractères qui sont des consonnes à partir d'une chaîne de caractères

Exemple de sortie

Bonjour à tous !

\{'H', 'r', 'w', 'd', 'l' \}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q628.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un ensemble nommé consonnes qui contient tous les caractères consonants de la chaîne d'entrée. Voici comment fonctionne ce code :

    string = "Hello, world !": Cette ligne initialise une chaîne nommée chaîne contenant des lettres, des espaces et des signes de ponctuation.
    consonnes = {char for char in string if char.isalpha() and char.lower() not in 'aeiou'} : Cette ligne initialise l'ensemble des consonnes à l'aide d'une compréhension de l'ensemble.
        for char in string : Cette partie du code met en place une boucle qui parcourt chaque caractère de la chaîne.
        {char.isalpha() et char.lower() not in 'aeiou'} : Pour chaque caractère, cette partie inclut le caractère dans le jeu de consonnes s'il s'agit d'un caractère alphabétique (c'est-à-dire char.isalpha()) et non d'une voyelle minuscule (c'est-à-dire char.lower() not in 'aeiou').
    print(string) : Cette ligne de code affiche la chaîne de caractères originale sur la console.
    print(consonnes) : Cette ligne de code affiche le jeu de consonnes sur la console.
        \end{solution}
        

        \question
        Créer un ensemble de chaînes de caractères avec des caractères en majuscules

Exemple de sortie

\{'banane', 'pomme', 'cerise'\}

\{'APPLE', 'BANANA', 'CHERRY'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q629.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un nouvel ensemble nommé uppercase_strings qui contient les versions en majuscules des mots de l'ensemble d'entrée strings. Voici comment fonctionne ce code :

    strings = {"apple", "banana", "cherry"} : Cette ligne initialise un ensemble nommé strings avec trois éléments de chaîne.
    uppercase_strings = {word.upper() for word in strings} : Cette ligne initialise l'ensemble uppercase_strings à l'aide d'une compréhension de l'ensemble.
        for word in strings : Cette partie du code met en place une boucle qui parcourt chaque mot (chaîne) de l'ensemble strings.
        {word.upper()} : Pour chaque mot, cette partie inclut la version en majuscules du mot dans l'ensemble uppercase_strings à l'aide de la méthode .upper().
    print(strings) : Cette ligne de code imprime les chaînes du jeu original sur la console.
    print(uppercase_strings) : Cette ligne de code imprime le jeu de chaînes en majuscules sur la console.
        \end{solution}
        

        \question
        Créer une série de mots avec leurs caractères triés.

Exemple de sortie

\{'banane', 'pomme', 'cerise'\}

\{'aaabnn', 'aelpp', 'cehrry'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q630.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise la compréhension d'un ensemble pour créer un nouvel ensemble appelé sorted_chars, qui contient les mots de l'ensemble d'entrée words, mais dont les caractères sont triés par ordre alphabétique. Voici comment fonctionne ce code :

    words = {"apple", "banana", "cherry"} : Cette ligne initialise un ensemble nommé words avec trois éléments de type chaîne de caractères.
    sorted_chars = {''.join(sorted(word)) for word in words} : Cette ligne initialise l'ensemble sorted_chars à l'aide d'une compréhension d'ensemble.
        for word in words : Cette partie du code met en place une boucle qui parcourt chaque mot (chaîne) de l'ensemble words.
        {''.join(sorted(word))} : Pour chaque mot, cette partie trie les caractères du mot par ordre alphabétique à l'aide de la fonction sorted(), puis ''.join() est utilisé pour concaténer les caractères triés en une seule chaîne.
    print(words) : Cette ligne de code imprime les mots du jeu original sur la console.
    print(sorted_chars) : Cette ligne de code affiche le jeu de caractères triés sur la console.
        \end{solution}
        

        \question
        Générer un ensemble de tuples contenant des nombres pairs et impairs de 1 à 10

Exemple de sortie

\{(3, 4), (5, 4), (3, 10), (9, 2), (5, 10), (9, 8), (1, 6), (7, 4), (7, 10), (5, 6), (3, 6), (9, 4), (9, 10), (1, 2), (1, 8), (7, 6), (3, 2), (5, 2), (3, 8), (5, 8), (9, 6), (1, 4), (1, 10), (7, 2), (7, 8)\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q631.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un nouvel ensemble nommé even_odd_pairs. Il contient des paires de nombres dont le premier (x) est impair et compris entre 1 et 10, et le second (y) est pair et compris entre 2 et 12. Voici comment fonctionne le code :

    {(x, y) for x in range(1, 11, 2) for y in range(2, 12, 2)} : Il s'agit d'une compréhension d'ensemble qui crée des paires (x, y) pour x dans l'intervalle des nombres impairs de 1 à 10 (1, 3, 5, 7, 9) et pour y dans l'intervalle des nombres pairs de 2 à 12 (2, 4, 6, 8, 10, 12).
        pour x dans range(1, 11, 2) : Cette partie du code met en place la boucle externe, qui parcourt les nombres impairs de 1 à 10 avec un pas de 2.
        for y in range(2, 12, 2) : Cette partie du code met en place la boucle interne, itérant à travers les nombres pairs de 2 à 12 avec un pas de 2.
        (x, y) : Pour chaque combinaison de x et y, il crée un tuple contenant les valeurs de x et y.
    print(even_odd_pairs) : Cette ligne de code affiche l'ensemble even_odd_pairs sur la console.
        \end{solution}
        

        \question
        Créer un ensemble de mots dont les voyelles sont remplacées par des traits de soulignement.

Exemple de résultat

\{'banane', 'cerise', 'pomme'\}

\{'\_ppl\_', 'ch\_rry', 'b\_n\_n\_'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q632.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise la compréhension d'un ensemble pour créer un nouvel ensemble nommé vowel_replaced, qui contient des mots de l'ensemble d'entrée words avec des voyelles remplacées par des traits de soulignement. Voici comment fonctionne ce code :

    words = {"apple", "banana", "cherry"} : Cette ligne initialise un ensemble nommé words avec trois éléments de type chaîne de caractères.
    vowel_replaced = {''.join(['_' if char.lower() in 'aeiou' else char for char in word]) for word in words} : Cette ligne initialise l'ensemble vowel_replaced à l'aide d'une compréhension de l'ensemble.
        for word in words : Cette partie du code met en place une boucle qui parcourt chaque mot (chaîne) de l'ensemble de mots.
        ''.join(['_' if char.lower() in 'aeiou' else char for char in word]) : Pour chaque mot, cette partie crée une nouvelle chaîne où chaque caractère est remplacé par un trait de soulignement ('_') s'il s'agit d'une voyelle (en minuscules), ou laissé inchangé s'il ne s'agit pas d'une voyelle.
    print(words) : Cette ligne de code imprime les mots du jeu original sur la console.
    print(voyelle_remplacée) : Cette ligne de code affiche sur la console le jeu de voyelles_remplacées.
        \end{solution}
        

        \question
        Générer un ensemble de tuples contenant des nombres et leurs cubes

Exemple de sortie

\{(3, 27), (4, 64), (1, 1), (5, 125), (2, 8)\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q633.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un nouvel ensemble nommé num_cubes. Il contient des paires de nombres où le premier nombre (x) est compris entre 1 et 5, et le second nombre est le cube de x. Voici comment fonctionne le code :

    {(x, x**3) for x in range(1, 6)} : Il s'agit d'une compréhension d'ensemble qui crée des paires (x, x**3) pour x dans la plage de nombres allant de 1 à 5.
        for x in range(1, 6) : Cette partie du code met en place la boucle, itérant sur les nombres de 1 à 5 (inclus).
        (x, x**3) : Pour chaque valeur de x, elle crée un tuple contenant la valeur de x et son cube, x**3.
    print(num_cubes) : Cette ligne de code affiche la valeur de num_cubes sur la console.
        \end{solution}
        

        \question
        Créer un ensemble de personnages uniques à partir d'une liste de mots

Exemple de sortie

['apple', 'banana', 'cherry']

\{'y', 'a', 'e', 'c', 'b', 'p', 'l', 'n', 'h', 'r' \}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q634.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un nouvel ensemble nommé unique_chars, qui contient des caractères uniques extraits d'une liste de mots. Voici comment fonctionne ce code :

    words = ["apple", "banana", "cherry"] : Cette ligne initialise une liste nommée words avec trois éléments de type chaîne de caractères.
    unique_chars = {char for word in words for char in word} : Cette ligne initialise l'ensemble unique_chars à l'aide d'une compréhension de l'ensemble.
        pour mot dans mots : Cette partie du code met en place une boucle imbriquée qui parcourt chaque mot de la liste des mots.
        for char in word : Pour chaque mot, cette partie parcourt chaque caractère du mot et ajoute chaque caractère unique à l'ensemble unique_chars.
    print(words) : Cette ligne de code imprime la liste originale de mots, words, sur la console.
    print(unique_chars) : Cette ligne de code affiche sur la console le jeu de caractères unique_chars, qui contient les caractères uniques des mots.
        \end{solution}
        

        \question
        Générer un ensemble de tuples contenant des nombres et leurs valeurs absolues

Exemple de sortie

[-2, 3, -5, 7, -11]

\{(7, 7), (-11, 11), (3, 3), (-5, 5), (-2, 2)\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q635.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un nouvel ensemble nommé valeurs_absolues, qui contient des paires de nombres et leurs valeurs absolues à partir d'une liste de nombres. Voici comment fonctionne ce code :

    nombres = [-2, 3, -5, 7, -11] : Cette ligne initialise une liste nommée numbers avec cinq éléments entiers.
    valeurs_absolues = {(x, abs(x)) for x in numbers} : Cette ligne initialise l'ensemble valeurs_absolues à l'aide d'une compréhension d'ensemble.
        for x in numbers : Cette partie du code met en place une boucle qui parcourt chaque nombre de la liste des nombres.
        (x, abs(x)) : Pour chaque nombre, cette partie crée un tuple contenant le nombre lui-même (x) et sa valeur absolue (abs(x)).
    print(nombres) : Cette ligne de code imprime la liste originale de nombres, numbers, sur la console.
    print(valeurs_absolues) : Cette ligne de code affiche sur la console le jeu de valeurs absolues, qui contient les paires de nombres et leurs valeurs absolues.
        \end{solution}
        

        \question
        Créer une série de mots dont les caractères sont répétés deux fois.

Exemple de sortie

['apple', 'banana', 'cherry']

\{'aappppllee', 'bbaannaannaa', 'cchheerrrryy'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q636.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un nouvel ensemble nommé duplicated_chars, qui contient des mots avec des caractères dupliqués à partir d'une liste de mots. Voici comment fonctionne ce code :

    mots = ["pomme", "banane", "cerise"] : Cette ligne initialise une liste nommée words avec trois éléments de type chaîne de caractères.
    duplicated_chars = {''.join([char*2 for char in word]) for word in words} : Cette ligne initialise l'ensemble duplicated_chars à l'aide d'une compréhension d'ensemble.
        for word in words : Cette partie du code met en place une boucle qui parcourt chaque mot de la liste des mots.
        for char in word : Pour chaque mot, cette partie parcourt chaque caractère du mot et le double en utilisant char*2.
        ''.join(...) : Cette partie du code combine les caractères doublés en une seule chaîne pour chaque mot.
    print(words) : Cette ligne de code imprime la liste originale de mots, words, sur la console.
    print(duplicated_chars) : Cette ligne de code imprime sur la console l'ensemble duplicated_chars, qui contient les mots dont les caractères sont dupliqués.
        \end{solution}
        

        \question
        Générer un ensemble de tuples contenant des nombres et leurs carrés, mais seulement pour les nombres pairs

Exemple de sortie

[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

\{(2, 4), (4, 16), (8, 64), (10, 100), (6, 36)\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q637.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un nouvel ensemble nommé even_num_squares, qui contient des tuples de nombres pairs et leurs carrés à partir d'une liste de nombres. Voici comment fonctionne ce code :

    nombres = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] : Cette ligne initialise une liste nommée nombres avec dix éléments entiers.
    even_num_squares = {(x, x**2) for x in numbers if x % 2 == 0} : Cette ligne initialise l'ensemble even_num_squares à l'aide d'une compréhension d'ensemble.
        for x in numbers : Cette partie du code met en place une boucle qui parcourt chaque nombre de la liste des nombres.
        if x % 2 == 0 : Cette partie du code filtre les nombres pour n'inclure que les nombres pairs (divisibles par 2).
        (x, x**2) : Pour chaque nombre pair, cette partie crée un tuple contenant le nombre original et son carré.
    print(nombres) : Cette ligne de code imprime la liste originale des nombres, numbers, sur la console.
    print(even_num_squares) : Cette ligne de code affiche sur la console l'ensemble even_num_squares, qui contient des tuples de nombres pairs et leurs carrés.
        \end{solution}
        

        \question
        Créer un ensemble de nombres qui sont des cubes parfaits de 1 à 100

Exemple de résultat

\{8, 1, 27\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q638.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un nouvel ensemble nommé perfect_cubes, qui contient des nombres cubiques parfaits compris entre 1 et 100. Voici comment fonctionne le code :

    perfect_cubes = {x for x in range(1, 101) if int(x**(1/3))**3 == x} : Cette ligne initialise l'ensemble perfect_cubes à l'aide d'une compréhension de l'ensemble.
        for x in range(1, 101) : Cette partie du code met en place une boucle qui parcourt chaque nombre compris entre 1 et 100 (inclus).
        if int(x**(1/3))**3 == x : Cette partie du code filtre les nombres pour n'inclure que ceux qui sont des cubes parfaits. Elle vérifie si la racine cubique de x, convertie en entier et élevée à la puissance 3, est égale à x. Si c'est le cas, cela signifie que x est un cube parfait.
    print(perfect_cubes) : Cette ligne de code affiche sur la console l'ensemble perfect_cubes, qui contient les nombres de cubes parfaits.
        \end{solution}
        

        \question
        Créer un ensemble de caractères sans espace à partir d'une chaîne de caractères

Exemple de sortie

Bonjour à tous !

\{'e', 'r', 'H', 'd', 'w', ',', 'l', '!', 'o'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q639.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un nouvel ensemble nommé non_whitespace_chars, qui contient les caractères sans espace de la chaîne "Hello, world !". Voici comment fonctionne ce code :

    non_whitespace_chars = {char for char in string if not char.isspace()} : Cette ligne initialise l'ensemble non_whitespace_chars à l'aide d'une compréhension de l'ensemble.
        for char in string : Cette partie du code parcourt chaque caractère de la chaîne "Hello, world !".
        if not char.isspace() : Cette partie du code filtre les caractères pour n'inclure que ceux qui ne sont pas des caractères d'espacement. Elle vérifie si le caractère char n'est pas un caractère d'espacement à l'aide de la méthode isspace().
    print(string) : Cette ligne de code imprime la chaîne originale, "Hello, world !", sur la console.
    print(non_whitespace_chars) : Cette ligne de code affiche sur la console le jeu de caractères non_whitespace_chars, qui contient les caractères non blancs de la chaîne.
        \end{solution}
        

        \question
        Créer un ensemble de nombres pairs de 1 à 50 qui ne sont pas divisibles par 4

Exemple de résultat

\{2, 34, 6, 38, 10, 42, 14, 46, 18, 50, 22, 26, 30\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{pascorrige.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            
        \end{solution}
        

        \question
        Générer un ensemble d'éléments communs à partir de plusieurs ensembles

Exemple de sortie

\{1, 2, 3, 4, 5\}

\{3, 4, 5, 6, 7\}

\{5, 6, 7, 8, 9\}

\{5\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q640.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Dans ce code Python, vous disposez de trois ensembles : set1, set2 et set3, et vous recherchez les éléments communs présents dans les trois ensembles. Voici comment fonctionne le code :

    set1 = {1, 2, 3, 4, 5} : Cette ligne définit l'ensemble 1 comme un ensemble contenant les éléments 1, 2, 3, 4 et 5.
    set2 = {3, 4, 5, 6, 7} : Cette ligne définit l'ensemble 2 comme un ensemble contenant les éléments 3, 4, 5, 6 et 7.
    set3 = {5, 6, 7, 8, 9} : Cette ligne définit l'ensemble 3 comme un ensemble contenant les éléments 5, 6, 7, 8 et 9.
    common_elements = {x for x in set1 if x in set2 and x in set3} : Cette ligne crée un ensemble nommé common_elements à l'aide d'une compréhension d'ensemble. Elle parcourt les éléments de l'ensemble 1 et inclut un élément dans l'ensemble common_elements s'il est également présent dans les ensembles 2 et 3. En d'autres termes, il trouve les éléments qui sont communs aux trois ensembles.
    print(set1) : Cette ligne affiche l'ensemble set1 sur la console.
    print(set2) : Cette ligne affiche l'ensemble set2 sur la console.
    print(set3) : Cette ligne affiche l'ensemble set3 sur la console.
    print(common_elements) : Cette ligne affiche le jeu d'éléments communs sur la console.
        \end{solution}
        

        \question
        Créez un ensemble de chaînes de caractères dont les voyelles ont été supprimées.

Exemple de résultat

\{'banane', 'cerise', 'pomme'\}

\{'chrry', 'ppl', 'bnn'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q641.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Vous voulez créer un nouvel ensemble appelé no_vowels qui contient les mêmes mots que strings, mais en supprimant les voyelles de chaque mot. Voici comment fonctionne le code :

    strings = {"apple", "banana", "cherry"} : Cette ligne définit un ensemble nommé strings contenant trois mots : "pomme", "banane" et "cerise".
    no_vowels = {''.join([char for char in word if char.lower() not in 'aeiou']) for word in strings} : Cette ligne utilise une compréhension d'ensemble pour créer l'ensemble no_vowels. Elle parcourt chaque mot de l'ensemble strings et, pour chaque mot, traite les caractères qu'il contient. Il vérifie si chaque caractère (converti en minuscule) n'est pas une voyelle ('a', 'e', 'i', 'o', 'u'). Si le caractère n'est pas une voyelle, il l'inclut dans le mot traité. La partie ''.join(...) est utilisée pour concaténer les caractères en un seul mot. Ainsi, pour chaque mot de strings, ce code crée un nouveau mot sans voyelles et l'ajoute à l'ensemble no_vowels.
    print(strings) : Cette ligne affiche sur la console le jeu de chaînes original, qui contient les mots avec voyelles.
    print(no_vowels) : Cette ligne affiche sur la console le jeu no_vowels, qui contient les mots modifiés dont les voyelles ont été supprimées.
        \end{solution}
        

        \question
        Générer un ensemble de mots commençant par une voyelle à partir d'une phrase

Exemple de résultat

Voici un exemple de phrase contenant des mots commençant par des voyelles.

\{'a', 'is'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q642.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Dans ce code Python, vous avez une phrase et vous voulez créer un ensemble appelé vowel_start_words qui contient les mots de la phrase qui commencent par une voyelle (en majuscules ou en minuscules). Voici comment fonctionne le code :

    sentence = "Voici un exemple de phrase avec des mots commençant par des voyelles" : Cette ligne définit une chaîne appelée phrase contenant la phrase d'entrée.
    vowel_start_words = {word for word in sentence.split() if word[0].lower() in 'aeiou'} : Cette ligne utilise une compréhension d'ensemble pour créer un ensemble appelé mots_voyelles_début. Voici comment cela fonctionne :
        sentence.split() divise la phrase en une liste de mots.
        for word in sentence.split() parcourt chaque mot de la liste.
        if word[0].lower() in 'aeiou' vérifie si la minuscule du premier caractère du mot est une voyelle. Si c'est le cas, le mot est inclus dans l'ensemble.
    print(phrase) : Cette ligne affiche la phrase originale sur la console.
    print(mots_voyelles_début) : Cette ligne affiche sur la console l'ensemble mots_début_voyelles, qui contient les mots de la phrase commençant par des voyelles.
        \end{solution}
        

        \question
        Créer un ensemble de voyelles uniques à partir d'une liste de mots

Exemple de résultat

['apple', 'banana', 'cherry']

\{'a', 'e'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q643.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python traite une liste de mots pour en extraire les voyelles uniques. Voici ce que fait chaque partie du code :

    words = ["apple", "banana", "cherry"] : Cette ligne définit une liste appelée words, qui contient trois mots : "pomme", "banane" et "cerise".
    unique_vowels = {char for word in words for char in word if char.lower() in 'aeiou'} : Cette ligne utilise la compréhension d'un ensemble pour créer un ensemble appelé unique_voyelles. Voici comment cela fonctionne :
        for word in words parcourt chaque mot de la liste des mots.
        for char in word parcourt chaque caractère du mot.
        if char.lower() in 'aeiou' vérifie si la minuscule du caractère est une voyelle ('a', 'e', 'i', 'o', ou 'u'). Si c'est le cas, le caractère est inclus dans l'ensemble. La compréhension de l'ensemble permet de s'assurer que seuls les caractères voyelles uniques sont inclus.
    print(words) : Cette ligne imprime la liste originale des mots sur la console.
    print(unique_vowels) : Cette ligne affiche l'ensemble unique_voyelles, qui contient les voyelles uniques extraites des mots de la liste.
        \end{solution}
        

        \question
        Créer un ensemble de nombres palindromes de 1 à 100

Exemple de résultat

\{1, 2, 3, 4, 5, 6, 7, 8, 9, 33, 11, 44, 66, 77, 99, 22, 55, 88\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q644.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un ensemble nommé palindromes, qui contient des nombres palindromiques compris entre 1 et 100. Voici comment fonctionne le code :

    palindromes = {x for x in range(1, 101) if str(x) == str(x)[::-1]} : Cette ligne initialise l'ensemble palindromes à l'aide d'une compréhension de l'ensemble.
        for x in range(1, 101) : Cette partie du code parcourt les nombres de 1 à 100 (inclus).
        if str(x) == str(x)[::-1] : Cette partie du code vérifie si un nombre est un palindrome. Pour ce faire, elle convertit le nombre x en chaîne de caractères à l'aide de str(x). Ensuite, elle vérifie si la représentation en chaîne du nombre est égale à son inverse, obtenu en découpant str(x)[::-1].
    print(palindromes) : Cette ligne de code imprime le jeu de palindromes sur la console, qui contient les nombres palindromiques compris dans l'intervalle spécifié.
        \end{solution}
        

        \question
        Générer un ensemble de mots qui sont des anagrammes à partir d'une liste de mots

Exemple de sortie

['apple', 'banana', 'elppa', 'race', 'care', 'cherry']

\{'aaabnn', 'cehrry', 'aelpp', 'acer'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q645.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un ensemble nommé anagrammes, qui contient les lettres triées de chaque mot de la liste words. Voici comment fonctionne le code :

    anagrammes = {''.join(sorted(word)) for word in words} : Cette ligne initialise l'ensemble d'anagrammes en utilisant une compréhension de l'ensemble.
        for word in words : Cette partie du code parcourt chaque mot de la liste words.
        ''.join(sorted(word)) : Pour chaque mot, le code trie les lettres par ordre alphabétique à l'aide de la fonction sorted, puis les réunit en une seule chaîne. Cela permet de créer un anagramme du mot.
    print(words) : Cette ligne de code imprime la liste originale des mots, qui est ["apple", "banana", "elppa", "race", "care", "cherry"], sur la console.
    print(anagrammes) : Cette ligne de code imprime le jeu d'anagrammes, qui contient les lettres triées de chaque mot, sur la console.
        \end{solution}
        

        \question
        Créer un ensemble de mots avec leurs caractères triés par ordre décroissant

Exemple de résultat

['apple', 'banana', 'cherry']

\{'pplea', 'yrrhec', 'nnbaaa'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q646.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un ensemble appelé sorted_descending, qui contient les lettres de chaque mot de la liste words triées par ordre décroissant (dans l'ordre alphabétique inverse). Voici comment fonctionne ce code :

    sorted_descending = {''.join(sorted(word, reverse=True)) for word in words} : Cette ligne initialise l'ensemble sorted_descending à l'aide d'une compréhension de l'ensemble.
        for word in words : Cette partie du code parcourt chaque mot de la liste words.
        ''.join(sorted(word, reverse=True)) : Pour chaque mot, le code trie les lettres dans l'ordre alphabétique inverse (ordre décroissant) en utilisant la fonction sorted avec l'argument reverse=True, puis les joint en une seule chaîne.
    print(words) : Cette ligne de code imprime la liste originale des mots, qui est ["apple", "banana", "cherry"], sur la console.
    print(sorted_descending) : Cette ligne de code imprime sur la console l'ensemble sorted_descending, qui contient les lettres de chaque mot trié par ordre décroissant.
        \end{solution}
        

        \question
        enerate un ensemble de caractères qui apparaissent exactement deux fois dans une chaîne de caractères

Exemple de sortie

Bonjour à tous !

\{'o'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q647.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un ensemble nommé twice_chars, qui contient les caractères qui apparaissent exactement deux fois dans la chaîne de caractères. Voici comment fonctionne ce code :

    twice_chars = {char for char in string if string.count(char) == 2} : Cette ligne initialise l'ensemble twice_chars à l'aide d'une compréhension de l'ensemble.
        for char in string : Cette partie du code parcourt chaque caractère de la chaîne de caractères.
        if string.count(char) == 2 : cette ligne vérifie si le nombre de caractères dans la chaîne est égal à 2, ce qui signifie que le caractère apparaît exactement deux fois dans la chaîne.
    print(string) : Cette ligne de code imprime la chaîne originale, qui est "Hello, world !", sur la console.
    print(twice_chars) : Cette ligne de code imprime sur la console l'ensemble twice_chars, qui contient les caractères qui apparaissent exactement deux fois dans la chaîne.
        \end{solution}
        

        \question
        Créer un ensemble de chaînes de caractères avec tous les caractères en majuscules à partir d'une liste de chaînes de caractères.

Exemple de sortie

['apple', 'banana', 'cherry']

\{'Banane', 'Pomme', 'Cerise' \}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q648.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un ensemble nommé chaînes_capitalisées, qui contient des chaînes dont chaque mot est en majuscule. Voici comment fonctionne ce code :

    chaînes_capitalisées = {' '.join([word.capitalize() for word in string.split()]) for string in strings} : Cette ligne initialise l'ensemble chaînes_capitalisées à l'aide d'une compréhension de l'ensemble.
        for string in strings : Cette partie du code parcourt chaque chaîne de la liste des chaînes.
        string.split() : Elle divise la chaîne actuelle en une liste de mots, en les séparant par des espaces.
        [word.capitalize() for word in string.split()] : Il parcourt les mots de la liste et met la première lettre de chaque mot en majuscule.
        ' '.join([word.capitalize() for word in string.split()]) : Il réunit les mots en majuscules en une seule chaîne de caractères, en les séparant par des espaces.
    print(strings) : Cette ligne de code imprime la liste originale des chaînes de caractères, qui est ["apple", "banana", "cherry"], sur la console.
    print(chaînes_capitalisées) : Cette ligne de code imprime sur la console le jeu de chaînes capitalisées, qui contient les chaînes dont les mots sont en majuscules.
        \end{solution}
        

        \question
        Générer un ensemble de mots comportant au moins une voyelle à partir d'une liste de mots

Exemple de résultat

['apple', 'banana', 'cherry']

\{'banane', 'pomme', 'cerise' \}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q649.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un ensemble nommé mots_voyelles, qui contient des mots de la liste des mots contenant au moins une voyelle (a, e, i, o ou u). Voici comment fonctionne ce code :

    mots_voyelles = {mot pour mot dans mots si any(char.lower() in 'aeiou' pour char dans mot)} : Cette ligne initialise l'ensemble mots_voyelles à l'aide d'une compréhension de l'ensemble.
        for word in words : Cette partie du code parcourt chaque mot de la liste des mots.
        if any(char.lower() in 'aeiou' for char in word) : Cette partie du code vérifie si au moins un caractère du mot actuel est une voyelle minuscule (a, e, i, o ou u).
    print(words) : Cette ligne de code imprime la liste originale des mots, qui est ["apple", "banana", "cherry"], sur la console.
    print(mots_voyelles) : Cette ligne de code imprime sur la console l'ensemble mots_voyelles, qui contient les mots comportant au moins une voyelle.
        \end{solution}
        

        \question
        Créer une série de mots dont les caractères sont répétés trois fois à partir d'une liste de mots.

Exemple de résultat

['apple', 'banana', 'cherry']

\{'bbbaaannnaaannnaaa', 'aaappppppllleee', 'ccchhheeerrrrrryyy'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q650.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise la compréhension d'un ensemble pour créer un ensemble nommé tripled_chars, qui contient des mots de la liste des mots dont chaque caractère est répété trois fois. Voici comment fonctionne ce code :

    tripled_chars = {''.join([char*3 for char in word]) for word in words} : Cette ligne initialise l'ensemble tripled_chars à l'aide d'une compréhension d'ensemble.
        for word in words : Cette partie du code parcourt chaque mot de la liste des mots.
        ''.join([char*3 for char in word]) : Cette partie du code répète trois fois chaque caractère du mot actuel et les joint à l'aide d'une chaîne vide. Cela crée un mot avec des caractères triplés.
    print(words) : Cette ligne de code imprime la liste originale de mots, qui est ["pomme", "banane", "cerise"], sur la console.
    print(tripled_chars) : Cette ligne de code imprime sur la console l'ensemble tripled_chars, qui contient des mots dont chaque caractère est répété trois fois.
        \end{solution}
        

        \question
        Créer un ensemble de mots dont les caractères sont triés et concaténés

Exemple de sortie

['apple', 'banana', 'cherry']

\{'aelpp', 'cehrry', 'aaabnn'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q651.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour créer un ensemble nommé sorted_concatenated, qui contient des mots de la liste de mots triés et concaténés. Voici comment fonctionne le code :

    sorted_concatenated = {''.join(sorted(word)) for word in words} : Cette ligne initialise l'ensemble sorted_concatenated à l'aide d'une compréhension d'ensemble.
        for word in words : Cette partie du code parcourt chaque mot de la liste des mots.
        ''.join(sorted(word)) : Cette partie du code trie les caractères du mot actuel par ordre alphabétique, puis les joint en utilisant une chaîne vide. Cela crée un mot dans lequel les caractères sont triés.
    print(mots) : Cette ligne de code imprime la liste originale de mots, qui est ["apple", "banana", "cherry"], sur la console.
    print(sorted_concatenated) : Cette ligne de code imprime sur la console l'ensemble sorted_concatenated, qui contient des mots dont les caractères sont triés par ordre alphabétique.
        \end{solution}
        

        \question
        Créer une série de mots avec leurs caractères mélangés à partir d'une liste de mots.

Exemple de sortie

['apple', 'banana', 'cherry']

\{'hreyrc', 'nbaana', 'lepap'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q652.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python mélange les caractères de chaque mot de la liste des mots à l'aide d'un échantillonnage aléatoire et crée un ensemble nommé shuffled_chars pour stocker les versions mélangées des mots. Voici comment fonctionne le code :

    import random : Cette ligne importe le module random, qui fournit des fonctions permettant de générer des nombres aléatoires et d'effectuer des opérations aléatoires.
    words = ["apple", "banana", "cherry"] : Cette ligne initialise une variable nommée words et lui attribue une liste de trois mots.
    shuffled_chars = {''.join(random.sample(word, len(word))) for word in words} : Cette ligne initialise un ensemble nommé shuffled_chars à l'aide d'une compréhension d'ensemble.
        for word in words : Cette partie du code parcourt chaque mot de la liste des mots.
        random.sample(word, len(word)) : Pour chaque mot, il utilise la fonction random.sample pour mélanger ses caractères. random.sample renvoie un échantillon aléatoire de la séquence d'entrée (dans ce cas, les caractères du mot) de la longueur spécifiée.
        ''.join(...) : Cette partie du code réunit les caractères mélangés en une seule chaîne.
    print(words) : Cette ligne de code imprime la liste originale des mots sur la console.
    print(shuffled_chars) : Cette ligne de code imprime le jeu de caractères mélangés (qui contient les versions mélangées des mots) sur la console.
        \end{solution}
        

        \question
        Filtrer les nombres négatifs d'un ensemble

Exemple de sortie

\{1, 3, 5, -4, -2\}

\{1, 3, 5\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q653.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python utilise une compréhension d'ensemble pour filtrer les nombres positifs d'un ensemble donné et crée un nouvel ensemble nommé nombres_positifs. Voici comment fonctionne le code :

    import random : Cette ligne importe le module random, bien qu'il ne soit pas utilisé dans le code.
    nombres = {1, -2, 3, -4, 5} : Cette ligne initialise un ensemble nommé numbers avec une collection d'entiers, comprenant à la fois des nombres positifs et négatifs.
    nombres_positifs = {x for x in numbers if x >= 0} : Cette ligne crée un nouvel ensemble nommé nombres_positifs à l'aide d'une compréhension d'ensemble.
        pour x dans nombres : Cette partie du code parcourt chaque élément de l'ensemble de nombres.
        if x >= 0 : elle vérifie si chaque élément est supérieur ou égal à zéro, ce qui permet de filtrer les nombres positifs et zéro de l'ensemble de nombres.
    print(nombres) : Cette ligne affiche le jeu de nombres original sur la console.
    print(nombres_positifs) : Cette ligne affiche sur la console l'ensemble nombres_positifs (qui ne contient que les nombres positifs et zéro).
        \end{solution}
        

        \question
        Générer des paires d'éléments à partir de deux ensembles

Exemple de sortie

\{1, 2, 3\}

\{'b', 'c', 'a'\}

\{(2, 'b'), (3, 'a'), (3, 'b'), (1, 'b'), (1, 'a'), (2, 'c'), (3, 'c'), (1, 'c'), (2, 'a')\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q654.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée des paires d'éléments à partir de deux ensembles, set1 et set2, et stocke ces paires dans un nouvel ensemble appelé paires. Voici comment fonctionne ce code :

    set1 = {1, 2, 3} : Cette ligne initialise un ensemble nommé set1 contenant trois entiers.
    set2 = {"a", "b", "c"} : Cette ligne initialise un autre ensemble nommé set2 contenant trois chaînes de caractères.
    pairs = {(x, y) for x in set1 for y in set2} : Cette ligne utilise une compréhension de l'ensemble pour créer des paires d'éléments à partir de l'ensemble 1 et de l'ensemble 2.
        for x in set1 : Cette partie du code parcourt chaque élément de l'ensemble 1.
        for y in set2 : Pour chaque élément de l'ensemble 1, il parcourt chaque élément de l'ensemble 2, créant des paires (x, y) pour toutes les combinaisons.
    print(set1) : Cette ligne affiche l'ensemble 1 original sur la console.
    print(set2) : Cette ligne affiche l'ensemble 2 original sur la console.
    print(pairs) : Cette ligne affiche le jeu de paires (qui contient toutes les paires possibles d'éléments de set1 et `set2) sur la console.
        \end{solution}
        

        \question
        Vérification des mots palindromes

Exemple de sortie

['radar', 'hello', 'level', 'world']

\{'radar', 'level'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q655.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un ensemble nommé palindromes qui contient des mots palindromiques à partir d'une liste de mots donnée. Voici comment fonctionne le code :

    words = ["radar", "hello", "level", "world"] : Cette ligne initialise une liste nommée words avec quatre mots, dont certains sont palindromes et d'autres non.
    palindromes = {mot pour mot dans mots si mot == mot[::-1]} : Cette ligne utilise une compréhension d'ensemble pour créer l'ensemble palindromes, qui ne contient que les mots de la liste words qui sont des palindromes.
        for word in words : Cette partie du code parcourt chaque mot de la liste des mots.
        si mot == mot[::-1] : Elle vérifie si chaque mot est un palindrome. Pour ce faire, il vérifie si le mot est égal à son inverse (mot[::-1]).
    print(words) : Cette ligne affiche la liste originale des mots sur la console.
    print(palindromes) : Cette ligne imprime le jeu de palindromes (qui contient les mots palindromiques de la liste des mots) sur la console.
        \end{solution}
        

        \question
        Conversion d'une liste de dictionnaires en un ensemble

Exemple de sortie

[\{'a' : 1, 'b' : 2\}, \{'b' : 2, 'c' : 3\}, \{'c' : 3, 'd' : 4\}]

\{frozenset(\{('a', 1), ('b', 2)\}), frozenset(\{('d', 4), ('c', 3)\}), frozenset(\{('b', 2), ('c', 3)\})\}.
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q656.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un ensemble nommé dict_set en convertissant une liste de dictionnaires, list_of_dicts, en ensembles de paires clé-valeur. Voici comment fonctionne ce code :

    list_of_dicts = [{"a" : 1, "b" : 2}, {"b" : 2, "c" : 3}, {"c" : 3, "d" : 4}] : Cette ligne initialise une liste de dictionnaires nommée list_of_dicts. Chaque dictionnaire contient des paires clé-valeur.
    dict_set = {frozenset(d.items()) for d in list_of_dicts} : Cette ligne utilise une compréhension de l'ensemble pour créer l'ensemble dict_set. Pour chaque dictionnaire d dans list_of_dicts, elle convertit les paires clé-valeur en un frozenset en utilisant frozenset(d.items()).
        pour d dans list_of_dicts : Cette partie du code parcourt chaque dictionnaire de la liste_of_dicts.
        frozenset(d.items()) : Elle convertit les paires clé-valeur du dictionnaire en un frozenset. Un frozenset est utilisé parce qu'il s'agit d'un type immuable et qu'il peut être inclus dans un ensemble.
    print(list_of_dicts) : Cette ligne affiche la liste originale des dictionnaires sur la console.
    print(dict_set) : Cette ligne affiche sur la console l'ensemble dict_set (qui contient des frozensets de paires clé-valeur provenant des dictionnaires originaux).
        \end{solution}
        

        \question
        Suppression de la ponctuation d'une chaîne de caractères

Exemple de sortie

Bonjour à tous ! Comment ça va ?

\{'e', ' ', 'g', 'o', 'h', 'd', 'l', 's', 'r', 'y', 'w', 't', 'H', 'n', 'v', 'i' \}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q657.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python supprime les caractères de ponctuation d'un texte donné en utilisant un ensemble de compréhension. Voici comment fonctionne le code :

    import string : Cette ligne importe le module string, qui contient une constante string, string.punctuation, qui inclut tous les caractères de ponctuation.
    text = "Hello, world ! Comment ça va ?": Cette ligne initialise une chaîne de caractères nommée text avec un exemple de texte contenant de la ponctuation.
    cleaned_text = {char for char in text if char not in string.punctuation} : Cette ligne utilise une compréhension d'ensemble pour créer l'ensemble texte_nettoyé. Elle parcourt chaque caractère char du texte et l'inclut dans l'ensemble cleaned_text s'il ne s'agit pas d'un caractère de ponctuation.
        pour char dans texte : Cette partie du code parcourt chaque caractère de la chaîne de texte.
        if char not in string.punctuation : Cette partie du code vérifie si chaque caractère ne se trouve pas dans la chaîne string.punctuation, qui contient les caractères de ponctuation.
    print(text) : Cette ligne imprime le texte original sur la console.
    print(texte_nettoyé) : Cette ligne imprime le jeu de textes nettoyés, qui contient les caractères du texte original, à l'exception des caractères de ponctuation.
        \end{solution}
        

        \question
        Ensemble des mots ayant un préfixe donné

Exemple de sortie

['apple', 'banana', 'cherry', 'date']

ba

\{'banane'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q658.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un ensemble nommé words_with_prefix qui contient des mots d'une liste donnée de mots commençant par un préfixe spécifié. Voici comment fonctionne ce code :

    words = ["apple", "banana", "cherry", "date"] : Cette ligne initialise une liste nommée words avec quatre mots.
    prefix = "ba" : Cette ligne initialise une variable de type chaîne nommée préfixe avec le préfixe que vous souhaitez rechercher.
    words_with_prefix = {word for word in words if word.startswith(prefix)} : Cette ligne utilise une compréhension de l'ensemble pour créer l'ensemble words_with_prefix. Elle parcourt chaque mot de la liste des mots et l'inclut dans l'ensemble words_with_prefix s'il commence par le préfixe spécifié.
        pour mot dans mots : Cette partie du code parcourt chaque mot de la liste des mots.
        if word.startswith(prefix) : Cette partie du code vérifie si chaque mot commence par le préfixe spécifié.
    print(mots) : Cette ligne imprime la liste de mots originale sur la console.
    print(prefix) : Cette ligne affiche le préfixe spécifié sur la console.
    print(mots_avec_préfixe) : Cette ligne affiche l'ensemble words_with_prefix, qui contient les mots commençant par le préfixe spécifié.
        \end{solution}
        

        \question
        Fusionner les caractères d'une liste de chaînes

Exemple de sortie

['apple', 'banana', 'cherry']

\{'r', 'b', 'p', 'n', 'a', 'e', 'c', 'h', 'y', 'l' \}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q659.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un ensemble nommé merged_chars qui contient les caractères distincts d'une liste de chaînes de caractères. Voici comment fonctionne ce code :

    strings = ["apple", "banana", "cherry"] : Cette ligne initialise une liste nommée strings avec trois chaînes.
    merged_chars = {char for string in strings for char in string} : Cette ligne utilise une compréhension d'ensemble pour créer l'ensemble merged_chars. Elle parcourt chaque chaîne de la liste des chaînes et inclut chaque caractère dans l'ensemble merged_chars.
        for string in strings : Cette partie du code parcourt chaque chaîne de la liste des chaînes.
        for char in string : Elle parcourt chaque caractère de la chaîne en cours.
    print(strings) : Cette ligne imprime la liste originale des chaînes de caractères sur la console.
    print(merged_chars) : Cette ligne affiche le jeu de caractères fusionnés, qui contient tous les caractères distincts des chaînes originales.
        \end{solution}
        

        \question
        DEPARTDICT
Créer un dictionnaire de carrés de nombres de 1 à 10

Exemple de sortie

\{1 : 1, 2 : 4, 3 : 9, 4 : 16, 5 : 25, 6 : 36, 7 : 49, 8 : 64, 9 : 81, 10 : 100\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q660.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un dictionnaire nommé carrés où les clés sont des nombres de 1 à 10, et les valeurs sont les carrés de ces nombres. Voici comment fonctionne le code :

    squares = {x : x ** 2 for x in range(1, 11)} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire squares. Elle parcourt chaque nombre x dans l'intervalle de 1 à 10 et affecte une paire clé-valeur au dictionnaire. La clé est le nombre lui-même (x) et la valeur est le carré de ce nombre (x ** 2).
        for x in range(1, 11) : Cette partie du code parcourt chaque nombre de 1 à 10.
    print(squares) : Cette ligne imprime le dictionnaire des carrés sur la console.
        \end{solution}
        

        \question
        Créer un dictionnaire dont les clés sont les nombres pairs et les valeurs leurs carrés.

Exemple de résultat

\{0 : 0, 2 : 4, 4 : 16, 6 : 36, 8 : 64, 10 : 100, 12 : 144, 14 : 196, 16 : 256, 18 : 324, 20 : 400\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q661.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un dictionnaire nommé evens_squared dont les clés sont des nombres pairs compris entre 0 et 20, et dont les valeurs sont les carrés de ces nombres pairs. Voici comment fonctionne ce code :

    evens_squared = {x : x ** 2 for x in range(0, 21) if x % 2 == 0} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire evens_squared. Elle parcourt chaque nombre pair x dans l'intervalle de 0 à 20 et affecte une paire clé-valeur au dictionnaire. La clé est le nombre pair lui-même (x) et la valeur est le carré de ce nombre pair (x ** 2).
        for x in range(0, 21) : Cette partie du code parcourt chaque nombre de 0 à 20.
        if x % 2 == 0 : elle vérifie si le nombre est pair en utilisant l'opérateur modulo (%) pour voir s'il n'y a pas de reste lorsque l'on divise par 2.
    print(evens_squared) : Cette ligne affiche le dictionnaire evens_squared sur la console.
        \end{solution}
        

        \question
        Créer un dictionnaire de mots et de leur longueur à partir d'une phrase

Exemple de sortie

Enter String : Python is awesome (Python est génial)

\{'Python' : 6, 'is' : 2, 'awesome' : 7\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q662.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un dictionnaire nommé word_lengths dont les clés sont les mots d'une phrase et les valeurs sont les longueurs de ces mots. Voici comment fonctionne ce code :

    sentence = "Python is awesome" : Cette ligne initialise une variable de chaîne nommée phrase avec la phrase que vous souhaitez analyser.
    word_lengths = {word : len(word) for word in sentence.split()} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire word_lengths. Elle divise la phrase en mots à l'aide de .split() et parcourt chaque mot de la phrase. Pour chaque mot, elle assigne une paire clé-valeur au dictionnaire. La clé est le mot lui-même (word), et la valeur est la longueur de ce mot (len(word)).
        pour mot dans phrase.split() : Cette partie du code parcourt chaque mot de la phrase après l'avoir divisée en mots.
    print(sentence) : Cette ligne imprime la phrase originale sur la console.
    print(word_lengths) : Cette ligne affiche le dictionnaire word_lengths, qui contient les longueurs des mots de la phrase originale.
        \end{solution}
        

        \question
        Créer un dictionnaire de caractères minuscules à partir d'une chaîne de caractères

Exemple de sortie

Bonjour à tous

\{'H' : 'h', 'e' : 'e', 'l' : 'l', 'o' : 'o', 'W' : 'w', 'r' : 'r', 'd' : 'd'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q663.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un dictionnaire nommé lowercase_chars dont les clés sont les caractères alphabétiques d'un texte donné et les valeurs sont les versions minuscules correspondantes de ces caractères. Voici comment fonctionne ce code :

    text = "Hello World" : Cette ligne initialise une variable de chaîne nommée texte avec le texte que vous souhaitez analyser.
    lowercase_chars = {char : char.lower() for char in text if char.isalpha()} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire lowercase_chars. Elle parcourt chaque caractère char du texte et vérifie s'il s'agit d'un caractère alphabétique (en utilisant char.isalpha()). Pour chaque caractère alphabétique, il attribue une paire clé-valeur au dictionnaire. La clé est le caractère lui-même (char) et la valeur est la version minuscule de ce caractère (char.lower()).
        pour char dans text : Cette partie du code parcourt chaque caractère du texte.
        if char.isalpha() : Cette partie du code vérifie si le caractère est alphabétique.
    print(text) : Cette ligne imprime le texte original sur la console.
    print(lowercase_chars) : Cette ligne affiche le dictionnaire lowercase_chars, qui contient les versions minuscules des caractères alphabétiques du texte original.
        \end{solution}
        

        \question
        Créer un dictionnaire des nombres et de leurs cubes

Exemple de résultat

[1, 2, 3, 4, 5]

\{1 : 1, 2 : 8, 3 : 27, 4 : 64, 5 : 125\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q664.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un dictionnaire nommé cubes où les clés sont des nombres d'une liste, et les valeurs sont les cubes de ces nombres. Voici comment fonctionne le code :

    nombres = [1, 2, 3, 4, 5] : Cette ligne initialise une liste nommée numbers avec une séquence de nombres que vous souhaitez analyser.
    cubes = {x : x ** 3 for x in numbers} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire cubes. Elle parcourt chaque nombre x dans la liste des nombres et affecte une paire clé-valeur au dictionnaire. La clé est le nombre lui-même (x) et la valeur est le cube de ce nombre (x ** 3).
        pour x dans nombres : Cette partie du code parcourt chaque nombre de la liste des nombres.
    print(numbers) : Cette ligne imprime la liste originale des nombres sur la console.
    print(cubes) : Cette ligne imprime le dictionnaire cubes, qui contient les cubes des nombres de la liste originale.
        \end{solution}
        

        \question
        Créer un dictionnaire des nombres et de leurs carrés, à l'exclusion des nombres impairs

Exemple de résultat

[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

\{2 : 4, 4 : 16, 6 : 36, 8 : 64, 10 : 100\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q665.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un dictionnaire nommé even_squares dont les clés sont les nombres pairs d'une liste et les valeurs sont les carrés de ces nombres pairs. Voici comment fonctionne ce code :

    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] : Cette ligne initialise une liste nommée numbers avec une séquence de nombres que vous souhaitez analyser.
    even_squares = {x : x ** 2 for x in numbers if x % 2 == 0} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire even_squares. Elle parcourt chaque nombre x dans la liste des nombres et vérifie si le nombre est pair (en utilisant x % 2 == 0). Pour chaque nombre pair, il attribue une paire clé-valeur au dictionnaire. La clé est le nombre pair lui-même (x) et la valeur est le carré de ce nombre (x ** 2).
        pour x dans nombres : Cette partie du code parcourt chaque nombre de la liste des nombres.
        if x % 2 == 0 : Cette partie du code vérifie si le nombre est pair (c'est-à-dire si son reste après division par 2 est égal à 0).
    print(even_squares) : Cette ligne affiche le dictionnaire even_squares, qui contient les carrés des nombres pairs de la liste originale.
        \end{solution}
        

        \question
        Créer un dictionnaire des nombres et de leur statut premier

Exemple de résultat

[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

\{1 : Faux, 2 : Vrai, 3 : Vrai, 4 : Faux, 5 : Vrai, 6 : Faux, 7 : Vrai, 8 : Faux, 9 : Faux, 10 : Faux\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q666.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python définit une fonction is_prime(n) qui vérifie si un nombre donné n est premier. Il utilise ensuite une compréhension de dictionnaire pour créer un dictionnaire nommé prime_status où les clés sont des nombres d'une liste et les valeurs sont des valeurs booléennes indiquant si chaque nombre est premier ou non. Voici comment fonctionne le code :

    def is_prime(n) : Ceci définit une fonction is_prime qui prend un seul argument n et vérifie s'il s'agit d'un nombre premier. La fonction renvoie True si n est premier et False dans le cas contraire. Elle utilise un algorithme standard de vérification de la primalité, testant les diviseurs jusqu'à la racine carrée de n.
    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] : Cette ligne initialise une liste nommée numbers avec une séquence de nombres que vous souhaitez analyser.
    prime_status = {x : is_prime(x) for x in numbers} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire prime_status. Elle parcourt chaque nombre x dans la liste des nombres et affecte une paire clé-valeur au dictionnaire. La clé est le nombre lui-même (x) et la valeur est le résultat de l'appel à la fonction is_prime sur ce nombre, qui détermine s'il est premier ou non.
        pour x dans nombres : Cette partie du code parcourt chaque nombre de la liste des nombres.
        {x : is_prime(x) for x in numbers} : Elle utilise la compréhension d'un dictionnaire pour créer des paires clé-valeur où la clé est le nombre x et la valeur est le résultat de la fonction is_prime pour ce nombre.
    print(nombres) : Cette ligne imprime la liste originale des nombres sur la console.
    print(prime_status) : Cette ligne affiche le dictionnaire prime_status, qui contient le statut premier (Vrai ou Faux) de chaque nombre de la liste originale.
        \end{solution}
        

        \question
        Créer un dictionnaire de caractères et de leurs valeurs ASCII à partir d'une chaîne de caractères

Exemple de sortie

Tuteur Joes

\{'T' : 84, 'u' : 117, 't' : 116, 'o' : 111, 'r' : 114, ' ' : 32, 'J' : 74, 'e' : 101, 's' : 115\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q667.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une chaîne de texte et crée un dictionnaire ascii_values où les clés sont des caractères de la chaîne, et les valeurs sont les valeurs ASCII correspondantes. Voici comment fonctionne ce code :

    text = "Tutor Joes" : Cette ligne initialise une variable texte avec la valeur "Tutor Joes".
    ascii_values = {char : ord(char) for char in text} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire ascii_values. Elle parcourt chaque caractère char de la chaîne de texte et affecte une paire clé-valeur au dictionnaire. La clé est le caractère lui-même (char) et la valeur est la valeur ASCII de ce caractère, obtenue à l'aide de la fonction ord(char).
        pour char dans text : Cette partie du code parcourt chaque caractère de la chaîne de texte.
        {char : ord(char) for char in text} : Elle utilise la compréhension d'un dictionnaire pour créer des paires clé-valeur où la clé est le caractère char et la valeur est sa valeur ASCII correspondante.
    print(text) : Cette ligne imprime la chaîne de texte originale sur la console.
    print(ascii_values) : Cette ligne affiche le dictionnaire ascii_values, qui contient les caractères de la chaîne originale comme clés et leurs valeurs ASCII comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire de mots et de leurs voyelles à partir d'une liste de chaînes de caractères.

Exemple de résultat

['apple', 'banana', 'cherry']

\{'apple' : 2, 'banana' : 3, 'cherry' : 1\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q668.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de mots et crée un dictionnaire vowel_counts dont les clés sont les mots et les valeurs sont les nombres de voyelles (a, e, i, o, u) dans chaque mot. Voici comment fonctionne le code :

    words = ['apple', 'banana', 'cherry'] : Cette ligne initialise une liste nommée words avec trois mots.
    vowel_counts = {word : sum(1 for char in word if char.lower() in 'aeiou') for word in words} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire vowel_counts. Elle parcourt chaque mot de la liste des mots et assigne une paire clé-valeur au dictionnaire. La clé est le mot lui-même (word), et la valeur est le résultat de l'expression suivante :
        sum(1 for char in word if char.lower() in 'aeiou') : Cette partie du code compte le nombre de voyelles dans chaque mot en parcourant chaque caractère char dans le mot. Si char est une voyelle (quelle que soit la casse), il ajoute 1 au compte. La fonction sum calcule le nombre total de voyelles dans le mot.
        pour mot dans mots : Cette partie du code parcourt chaque mot de la liste des mots.
    print(words) : Cette ligne imprime la liste de mots originale sur la console.
    print(vowel_counts) : Cette ligne imprime le dictionnaire vowel_counts, qui contient les mots comme clés et le nombre de voyelles dans chaque mot comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire de mots avec les lettres triées

Exemple de résultat

['python', 'programmation', 'langage']

\{'python' : 'hnopty', 'programming' : 'aggimmnoprr', 'language' : 'aaegglnu'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q669.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de mots et crée un dictionnaire sorted_letters où les clés sont des mots, et les valeurs sont les mots avec leurs lettres triées dans l'ordre alphabétique. Voici comment fonctionne ce code :

    mots = ['python', 'programmation', 'langage'] : Cette ligne initialise une liste nommée words avec trois mots.
    sorted_letters = {word : ''.join(sorted(word)) for word in words} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire sorted_letters. Elle parcourt chaque mot de la liste des mots et affecte une paire clé-valeur au dictionnaire. La clé est le mot lui-même (word), et la valeur est le résultat de l'expression suivante :
        ''.join(sorted(word)) : Cette partie du code trie les lettres de chaque mot par ordre alphabétique et les réunit en une chaîne. La fonction sorted est utilisée pour trier les caractères du mot, et join combine les caractères triés en une seule chaîne.
        pour mot dans mots : Cette partie du code parcourt chaque mot de la liste des mots.
    print(words) : Cette ligne imprime la liste de mots originale sur la console.
    print(lettres_triées) : Cette ligne affiche le dictionnaire sorted_letters, qui contient les mots comme clés et les mots avec leurs lettres triées par ordre alphabétique comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire des mots et de leur longueur, mais seulement pour les mots de plus de 5 lettres.

Exemple de résultat

['apple', 'banana', 'cherry', 'date']

\{'banane' : 6, 'cerise' : 6\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q670.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de mots et crée un dictionnaire long_word_lengths où les clés sont les mots dont la longueur est supérieure à 5 caractères, et les valeurs sont les longueurs de ces mots. Voici comment fonctionne ce code :

    words = ['apple', 'banana', 'cherry', 'date'] : Cette ligne initialise une liste nommée words avec quatre mots.
    long_word_lengths = {word : len(word) for word in words if len(word) > 5} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire long_word_lengths. Elle parcourt chaque mot de la liste des mots et affecte une paire clé-valeur au dictionnaire uniquement si la longueur du mot est supérieure à 5 caractères. La clé est le mot lui-même (word) et la valeur est la longueur du mot (calculée à l'aide de len(word)).
        pour mot dans mots : Cette partie du code parcourt chaque mot de la liste des mots.
        if len(word) > 5 : Cette partie du code vérifie si la longueur du mot courant est supérieure à 5.
    print(words) : Cette ligne imprime la liste de mots originale sur la console.
    print(long_word_lengths) : Cette ligne affiche le dictionnaire long_word_lengths, qui contient les mots dont la longueur est supérieure à 5 comme clés et leurs longueurs respectives comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire des caractères et de leur fréquence dans une chaîne de caractères

Exemple de sortie

bonjour le monde

\{'l' : 3, ' ' : 1, 'r' : 1, 'h' : 1, 'd' : 1, 'o' : 2, 'e' : 1, 'w' : 1\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q671.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une chaîne de texte et crée un dictionnaire char_frequency où les clés sont des caractères uniques dans la chaîne, et les valeurs sont les fréquences de ces caractères dans la chaîne. Voici comment fonctionne le code :

    text = "hello world" : Cette ligne initialise la chaîne de caractères text avec le texte "hello world".
    char_frequency = {char : text.count(char) for char in set(text)} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire char_frequency. Elle effectue les opérations suivantes :
        set(text) : Cette partie du code crée un ensemble de caractères uniques dans la chaîne de texte. L'utilisation d'un ensemble permet de s'assurer que chaque caractère n'est inclus qu'une seule fois, ce qui élimine les doublons.
        {char : text.count(char) for char in set(text)} : Cette partie du code parcourt chaque caractère unique char dans le jeu de caractères uniques et attribue une paire clé-valeur au dictionnaire. La clé est le caractère lui-même (char) et la valeur est le résultat de text.count(char), qui compte le nombre d'occurrences de ce caractère dans la chaîne de texte.
    print(text) : Cette ligne imprime la chaîne de texte originale sur la console.
    print(char_frequency) : Cette ligne affiche le dictionnaire char_frequency, qui contient des caractères uniques comme clés et leurs fréquences comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire de mots et de leurs formes inversées

Exemple de résultat

['apple', 'banana', 'cherry']

\{'apple' : 'elppa', 'banana' : 'ananab', 'cherry' : 'yrrehc'\}.
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q672.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de mots et crée un dictionnaire reversed_words dont les clés sont les mots originaux et les valeurs les versions inversées de ces mots. Voici comment fonctionne ce code :

    mots = ['pomme', 'banane', 'cerise'] : Cette ligne initialise une liste nommée words avec trois mots.
    reversed_words = {word : word[::-1] for word in words} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire mots_inversés. Elle parcourt chaque mot de la liste des mots et affecte une paire clé-valeur au dictionnaire. La clé est le mot original (word), et la valeur est le mot inversé en utilisant le découpage (word[::-1]).
        pour mot dans mots : Cette partie du code parcourt chaque mot de la liste des mots.
        mot[::-1] : Cette partie du code découpe le mot avec un pas de -1, inversant ainsi l'ordre des caractères dans le mot.
    print(mots) : Cette ligne imprime la liste de mots originale sur la console.
    print(mots_inversés) : Cette ligne affiche le dictionnaire mots_inversés, qui contient les mots originaux comme clés et leurs versions inversées comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire des nombres et de leurs carrés, mais uniquement pour les nombres pairs

Exemple de résultat

[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

\{2 : 4, 4 : 16, 6 : 36, 8 : 64, 10 : 100\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q673.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de nombres et crée un dictionnaire even_squares dont les clés sont les nombres pairs de la liste originale, et les valeurs sont les carrés de ces nombres pairs. Voici comment fonctionne ce code :

    nombres = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] : Cette ligne initialise une liste nommée numbers avec dix valeurs entières.
    even_squares = {x : x ** 2 for x in numbers if x % 2 == 0} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire even_squares. Elle parcourt chaque nombre x dans la liste des nombres et affecte une paire clé-valeur au dictionnaire si et seulement si le nombre est pair (c'est-à-dire si x % 2 == 0 est Vrai). La clé est le nombre pair lui-même (x) et la valeur est le carré de ce nombre pair (x ** 2).
        pour x dans nombres : Cette partie du code parcourt chaque nombre de la liste des nombres.
        if x % 2 == 0 : Cette partie du code vérifie si le nombre est pair en testant s'il est divisible par 2 sans reste.
    print(numbers) : Cette ligne imprime la liste originale des nombres sur la console.
    print(even_squares) : Cette ligne affiche le dictionnaire even_squares, qui contient les nombres pairs comme clés et leurs valeurs au carré comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire des nombres et de leurs facteurs

Exemple de résultat

[1, 2, 3, 4, 5]

\{1 : [1], 2 : [1, 2], 3 : [1, 3], 4 : [1, 2, 4], 5 : [1, 5]\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q674.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de nombres et crée un dictionnaire factors où les clés sont les nombres de la liste originale, et les valeurs sont des listes de leurs facteurs. Voici comment fonctionne le code :

    nombres = [1, 2, 3, 4, 5] : Cette ligne initialise une liste nommée numbers avec cinq valeurs entières.
    facteurs = {x : [i for i in range(1, x + 1) if x % i == 0] for x in numbers} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire des facteurs. Elle parcourt chaque nombre x dans la liste des nombres et affecte une paire clé-valeur au dictionnaire. La clé est le nombre lui-même (x) et la valeur est une liste de ses facteurs.
        pour x dans nombres : Cette partie du code parcourt chaque nombre de la liste des nombres.
        x : [i for i in range(1, x + 1) if x % i == 0] : Cette partie du code utilise une compréhension de liste pour générer une liste de facteurs pour chaque nombre. Elle parcourt les nombres de 1 à x (inclus) et n'inclut que les nombres pour lesquels x % i == 0 est Vrai. Cette condition vérifie si i est un facteur de x.
    print(nombres) : Cette ligne imprime la liste originale des nombres sur la console.
    print(facteurs) : Cette ligne affiche le dictionnaire des facteurs, qui contient des nombres comme clés et des listes de leurs facteurs comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire de mots et de leurs majuscules

Exemple de sortie

['apple', 'banana', 'cherry']

\{'apple' : 'APPLE', 'banana' : 'BANANA', 'cherry' : 'CHERRY'\}.
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q675.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de mots et crée un dictionnaire uppercase_words dont les clés sont les mots de la liste originale et les valeurs sont les versions en majuscules de ces mots. Voici comment fonctionne ce code :

    mots = ['pomme', 'banane', 'cerise'] : Cette ligne initialise une liste nommée words avec trois valeurs de chaîne.
    uppercase_words = {word : word.upper() for word in words} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire uppercase_words. Elle parcourt chaque mot de la liste des mots et affecte une paire clé-valeur au dictionnaire. La clé est le mot original (word) et la valeur est la version en majuscules du mot (word.upper()).
        pour mot dans mots : Cette partie du code parcourt chaque mot de la liste des mots.
        word : word.upper() : Cette partie du code crée la paire clé-valeur. La clé est le mot original et la valeur est la version en majuscules du mot.
    print(words) : Cette ligne imprime la liste des mots originaux sur la console.
    print(mots_en_majuscules) : Cette ligne affiche le dictionnaire uppercase_words, qui contient des mots comme clés et leurs versions en majuscules comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire des nombres et de leur parité (paire ou impaire)

Exemple de résultat

[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

\{1 : 'odd', 2 : 'even', 3 : 'odd', 4 : 'even', 5 : 'odd', 6 : 'even', 7 : 'odd', 8 : 'even', 9 : 'odd', 10 : 'even'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q676.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de nombres et crée un dictionnaire de parité où les clés sont les nombres de la liste originale, et les valeurs indiquent si chaque nombre est "pair" ou "impair". Voici comment fonctionne ce code :

    nombres = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] : Cette ligne initialise une liste nommée nombres avec dix valeurs entières.
    parité = {x : 'even' if x % 2 == 0 else 'odd' for x in numbers} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire de parité. Elle parcourt chaque nombre x dans la liste des nombres et affecte une paire clé-valeur au dictionnaire. La clé est le nombre lui-même (x) et la valeur est déterminée à l'aide d'une expression conditionnelle :
        Si x % 2 == 0, il est considéré comme "pair". Sinon, il est considéré comme "impair".
        pour x dans nombres : Cette partie du code parcourt chaque nombre de la liste des nombres.
        x : "pair" si x % 2 == 0 sinon "impair" : Cette partie du code crée la paire clé-valeur. La clé est le nombre x, et la valeur est soit "pair", soit "impair", en fonction du résultat de l'expression conditionnelle.
    print(nombres) : Cette ligne imprime la liste originale des nombres sur la console.
    print(parity) : Cette ligne affiche le dictionnaire de parité, qui contient des nombres comme clés et leur parité (paire ou impaire) comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire des nombres et de leurs représentations binaires

Exemple de sortie

[1, 2, 3, 4, 5]

\{1 : '0b1', 2 : '0b10', 3 : '0b11', 4 : '0b100', 5 : '0b101'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q677.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python prend une liste de nombres et crée un dictionnaire binary_representations dont les clés sont les nombres de la liste originale et les valeurs sont leurs représentations binaires sous forme de chaînes de caractères. Voici comment fonctionne ce code :

    nombres = [1, 2, 3, 4, 5] : Cette ligne initialise une liste nommée numbers avec cinq valeurs entières.
    binary_representations = {x : bin(x) for x in numbers} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire binary_representations. Elle parcourt chaque nombre x de la liste des nombres et affecte une paire clé-valeur au dictionnaire. La clé est le nombre lui-même (x) et la valeur est sa représentation binaire sous forme de chaîne, obtenue à l'aide de la fonction bin.
        pour x dans nombres : Cette partie du code parcourt chaque nombre de la liste des nombres.
        x : bin(x) : Cette partie du code crée la paire clé-valeur. La clé est le nombre x et la valeur est sa représentation binaire sous forme de chaîne de caractères.
    print(nombres) : Cette ligne imprime la liste originale des nombres sur la console.
    print(binary_representations) : Cette ligne affiche le dictionnaire binary_representations, qui contient des nombres comme clés et leurs représentations binaires comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire des nombres et de leurs factoriels

Exemple de résultat

[1, 2, 3, 4, 5]

\{1 : 1, 2 : 2, 3 : 6, 4 : 24, 5 : 120\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q678.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un dictionnaire factorials dont les clés sont des nombres issus d'une liste et les valeurs sont leurs valeurs factorielles calculées à l'aide de la fonction math.factorial. Voici comment fonctionne le code :

    nombres = [1, 2, 3, 4, 5] : Cette ligne initialise une liste nommée numbers avec cinq valeurs entières.
    factorials = {x : math.factorial(x) for x in numbers} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire factorials. Elle parcourt chaque nombre x dans la liste des nombres et affecte une paire clé-valeur au dictionnaire. La clé est le nombre lui-même (x) et la valeur est sa factorielle calculée à l'aide de la fonction math.factorial.
        pour x dans nombres : Cette partie du code parcourt chaque nombre de la liste des nombres.
        x : math.factorial(x) : Cette partie du code crée la paire clé-valeur. La clé est le nombre x et la valeur est sa valeur factorielle calculée à l'aide de math.factorial(x).
    print(nombres) : Cette ligne imprime la liste originale des nombres sur la console.
    print(factorials) : Cette ligne affiche le dictionnaire factorials, qui contient des nombres comme clés et leurs valeurs factorielles comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire des nombres et de leurs carrés, mais seulement pour les multiples de 3

Exemple de résultat

[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

\{3 : 9, 6 : 36, 9 : 81\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q679.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un dictionnaire multiples_of_3_squares où les clés sont des nombres d'une liste, mais seulement pour les nombres qui sont des multiples de 3, et les valeurs sont les carrés de ces nombres. Voici comment fonctionne le code :

    nombres = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] : Cette ligne initialise une liste nommée nombres avec dix valeurs entières.
    multiples_of_3_squares = {x : x ** 2 for x in numbers if x % 3 == 0} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire multiples_of_3_squares. Elle parcourt chaque nombre x dans la liste des nombres et affecte une paire clé-valeur au dictionnaire uniquement si le nombre est un multiple de 3 (c'est-à-dire lorsque x % 3 == 0). La clé est le nombre lui-même (x) et la valeur est le carré de ce nombre (x ** 2).
        pour x dans nombres : Cette partie du code parcourt chaque nombre de la liste des nombres.
        if x % 3 == 0 : cette partie du code vérifie si le nombre x est un multiple de 3.
        x : x ** 2 : cette partie du code crée la paire clé-valeur. La clé est le nombre x et la valeur est son carré, calculé comme x ** 2.
    print(nombres) : Cette ligne imprime la liste originale des nombres sur la console.
    print(multiples_de_3_squares) : Cette ligne affiche le dictionnaire multiples_de_3_squares, qui contient des nombres (multiples de 3) comme clés et leurs valeurs au carré comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire des nombres et de leurs puissances de 2

Exemple de sortie

[1, 2, 3, 4, 5]

\{1 : 2, 2 : 4, 3 : 8, 4 : 16, 5 : 32\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q680.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python crée un dictionnaire powers_of_2, où les clés sont des nombres d'une liste, et les valeurs sont 2 élevés à la puissance de chaque nombre. Voici comment fonctionne le code :

    nombres = [1, 2, 3, 4, 5] : Cette ligne initialise une liste nommée numbers avec cinq valeurs entières.
    puissances_de_2 = {x : 2 ** x for x in numbers} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire powers_of_2. Elle parcourt chaque nombre x dans la liste des nombres et affecte une paire clé-valeur au dictionnaire. La clé est le nombre lui-même (x), et la valeur est calculée en élevant 2 à la puissance de ce nombre (2 ** x).
        pour x dans nombres : Cette partie du code parcourt chaque nombre de la liste des nombres.
        x : 2 ** x : Cette partie du code crée la paire clé-valeur. La clé est le nombre x, et la valeur est calculée comme 2 ** x, ce qui élève 2 à la puissance du nombre x.
    print(numbers) : Cette ligne imprime la liste originale des nombres sur la console.
    print(puissances_de_2) : Cette ligne affiche le dictionnaire powers_of_2, qui contient des nombres comme clés et leurs puissances de 2 correspondantes comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire de mots et de leurs voyelles, en excluant les mots sans voyelles.

Exemple de résultat

['apple', 'banana', 'cherry', 'dog', 'ct']

\{'apple' : 2, 'banana' : 3, 'cherry' : 1, 'dog' : 1, 'cat' : 1\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q681.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python définit un dictionnaire vowel_counts, dont les clés sont des mots d'une liste contenant au moins une voyelle (a, e, i, o, u), et dont les valeurs sont les nombres de voyelles dans chaque mot. Voici comment fonctionne le code :

    words = ['apple', 'banana', 'cherry', 'dog', 'ct'] : Cette ligne initialise une liste nommée words avec cinq valeurs de chaîne, dont certaines contiennent des voyelles.
    vowel_counts = {word : sum(1 for char in word if char.lower() in 'aeiou') for word in words if any(char.lower() in 'aeiou' for char in word)} : Cette ligne utilise une compréhension du dictionnaire pour créer le dictionnaire vowel_counts. Elle parcourt chaque mot de la liste des mots, et pour chaque mot, elle vérifie s'il y a au moins une voyelle (n'importe quel caractère voyelle) dans ce mot.
        pour mot dans mots : Cette partie du code parcourt chaque mot de la liste des mots.
        any(char.lower() in 'aeiou' for char in word) : Cette partie vérifie si l'un des caractères du mot est une voyelle minuscule ("a", "e", "i", "o", "u"). La partie char.lower() garantit que les voyelles minuscules et majuscules sont comptées.
        word : sum(1 for char in word if char.lower() in 'aeiou') : Si le mot contient au moins une voyelle, une paire clé-valeur est créée dans le dictionnaire. La clé est le mot lui-même (word), et la valeur est calculée en additionnant 1 pour chaque caractère du mot qui est une voyelle. La fonction char.lower() de la partie 'aeiou' vérifie si le caractère est une voyelle minuscule.
    print(words) : Cette ligne affiche la liste originale des mots sur la console.
    print(vowel_counts) : Cette ligne affiche le dictionnaire vowel_counts, qui contient les mots comportant au moins une voyelle et leur nombre de voyelles.
        \end{solution}
        

        \question
        Créer un dictionnaire de chaînes de caractères en remplaçant les voyelles par des traits de soulignement

Exemple de résultat

['apple', 'banana', 'cherry']

\{'apple' : '\_ppl\_', 'banana' : 'b\_n\_n\_', 'cherry' : 'ch\_rry'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q682.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le code Python définit un dictionnaire underscored_words, dont les clés sont des mots d'une liste et les valeurs sont les mêmes mots dont les voyelles ont été remplacées par des traits de soulignement. Voici comment fonctionne le code :

    words = ['apple', 'banana', 'cherry'] : Cette ligne initialise une liste nommée words avec trois valeurs de chaîne.
    underscored_words = {word : ''.join(['_' if char.lower() in 'aeiou' else char for char in word]) for word in words} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire underscored_words. Elle parcourt chaque mot de la liste des mots et crée une paire clé-valeur pour chaque mot.
        for word in words : Cette partie du code parcourt chaque mot de la liste des mots.
        ''.join(['_' if char.lower() in 'aeiou' else char for char in word]) : Pour chaque mot, il crée une version modifiée du mot dont les voyelles sont remplacées par des traits de soulignement ("_"). Pour ce faire, il parcourt chaque caractère du mot (for char in word) et utilise une expression conditionnelle pour vérifier si le caractère est une voyelle minuscule ('a', 'e', 'i', 'o', 'u'). S'il s'agit d'une voyelle, il la remplace par un trait de soulignement ; sinon, il conserve le caractère tel quel. La méthode join est utilisée pour concaténer les caractères modifiés en une seule chaîne.
    print(words) : Cette ligne affiche la liste originale des mots sur la console.
    print(mots_soulignés) : Cette ligne affiche le dictionnaire underscored_words, qui contient les mots originaux comme clés et leurs versions remplacées par des voyelles comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire de mots et de leur longueur, mais uniquement pour les mots commençant par "a".

Exemple de résultat

['apple', 'banana', 'cherry', 'date']

\{'apple' : 5\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q683.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le code Python que vous avez fourni crée un dictionnaire a_word_lengths, dont les clés sont les mots d'une liste commençant par la lettre "a", et les valeurs sont les longueurs de ces mots. Voici comment fonctionne le code :

    words = ['apple', 'banana', 'cherry', 'date'] : Cette ligne initialise une liste nommée words avec quatre valeurs de chaîne.
    a_word_lengths = {word : len(word) for word in words if word.startswith('a')} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire a_word_lengths. Elle parcourt chaque mot de la liste des mots et crée une paire clé-valeur pour chaque mot commençant par la lettre "a".
        pour mot dans mots : Cette partie du code parcourt chaque mot de la liste des mots.
        'a_word_lengths' = {word : len(word) for word in words if word.startswith('a')} : Pour chaque mot, il est vérifié si le mot commence par la lettre "a" en utilisant la condition word.startswith('a'). Si la condition est vraie, le mot est inclus dans le dictionnaire. La clé est le mot lui-même, et la valeur est la longueur du mot, calculée à l'aide de la fonction len(word).
    print(words) : Cette ligne affiche la liste originale des mots sur la console.
    print(a_word_lengths) : Cette ligne affiche le dictionnaire a_word_lengths, qui contient les mots commençant par "a" comme clés et leurs longueurs correspondantes comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire de chaînes de caractères en répétant chaque mot trois fois

Exemple de résultat

['apple', 'banana', 'cherry']

\{'apple' : 'appleappleapple', 'banana' : 'bananabanabanana', 'cherry' : 'cherrycherrycherry'\}.
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q684.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Crée un dictionnaire mots_répétés, dont les clés sont des mots d'une liste et les valeurs sont ces mots répétés trois fois. Voici comment fonctionne le code :

    words = ['apple', 'banana', 'cherry'] : Cette ligne initialise une liste nommée words avec trois valeurs de chaîne.
    repeated_words = {word : word * 3 for word in words} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire repeated_words. Elle parcourt chaque mot de la liste words et crée une paire clé-valeur pour chaque mot.
        for word in words : Cette partie du code parcourt chaque mot de la liste des mots.
        'repeated_words' = {word : word * 3 for word in words} : Pour chaque mot, le code prend le mot lui-même comme clé et utilise la multiplication de chaîne (mot * 3) pour répéter le mot trois fois, créant ainsi la valeur.
    print(words) : Cette ligne affiche la liste originale des mots sur la console.
    print(mots_répétés) : Cette ligne affiche le dictionnaire mots_répétés, qui contient les mots comme clés et les mots répétés trois fois comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire de chaînes avec les mots contenant "a" et leur longueur

Exemple de résultat

['apple', 'banana', 'cherry', 'date']

\{'apple' : 5, "banane" : 6, "date" : 4\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q685.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Crée un dictionnaire a_word_lengths, dont les clés sont les mots d'une liste contenant la lettre "a" et les valeurs sont les longueurs de ces mots. Voici comment fonctionne le code :

    words = ['apple', 'banana', 'cherry', 'date'] : Cette ligne initialise une liste nommée words avec quatre valeurs de chaîne.
    a_word_lengths = {word : len(word) for word in words if 'a' in word} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire a_word_lengths. Elle parcourt chaque mot de la liste des mots, vérifie si la lettre "a" est présente dans le mot et crée une paire clé-valeur pour les mots qui contiennent "a".
        pour mot dans mots : Cette partie du code parcourt chaque mot de la liste des mots.
        'a_word_lengths' = {word : len(word) for word in words if 'a' in word} : Pour chaque mot, il prend le mot lui-même comme clé et utilise la fonction len(word) pour calculer la longueur du mot, créant ainsi la valeur.
        if 'a' in word : Cette condition garantit que seuls les mots contenant la lettre 'a' sont inclus dans le dictionnaire.
    print(words) : Cette ligne affiche la liste originale des mots sur la console.
    print(a_word_lengths) : Cette ligne affiche le dictionnaire a_word_lengths, qui contient les mots (avec 'a') comme clés et leurs longueurs respectives comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire des nombres et de leurs carrés, mais uniquement pour les nombres supérieurs à 5

Exemple de résultat

[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

\{6 : 36, 7 : 49, 8 : 64, 9 : 81, 10 : 100\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q686.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Crée un dictionnaire nommé squares_greater_than_5, où les clés sont des nombres d'une liste qui sont supérieurs à 5, et les valeurs sont les carrés de ces nombres. Voici comment fonctionne le code :

    nombres = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] : Cette ligne initialise une liste nommée numbers avec dix valeurs entières.
    carrés_plus_que_5 = {x : x ** 2 for x in numbers if x > 5} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire squares_greater_than_5. Elle parcourt chaque nombre de la liste des nombres et vérifie s'il est supérieur à 5. Si la condition est remplie, elle crée une paire clé-valeur dans le dictionnaire.
        pour x dans nombres : Cette partie du code parcourt chaque nombre de la liste des nombres.
        carrés_plus_que_5 = {x : x ** 2 for x in numbers if x > 5} : Pour chaque nombre, le code prend le nombre lui-même comme clé et calcule le carré du nombre à l'aide de l'expression x ** 2, créant ainsi la valeur.
        if x > 5 : Cette condition garantit que seuls les nombres supérieurs à 5 sont inclus dans le dictionnaire.
    print(numbers) : Cette ligne imprime la liste originale des nombres sur la console.
    print(carrés_plus_grands_que_5) : Cette ligne affiche le dictionnaire squares_greater_than_5, qui contient les nombres supérieurs à 5 comme clés et leurs carrés correspondants comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire de caractères et de leurs valeurs ASCII à partir d'une chaîne de caractères, à l'exclusion des caractères non alphabétiques.

Exemple de sortie

Bonjour123

\{'H' : 72, 'e' : 101, 'l' : 108, 'o' : 111\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q687.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Crée un dictionnaire nommé ascii_values pour faire correspondre les caractères alphabétiques de la variable texte à leurs valeurs ASCII. Voici comment fonctionne le code :

    text = "Hello123" : Cette ligne initialise la variable texte avec la chaîne "Hello123".
    ascii_values = {char : ord(char) for char in text if char.isalpha()} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire ascii_values. Elle parcourt chaque caractère (char) de la chaîne de texte et vérifie si le caractère est alphabétique à l'aide de la méthode char.isalpha(). Si le caractère est alphabétique, il crée une paire clé-valeur dans le dictionnaire.
        pour char dans text : Cette partie du code parcourt chaque caractère de la chaîne de texte.
        ascii_values = {char : ord(char) for char in text if char.isalpha()} : Pour chaque caractère alphabétique, il prend le caractère lui-même comme clé et récupère sa valeur ASCII à l'aide de la fonction ord(char), créant ainsi la valeur.
        if char.isalpha() : Cette condition garantit que seuls les caractères alphabétiques sont inclus dans le dictionnaire.
    print(text) : Cette ligne imprime la chaîne de texte originale sur la console.
    print(ascii_values) : Cette ligne affiche le dictionnaire ascii_values, qui contient des caractères alphabétiques comme clés et leurs valeurs ASCII correspondantes comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire de mots et de leurs formes en majuscules, en excluant les mots sans majuscules.

Exemple de résultat

['apple', 'Banana', 'cherry', 'Date']

\{'Banane' : 'BANANE', 'Date' : 'DATE'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q688.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Crée un dictionnaire nommé uppercase_words qui associe les mots comportant au moins un caractère en majuscule à leur version en majuscule. Voici comment fonctionne le code :

    words = ['apple', 'Banana', 'cherry', 'Date'] : Cette ligne initialise la liste des mots avec une collection de mots, dont certains contiennent des caractères majuscules.
    uppercase_words = {word : word.upper() for word in words if any(char.isupper() for char in word)} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire uppercase_words. Elle parcourt chaque mot de la liste des mots et vérifie s'il contient au moins un caractère majuscule (char.isupper()). Si le mot contient au moins une majuscule, il crée une paire clé-valeur dans le dictionnaire.
        pour mot dans mots : Cette partie du code parcourt chaque mot de la liste des mots.
        if any(char.isupper() for char in word) : Cette condition vérifie s'il existe au moins un caractère majuscule dans le mot actuel. La fonction any vérifie si l'un des caractères du mot est en majuscule.
        {word : word.upper() for word in words if any(char.isupper() for char in word)} : Si la condition est remplie, une paire clé-valeur est créée dans le dictionnaire. La clé est le mot original, et la valeur est la version en majuscules de ce mot obtenue à l'aide de word.upper().
    print(words) : Cette ligne affiche la liste des mots originaux sur la console.
    print(mots_en_majuscules) : Cette ligne affiche le dictionnaire uppercase_words, qui contient des mots comportant au moins un caractère majuscule comme clés et leurs versions majuscules comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire de chaînes de mots contenant plus de 4 lettres

Exemple de résultat

Python est un langage de programmation puissant et polyvalent.

\{'Python' : 6, 'puissant' : 8, 'polyvalent' : 9, "programmation" : 11, "langage" : 8\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q689.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le code Python présente une phrase et crée un dictionnaire appelé mots_longs. Ce dictionnaire associe les mots d'une longueur supérieure à 4 à leurs longueurs respectives. Voici comment fonctionne le code :

    phrase = "Python est un langage de programmation puissant et polyvalent" : Cette ligne initialise la variable phrase avec une chaîne contenant des mots.
    long_words = {word : len(word) for word in sentence.split() if len(word) > 4} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire long_words. Elle divise la phrase en mots à l'aide de sentence.split(), puis parcourt chaque mot de la liste des mots.
        for word in sentence.split() : Cette partie du code parcourt chaque mot de la phrase.
        if len(word) > 4 : cette condition vérifie si la longueur du mot actuel est supérieure à 4 caractères.
        {mot : len(mot)} : Si la condition est remplie, une paire clé-valeur est créée dans le dictionnaire. La clé est le mot lui-même, et la valeur est la longueur du mot obtenue à l'aide de len(mot).
    print(phrase) : Cette ligne affiche la phrase originale sur la console.
    print(mots_longs) : Cette ligne affiche le dictionnaire mots_longs, qui contient des mots de longueur supérieure à 4 comme clés et leurs longueurs respectives comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire des mots et de leur première lettre en majuscule

Exemple de résultat

['apple', 'banana', 'cherry']

\{'apple' : 'Apple', 'banana' : 'Banana', 'cherry' : 'Cherry'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q690.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            La liste des mots et crée un dictionnaire appelé capitalized_first_letter. Ce dictionnaire associe chaque mot à une version du mot dont la première lettre est en majuscule. Voici comment fonctionne le code :

    words = ['apple', 'banana', 'cherry'] : Cette ligne initialise la variable words avec une liste de mots.
    première_lettre_capitalisée = {mot : mot[0].upper() + mot[1 :] pour mot dans mots} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire capitalized_first_letter. Elle parcourt chaque mot de la liste des mots.
        {mot : mot[0].upper() + mot[1 :]} : Cette partie du code crée des paires clé-valeur dans le dictionnaire. La clé est le mot original et la valeur est une version modifiée du mot dont la première lettre est en majuscule. Pour ce faire, on utilise word[0].upper() pour mettre la première lettre en majuscule, puis on la concatène avec le reste du mot obtenu à l'aide de word[1 :].
    print(words) : Cette ligne imprime la liste originale de mots, words, sur la console.
    print(première_lettre_capitalisée) : Cette ligne affiche le dictionnaire capitalized_first_letter, qui contient les mots originaux comme clés et leurs versions avec la première lettre en majuscule comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire de chaînes de caractères dont les voyelles ont été supprimées

Exemple de résultat

['apple', 'banana', 'cherry']

\{'apple' : 'ppl', 'banana' : 'bnn', 'cherry' : 'chrry'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q691.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            La liste des mots et crée un dictionnaire nommé without_vowels. Ce dictionnaire associe chaque mot à une version du mot dans laquelle toutes les voyelles (majuscules et minuscules) ont été supprimées. Voici comment fonctionne le code :

    words = ['apple', 'banana', 'cherry'] : Cette ligne initialise la variable words avec une liste de mots.
    without_vowels = {word : ''.join([char for char in word if char.lower() not in 'aeiou']) for word in words} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire sans_voyelles. Elle parcourt chaque mot de la liste des mots.
        {mot : ''.join([char for char in word if char.lower() not in 'aeiou'])} : Cette partie du code crée des paires clé-valeur dans le dictionnaire. La clé est le mot original et la valeur est une version modifiée du mot. La modification est effectuée en parcourant chaque caractère char dans le mot et en vérifiant si char.lower() (la version minuscule du caractère) n'est pas dans la chaîne 'aeiou', qui représente les voyelles. Si char n'est pas une voyelle, il est inclus dans la version modifiée du mot. La fonction join est utilisée pour concaténer les caractères en une seule chaîne.
    print(words) : Cette ligne imprime la liste originale des mots, words, sur la console.
    print(sans_voyelles) : Cette ligne affiche le dictionnaire without_vowels, qui contient les mots originaux comme clés et leurs versions sans voyelles comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire des nombres avec leurs signes inversés

Exemple de résultat

[5, -10, 15, -20, 25]

\{5 : -5, -10 : 10, 15 : -15, -20 : 20, 25 : -25\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q692.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            La liste des nombres et crée un dictionnaire appelé signes_inversés. Ce dictionnaire associe chaque nombre à sa négation (en changeant son signe de positif à négatif ou vice versa). Voici comment fonctionne le code :

    nombres = [5, -10, 15, -20, 25] : Cette ligne initialise la variable numbers avec une liste d'entiers, comprenant à la fois des nombres positifs et négatifs.
    signes_inversés = {x : -x for x in numbers} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire signes_inversés. Elle parcourt chaque nombre x dans la liste des nombres.
        {x : -x} : Cette partie du code crée des paires clé-valeur dans le dictionnaire. La clé est le nombre original x, et la valeur est la négation de ce nombre, qui est calculée comme -x.
    print(nombres) : Cette ligne imprime la liste originale des nombres, numbers, sur la console.
    print(signes_inversés) : Cette ligne affiche le dictionnaire signes_inversés, qui contient les nombres originaux comme clés et leurs négations comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire de chaînes de caractères avec des mots inversés

Exemple de résultat

Python est amusant

\{0 : 'fun', 1 : 'is', 2 : 'Python'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q693.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le code Python traite une phrase et crée un dictionnaire appelé mots_inversés. Ce dictionnaire associe l'index (position) de chaque mot dans l'ordre inverse au mot lui-même. Voici comment fonctionne le code :

    phrase = "Python is fun" : Cette ligne initialise la variable phrase avec une chaîne contenant plusieurs mots.
    reversed_words = {i : word for i, word in enumerate(sentence.split()[::-1])} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire mots_inversés. Voici ce qui se passe :
        sentence.split() : Cette partie du code divise la phrase en mots individuels et renvoie une liste de mots.
        [::-1] : Cette partie inverse l'ordre des mots dans la liste. Elle inverse donc l'ordre des mots dans la phrase.
        enumerate(...) : Cette fonction est utilisée pour parcourir la liste inversée des mots et renvoie à la fois l'index (i) et le mot lui-même.
        {i : mot pour i, mot dans ...} : Cette partie du code crée des paires clé-valeur dans le dictionnaire. Les clés (i) sont les indices des mots, et les valeurs (mot) sont les mots individuels de la liste inversée.
    print(phrase) : Cette ligne imprime la phrase originale, sentence, sur la console.
    print(mots_inversés) : Cette ligne affiche le dictionnaire mots_inversés, qui contient les indices des mots comme clés (dans l'ordre inverse) et les mots correspondants comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire des nombres avec leurs diviseurs

Exemple de résultat

[1, 2, 3, 4, 5]

\{1 : [1], 2 : [1, 2], 3 : [1, 3], 4 : [1, 2, 4], 5 : [1, 5]\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q694.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Crée un dictionnaire nommé diviseurs qui associe chaque nombre de la liste des nombres à une liste de ses diviseurs. Voici comment fonctionne le code :

    nombres = [1, 2, 3, 4, 5] : Cette ligne initialise la liste des nombres avec une séquence d'entiers.
    diviseurs = {x : [i for i in range(1, x + 1) if x % i == 0] for x in numbers} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire des diviseurs. Voici ce qui se passe :
        for x in numbers : Cette partie du code itère sur chaque nombre x dans la liste des nombres.
        {x : ...} : Cette partie du code crée des paires clé-valeur dans le dictionnaire. La clé est le nombre x et la valeur est le résultat de la compréhension de la liste intérieure.
        [i for i in range(1, x + 1) if x % i == 0] : Il s'agit de la compréhension de liste qui génère une liste de diviseurs pour chaque nombre x. Elle parcourt les nombres de 1 à x (inclus) et vérifie si x est divisible par i. Si c'est le cas, i est inclus dans la liste des diviseurs.
    print(nombres) : Cette ligne imprime la liste des nombres sur la console.
    print(diviseurs) : Cette ligne affiche le dictionnaire des diviseurs, qui contient des nombres comme clés et des listes de diviseurs comme valeurs.
        \end{solution}
        

        \question
        Créer un dictionnaire de caractères et leur nombre, à l'exclusion des caractères d'espacement, à partir d'une chaîne de caractères.

Exemple de sortie

bonjour le monde

\{'o' : 2, 'h' : 1, 'r' : 1, 'w' : 1, 'e' : 1, 'l' : 3, 'd' : 1\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q695.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Il compte les occurrences de caractères non spatiaux dans le texte donné et crée un dictionnaire qui associe chaque caractère à son nombre. Voici comment fonctionne le code :

    text = "hello world" : Cette ligne initialise la variable texte avec le texte d'entrée.
    char_counts = {char : text.count(char) for char in set(text) if not char.isspace()} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire char_counts. Voici ce qui se passe :
        {char : ...} : Cette partie du code crée des paires clé-valeur dans le dictionnaire. La clé est un caractère char, et la valeur est le résultat de l'expression text.count(char), qui compte les occurrences de char dans le texte.
        for char in set(text) : Cette partie itère sur chaque caractère unique du texte. L'expression set(text) est utilisée pour obtenir un ensemble de caractères uniques, en éliminant les doublons.
        if not char.isspace() : Cette partie vérifie si le caractère char n'est pas un caractère d'espacement. Elle permet de s'assurer que seuls les caractères non spatiaux sont comptés.
    print(text) : Cette ligne imprime le texte original sur la console.
    print(char_counts) : Cette ligne affiche le dictionnaire char_counts, qui contient des caractères non spatiaux comme clés et leur nombre comme valeurs.
        \end{solution}
        

        \question
        Correspondance entre les lettres minuscules et leurs valeurs ASCII

Exemple de sortie

\{'a' : 97, 'b' : 98, 'c' : 99, 'd' : 100, 'e' : 101, 'f' : 102, "g" : 103, "h" : 104, 'i' : 105, 'j' : 106, 'k' : 107, "l" : 108, "m" : 109, "n" : 110, "o" : 111, "p" : 112, 'q' : 113, 'r' : 114, 's' : 115, "t" : 116, "u" : 117, 'v' : 118, 'w' : 119, 'x' : 120, 'y' : 121, 'z' : 122\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q696.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Crée un dictionnaire appelé ascii_mapping qui associe chaque lettre minuscule de l'alphabet anglais à la valeur ASCII correspondante. Voici ce que fait le code :

    ascii_mapping = {char : ord(char) for char in 'abcdefghijklmnopqrstuvwxyz'} : Cette ligne crée le dictionnaire ascii_mapping en utilisant une compréhension de dictionnaire. Voici comment cela fonctionne :
        {char : ord(char) for char in 'abcdefghijklmnopqrstuvwxyz'} est la compréhension du dictionnaire. Il parcourt chaque caractère (char) de la chaîne 'abcdefghijklmnopqrstuvwxyz'.
        Pour chaque caractère, il crée une paire clé-valeur dans le dictionnaire. La clé (char) est le caractère lui-même, et la valeur (ord(char)) est la valeur ASCII de ce caractère obtenue à l'aide de la fonction ord.
        \end{solution}
        

        \question
        Nombres et leur factorielle de 1 à 10

Exemple de résultat

\{1 : 1, 2 : 2, 3 : 6, 4 : 24, 5 : 120, 6 : 720, 7 : 5040, 8 : 40320, 9 : 362880, 10 : 3628800\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q697.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le code définit une fonction Python factorial(n) pour calculer la factorielle d'un nombre n à l'aide de la récursivité, puis utilise cette fonction pour créer un dictionnaire appelé factorials. Ce dictionnaire associe les nombres de 1 à 10 à leurs valeurs factorielles respectives. Voici une explication pas à pas du code :

    def factorial(n) : Cette ligne définit une fonction nommée factorial qui prend un entier n en entrée et calcule la factorielle de n en utilisant la récursivité.
        Le cas de base est défini comme suit : if n == 0 :. Lorsque n est 0, la fonction renvoie 1 car 0 ! (lire "factorielle zéro") est défini comme 1.
        Dans le cas récursif, la fonction calcule la factorielle de n comme n * factorielle(n - 1). Elle s'appelle récursivement avec une valeur plus petite jusqu'à ce qu'elle atteigne le cas de base.
    factorials = {x : factorial(x) for x in range(1, 11)} : Cette ligne crée le dictionnaire factoriel en utilisant une compréhension de dictionnaire. Voici comment cela fonctionne :
        {x : factorial(x) for x in range(1, 11)} est la compréhension du dictionnaire. Elle parcourt la plage de nombres de 1 à 10 (inclus).
        Pour chaque nombre x, il crée une paire clé-valeur dans le dictionnaire. La clé (x) est le nombre lui-même, et la valeur (factorielle(x)) est calculée en appelant la fonction factorielle avec ce nombre en entrée.
    print(factorials) : Cette ligne affiche le dictionnaire factoriel sur la console.
        \end{solution}
        

        \question
        Les nombres et leur représentation binaire de 1 à 10

Exemple de sortie

\{1 : '1', 2 : '10', 3 : '11', 4 : '100', 5 : '101', 6 : '110', 7 : '111', 8 : '1000', 9 : '1001', 10 : '1010'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q698.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Crée un dictionnaire appelé binary_rep en utilisant une compréhension de dictionnaire en Python. Ce dictionnaire associe les nombres de 1 à 10 à leurs représentations binaires respectives sous forme de chaînes de caractères. Voici une explication pas à pas du code :

    binary_rep = {x : bin(x)[2 :] for x in range(1, 11)} : Cette ligne crée le dictionnaire binary_rep à l'aide d'une compréhension de dictionnaire. Voici comment cela fonctionne :
        {x : bin(x)[2 :] for x in range(1, 11)} est la compréhension du dictionnaire. Elle parcourt la plage de nombres de 1 à 10 (inclus).
        Pour chaque nombre x, il crée une paire clé-valeur dans le dictionnaire. La clé (x) est le nombre lui-même, et la valeur (bin(x)[2 :]) est calculée en convertissant x en sa représentation binaire à l'aide de la fonction bin, puis en supprimant les deux premiers caractères (qui sont '0b') de la chaîne binaire pour obtenir la représentation binaire sous la forme d'une chaîne.
    print(binary_rep) : Cette ligne affiche le dictionnaire binary_rep sur la console.
        \end{solution}
        

        \question
        Paires d'éléments distincts et leur différence absolue à partir de deux listes

Exemple de résultat

[3, 6, 9]

[5, 10, 15]

\{(3, 5) : 2, (3, 10) : 7, (3, 15) : 12, (6, 5) : 1, (6, 10) : 4, (6, 15) : 9, (9, 5) : 4, (9, 10) : 1, (9, 15) : 6\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q699.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Crée un dictionnaire nommé abs_diff_dict. Ce dictionnaire associe des paires d'éléments de list1 et list2 à leurs différences absolues. Voici comment fonctionne le code :

    list1 = [3, 6, 9] et list2 = [5, 10, 15] : Ces lignes initialisent deux listes, list1 et list2, avec des valeurs entières.
    abs_diff_dict = {(x, y) : abs(x - y) for x in list1 for y in list2} : Cette ligne utilise une compréhension de dictionnaire pour créer le dictionnaire abs_diff_dict. Voici ce qui se passe :
        (x, y) est utilisé comme un tuple pour représenter des paires d'éléments, où x est un élément de la liste 1 et y est un élément de la liste 2.
        abs(x - y) calcule la différence absolue entre x et y pour chaque paire.
        La compréhension du dictionnaire passe en revue toutes les paires possibles d'éléments de list1 et list2 et calcule la différence absolue pour chaque paire, en utilisant le tuple (x, y) comme clé et la différence absolue comme valeur.
    print(list1) : Cette ligne affiche le contenu de la liste 1 sur la console.
    print(list2) : Cette ligne affiche le contenu de la liste 2 sur la console.
    print(abs_diff_dict) : Cette ligne affiche le dictionnaire abs_diff_dict, qui contient des paires d'éléments comme clés et leurs différences absolues comme valeurs.
        \end{solution}
        

        \question
        Paires d'éléments distincts et leur position de caractère additionnés à partir de deux listes

Exemple de résultat

['abc', 'def', 'ghi']

['jkl', 'mno', 'pqr']

\{('abc', 'jkl') : 615, ('abc', 'mno') : 624, ('abc', 'pqr') : 633, ('def', 'jkl') : 624, ('def', 'mno') : 633, ("def", "pqr") : 642, ('ghi', 'jkl') : 633, ('ghi', 'mno') : 642, ('ghi', 'pqr') : 651\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q700.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Crée un dictionnaire appelé char_pos_sum_dict à l'aide d'une compréhension de dictionnaire en Python. Ce dictionnaire associe des paires de chaînes de caractères provenant de deux listes, list1 et list2, à la somme des valeurs ordinales (valeurs ASCII) des caractères de chaque paire. Voici une explication pas à pas du code :

    list1 = ["abc", "def", "ghi"] : Cette ligne définit une liste appelée list1 contenant trois chaînes de caractères.
    list2 = ["jkl", "mno", "pqr"] : Cette ligne définit une autre liste appelée list2 contenant trois chaînes de caractères.
    char_pos_sum_dict = {(x, y) : sum(ord(char) for char in x) + sum(ord(char) for char in y) for x in list1 for y in list2} : Cette ligne crée le dictionnaire char_pos_sum_dict à l'aide d'une compréhension de dictionnaire imbriqué. Voici comment cela fonctionne :
        {(x, y) : sum(ord(char) for char in x) + sum(ord(char) for char in y) for x in list1 for y in list2} est la compréhension du dictionnaire. Il itère sur des paires de chaînes (x, y) où x provient de list1 et y de list2.
        Pour chaque paire de chaînes, il crée une paire clé-valeur dans le dictionnaire. La clé x, y est un tuple contenant les deux chaînes. La valeur est calculée en additionnant les valeurs ordinales (valeurs ASCII) de tous les caractères de la première chaîne x et de tous les caractères de la deuxième chaîne y.
    print(list1) : Cette ligne imprime le contenu de la liste 1 sur la console.
    print(list2) : Cette ligne affiche le contenu de la liste 2 sur la console.
    print(char_pos_sum_dict) : Cette ligne affiche le dictionnaire char_pos_sum_dict sur la console.
        \end{solution}
        

        \question
        Mots distincts et leur longueur, à l'exclusion des mots de longueur impaire, dans une phrase

Exemple de sortie

Bonjour, comment allez-vous ?

\{'Hello,' : 6, 'you?' : 4\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q701.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le code traite une phrase et crée un dictionnaire nommé distinct_word_length_no_odd à l'aide d'une compréhension de dictionnaire en Python. Ce dictionnaire associe les mots distincts de la phrase à leurs longueurs respectives, mais uniquement pour les mots de longueur paire. Voici une explication pas à pas du code :

    sentence = "Hello, how are you ?": Cette ligne définit une variable de type chaîne appelée sentence contenant la phrase "Hello, how are you ?"
    distinct_word_length_no_odd = {word : len(word) for word in set(sentence.split()) if len(word) % 2 == 0} : Cette ligne crée le dictionnaire distinct_word_length_no_odd en utilisant une compréhension de dictionnaire. Voici comment cela fonctionne :
        {word : len(word) for word in set(sentence.split()) if len(word) % 2 == 0} est la compréhension du dictionnaire. Il effectue les étapes suivantes :
        sentence.split() divise la phrase en une liste de mots. Dans ce cas, elle inclura des mots comme "Hello," (avec une virgule) et "you ?" (avec un point d'interrogation). (avec un point d'interrogation).
        set(sentence.split()) crée un ensemble de mots distincts en supprimant les doublons et la ponctuation. Il contiendra donc des mots comme "Hello," (sans la virgule) et "you" (sans le point d'interrogation).
        for word in set(sentence.split()) itère sur chaque mot distinct de l'ensemble.
        len(word) % 2 == 0 vérifie si la longueur du mot est paire.
        Si la longueur d'un mot est paire, il crée une paire clé-valeur dans le dictionnaire. La clé (mot) est le mot lui-même, et la valeur (len(mot)) est la longueur du mot.
    print(phrase) : Cette ligne imprime la phrase originale, qui est "Hello, how are you ?", sur la console.
    print(distinct_word_length_no_odd) : Cette ligne affiche le dictionnaire distinct_mot_longueur_no_odd sur la console.
        \end{solution}
        

        \question
        Mots distincts et leur longueur, à l'exclusion des mots de longueur paire, dans une phrase

Exemple de sortie

Bonjour, comment allez-vous ?

\{'how' : 3, 'are' : 3\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q702.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le code traite une phrase et crée un dictionnaire nommé distinct_word_length_no_even à l'aide d'une compréhension de dictionnaire en Python. Ce dictionnaire associe les mots distincts de la phrase à leurs longueurs respectives, mais uniquement pour les mots de longueur impaire. Voici une explication pas à pas du code :

    sentence = "Hello, how are you ?": Cette ligne définit une variable de type chaîne appelée sentence contenant la phrase "Hello, how are you ?"
    distinct_word_length_no_even = {word : len(word) for word in set(sentence.split()) if len(word) % 2 != 0} : Cette ligne crée le dictionnaire distinct_mot_longueur_même à l'aide d'une compréhension de dictionnaire. Voici comment cela fonctionne :
        {word : len(word) for word in set(sentence.split()) if len(word) % 2 != 0} est la compréhension du dictionnaire. Il effectue les étapes suivantes :
        sentence.split() divise la phrase en une liste de mots. Dans ce cas, elle inclura des mots comme "Hello," (avec une virgule) et "you ?" (avec un point d'interrogation). (avec un point d'interrogation).
        set(sentence.split()) crée un ensemble de mots distincts en supprimant les doublons et la ponctuation. Il contiendra donc des mots comme "Hello," (sans la virgule) et "you" (sans le point d'interrogation).
        for word in set(sentence.split()) itère sur chaque mot distinct de l'ensemble.
        len(word) % 2 != 0 vérifie si la longueur du mot est impaire.
        Si la longueur d'un mot est impaire, cela crée une paire clé-valeur dans le dictionnaire. La clé (mot) est le mot lui-même, et la valeur (len(mot)) est la longueur du mot.
    print(phrase) : Cette ligne imprime la phrase originale, qui est "Hello, how are you ?", sur la console.
    print(distinct_word_length_no_even) : Cette ligne affiche le dictionnaire distinct_mot_longueur_non_pair sur la console.
        \end{solution}
        

        \question
        Caractères et nombre d'occurrences, hors ponctuation, dans une phrase

Exemple de sortie

Bonjour, comment allez-vous ?

\{'w' : 1, 'r' : 1, 'u' : 1, 'o' : 3, 'e' : 2, 'H' : 1, 'l' : 2, 'h' : 1, ' ' : 3, 'y' : 1, 'a' : 1\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q703.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le code traite une phrase et crée un dictionnaire nommé char_occurrence_no_punct à l'aide d'une compréhension de dictionnaire en Python. Ce dictionnaire associe les caractères présents dans la phrase à leur nombre respectif, à l'exclusion des caractères de ponctuation. Voici une explication pas à pas du code :

    import string : Cette ligne importe le module string, qui fournit une chaîne contenant tous les caractères de ponctuation ASCII.
    sentence = "Hello, how are you ?": Cette ligne définit une variable de type chaîne de caractères appelée sentence contenant la phrase "Hello, how are you ?"
    char_occurrence_no_punct = {char : sentence.count(char) for char in set(sentence) if char not in string.punctuation} : Cette ligne crée le dictionnaire char_occurrence_no_punct à l'aide d'une compréhension de dictionnaire. Voici comment cela fonctionne :
        {char : sentence.count(char) for char in set(sentence) if char not in string.punctuation} est la compréhension du dictionnaire. Il exécute les étapes suivantes :
        set(sentence) crée un ensemble de caractères distincts à partir de la phrase.
        for char in set(sentence) itère sur chaque caractère distinct de l'ensemble.
        char not in string.punctuation vérifie si le caractère n'est pas dans la chaîne string.punctuation, qui contient tous les caractères de ponctuation.
        Si un caractère n'est pas un caractère de ponctuation, il crée une paire clé-valeur dans le dictionnaire. La clé (char) est le caractère lui-même, et la valeur (sentence.count(char)) est le nombre de fois où ce caractère apparaît dans la phrase.
    print(phrase) : Cette ligne imprime la phrase originale, qui est "Hello, how are you ?", sur la console.
    print(char_occurrence_no_punct) : Cette ligne affiche le dictionnaire char_occurrence_no_punct sur la console.
        \end{solution}
        

        \question
        Mots distincts et leur longueur, à l'exclusion de ceux dont la longueur n'est pas de Fibonacci, dans une phrase

Exemple de sortie

Bonjour, comment allez-vous ?

\{'are' : 3, 'how' : 3\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q704.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le code définit une fonction is_fibonacci_length(n) pour vérifier si un nombre donné est un nombre de Fibonacci (en vérifiant si sa longueur fait partie de la séquence de Fibonacci). Il utilise ensuite cette fonction pour créer un dictionnaire nommé distinct_word_length_fibonacci à l'aide d'une compréhension de dictionnaire en Python. Ce dictionnaire associe les mots distincts de la phrase à leurs longueurs respectives, mais uniquement pour les mots dont les longueurs sont des nombres de Fibonacci. Voici une explication pas à pas du code :

    def is_fibonacci_length(n) : Cette ligne définit une fonction nommée is_fibonacci_length qui prend un entier n en entrée et vérifie si n est un nombre de Fibonacci en comparant sa longueur à la séquence de Fibonacci.
        Dans la fonction, une liste fib est initialisée avec les deux premiers nombres de Fibonacci (0 et 1).
        Une boucle while vérifie si le dernier nombre de la liste fib (fib[-1]) est inférieur ou égal à n. Elle continue à calculer les nombres de Fibonacci jusqu'à ce que le dernier soit inférieur ou égal à n.
        Si fib[-1] est égal à n, la fonction renvoie True car n est un nombre de Fibonacci en raison de sa longueur.
        Si la boucle se termine sans trouver de nombre de Fibonacci de la longueur donnée, la fonction renvoie False.
    sentence = "Hello, how are you ?": Cette ligne définit une variable de type chaîne de caractères appelée sentence contenant la phrase "Hello, how are you ?"
    distinct_word_length_fibonacci = {word : len(word) for word in set(sentence.split()) if is_fibonacci_length(len(word))} : Cette ligne crée le dictionnaire distinct_mot_longueur_fibonacci à l'aide d'une compréhension de dictionnaire. Voici comment cela fonctionne :
        {word : len(word) for word in set(sentence.split()) if is_fibonacci_length(len(word)} est la compréhension du dictionnaire. Il effectue les étapes suivantes :
        sentence.split() divise la phrase en une liste de mots.
        set(sentence.split()) crée un ensemble de mots distincts en supprimant les doublons.
        for word in set(sentence.split()) itère sur chaque mot distinct de l'ensemble.
        is_fibonacci_length(len(word)) vérifie si la longueur du mot est un nombre de Fibonacci à l'aide de la fonction is_fibonacci_length.
        Si la longueur d'un mot est un nombre de Fibonacci, une paire clé-valeur est créée dans le dictionnaire. La clé (mot) est le mot lui-même, et la valeur (len(mot)) est la longueur du mot.
    print(phrase) : Cette ligne imprime la phrase originale, qui est "Hello, how are you ?", sur la console.
    print(longueur_de_mot_distinct_fibonacci) : Cette ligne affiche le dictionnaire distinct_mot_longueur_fibonacci sur la console.
        \end{solution}
        

        \question
        Correspondance entre les mots et la fréquence à laquelle ils contiennent la lettre "e".

Exemple de résultat

Bonjour, comment allez-vous ?

\{'Hello,' : 1, 'comment' : 0, 'are' : 1, 'you ? 0\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q705.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le code traite une phrase et crée un dictionnaire nommé word_contains_e à l'aide d'une compréhension de dictionnaire en Python. Ce dictionnaire associe les mots de la phrase au nombre de lettres "e" dans chaque mot. Voici une explication pas à pas du code :

    sentence = "Hello, how are you ?": Cette ligne définit une variable de type chaîne appelée sentence contenant la phrase "Hello, how are you ?"
    word_contains_e = {word : word.count('e') for word in sentence.split()} : Cette ligne crée le dictionnaire word_contains_e à l'aide d'une compréhension de dictionnaire. Voici comment cela fonctionne :
        {word : word.count('e') for word in sentence.split()} est la compréhension du dictionnaire. Elle effectue les étapes suivantes :
        sentence.split() divise la phrase en une liste de mots. Dans ce cas, elle inclura des mots comme "Hello," (avec une virgule) et "you ?" (avec un point d'interrogation). (avec un point d'interrogation).
        for word in sentence.split() parcourt chaque mot de la liste de mots.
        word.count('e') compte les occurrences de la lettre "e" dans le mot.
        Il crée une paire clé-valeur dans le dictionnaire, où la clé (mot) est le mot lui-même, et la valeur (mot.count('e')) est le nombre d'occurrences de la lettre 'e' dans le mot.
    print(phrase) : Cette ligne imprime la phrase originale, qui est "Hello, how are you ?", sur la console.
    print(mot_contient_e) : Cette ligne affiche le dictionnaire word_contains_e sur la console.
        \end{solution}
        

        \question
        Correspondance entre les caractères et leur position dans l'alphabet

Exemple de sortie

\{'a' : 1, 'b' : 2, 'c' : 3, 'd' : 4, 'e' : 5, 'f' : 6, 'g' : 7, 'h' : 8, 'i' : 9, 'j' : 10, 'k' : 11, "l" : 12, "m" : 13, "n" : 14, "o" : 15, "p" : 16, 'q' : 17, 'r' : 18, 's' : 19, "t" : 20, "u" : 21, "v" : 22, "w" : 23, 'x' : 24, 'y' : 25, 'z' : 26\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q706.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Crée un dictionnaire nommé char_alphabet_position à l'aide d'une compréhension de dictionnaire en Python. Ce dictionnaire associe les lettres minuscules de l'alphabet anglais à leurs positions respectives dans l'alphabet, en commençant par 1. Voici une explication du code étape par étape :

    import string : Cette ligne importe le module string, qui fournit une constante string.ascii_lowercase contenant toutes les lettres minuscules de l'alphabet anglais.
    char_alphabet_position = {char : string.ascii_lowercase.index(char) + 1 for char in string.ascii_lowercase} : Cette ligne crée le dictionnaire char_alphabet_position à l'aide d'une compréhension de dictionnaire. Voici comment cela fonctionne :
        {char : string.ascii_lowercase.index(char) + 1 for char in string.ascii_lowercase} est la compréhension du dictionnaire. Il effectue les étapes suivantes :
        string.ascii_lowercase est la chaîne contenant toutes les lettres minuscules de l'alphabet anglais : "abcdefghijklmnopqrstuvwxyz".
        for char in string.ascii_lowercase itère sur chaque lettre minuscule de l'alphabet.
        string.ascii_lowercase.index(char) trouve l'indice (position) du caractère char dans la chaîne de caractères string.ascii_lowercase. Cet indice est basé sur zéro.
        + 1 est ajouté à l'index pour le faire passer d'un index basé sur zéro à une position basée sur un, car les positions dans l'alphabet commencent à 1.
        Cela crée une paire clé-valeur dans le dictionnaire, où la clé (char) est la lettre minuscule, et la valeur (string.ascii_lowercase.index(char) + 1) est sa position dans l'alphabet.
    print(char_alphabet_position) : Cette ligne affiche le dictionnaire char_alphabet_position sur la console.
        \end{solution}
        

        \question
        Mise en correspondance des mots avec leur statut de palindrome dans une phrase

Exemple de sortie

madame voit la voiture de course

\{'madam' : True, 'sees' : True, 'the' : False, 'racecar' : True\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q707.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le code traite une phrase et crée un dictionnaire nommé word_is_palindrome à l'aide d'une compréhension de dictionnaire en Python. Ce dictionnaire associe les mots de la phrase à une valeur booléenne indiquant si chaque mot est un palindrome. Voici une explication pas à pas du code :

    sentence = "madame voit la voiture de course" : Cette ligne définit une variable de type chaîne appelée phrase contenant la phrase "madame voit la voiture de course".
    word_is_palindrome = {word : word == word[::-1] for word in sentence.split()} : Cette ligne crée le dictionnaire word_is_palindrome en utilisant la compréhension du dictionnaire. Voici comment cela fonctionne :
        {word : word == word[::-1] for word in sentence.split()} est la compréhension du dictionnaire. Elle effectue les étapes suivantes :
        sentence.split() divise la phrase en une liste de mots. Dans ce cas, la phrase contient des mots comme "madam", "sees", "the" et "racecar".
        for word in sentence.split() itère sur chaque mot de la liste de mots.
        mot == mot[::-1] vérifie si le mot est un palindrome. Pour ce faire, il compare le mot lui-même (word) à son inverse (word[::-1]).
        Si un mot est un palindrome, il crée une paire clé-valeur dans le dictionnaire. La clé (mot) est le mot lui-même, et la valeur (mot == mot[::-1]) est True, indiquant qu'il s'agit d'un palindrome.
        Si un mot n'est pas un palindrome, la valeur est False.
    print(phrase) : Cette ligne imprime la phrase originale, qui est "madame voit la voiture de course", sur la console.
    print(mot_est_palindrome) : Cette ligne affiche le dictionnaire word_is_palindrome sur la console.
        \end{solution}
        

        \question
        Correspondance entre les nombres et leurs représentations binaires et hexadécimales

Exemple de sortie

\{1 : ('1', '1'), 2 : ('10', '2'), 3 : ('11', '3'), 4 : ('100', '4'), 5 : ('101', '5'), 6 : ('110', '6'), 7 : ('111', '7'), 8 : ('1000', '8'), 9 : ('1001', '9'), 10 : ('1010', 'a')\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q708.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Crée un dictionnaire nommé number_binary_hex en utilisant une compréhension de dictionnaire en Python. Ce dictionnaire associe les nombres de 1 à 10 à leurs représentations binaires et hexadécimales. Voici une explication pas à pas du code :

    number_binary_hex = {num : (bin(num)[2 :], hex(num)[2 :]) for num in range(1, 11)} : Cette ligne crée le dictionnaire number_binary_hex à l'aide d'une compréhension de dictionnaire. Voici comment cela fonctionne :
        {num : (bin(num)[2 :], hex(num)[2 :]) for num in range(1, 11)} est la compréhension du dictionnaire. Il effectue les étapes suivantes :
        for num in range(1, 11) itère sur les nombres de 1 à 10 (inclus).
        (bin(num)[2 :], hex(num)[2 :]) est un tuple contenant deux éléments :
            bin(num)[2 :] convertit le nombre num en sa représentation binaire à l'aide de la fonction bin, puis coupe les deux premiers caractères (qui représentent "0b" au début de la chaîne binaire).
            hex(num)[2 :] convertit le nombre num en sa représentation hexadécimale à l'aide de la fonction hex, puis coupe les deux premiers caractères (qui représentent "0x" au début de la chaîne hexadécimale).
        Il crée une paire clé-valeur dans le dictionnaire, où la clé (num) est le nombre lui-même, et la valeur est le tuple contenant les représentations binaire et hexadécimale.
    print(nombre_binaire_hex) : Cette ligne imprime le dictionnaire number_binary_hex sur la console.
        \end{solution}
        

        \question
        Mettre en correspondance les mots et leur inverse dans une phrase

Exemple de sortie

Bonjour, comment allez-vous ?

\{'Hello,' : ',olleH', 'how' : 'woh', 'are' : 'era', 'you?' : '?uoy'\}
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q709.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le code traite une phrase et crée un dictionnaire nommé word_reverse_mapping à l'aide d'une compréhension de dictionnaire en Python. Ce dictionnaire associe les mots de la phrase à leurs versions inversées respectives. Voici une explication pas à pas du code :

    sentence = "Hello, how are you ?": Cette ligne définit une variable de chaîne appelée sentence contenant la phrase "Hello, how are you ?"
    word_reverse_mapping = {word : word[::-1] for word in sentence.split()} : Cette ligne crée le dictionnaire word_reverse_mapping à l'aide d'une compréhension de dictionnaire. Voici comment cela fonctionne :
        {word : word[::-1] for word in sentence.split()} est la compréhension du dictionnaire. Elle effectue les étapes suivantes :
        sentence.split() divise la phrase en une liste de mots. Dans ce cas, elle inclura des mots comme "Hello," (avec une virgule) et "you ?" (avec un point d'interrogation). (avec un point d'interrogation).
        for word in sentence.split() parcourt chaque mot de la liste de mots.
        mot[::-1] inverse l'ordre des caractères dans le mot. Pour ce faire, on utilise la notation de découpage de Python, où [::-1] est utilisé pour inverser une chaîne de caractères.
        Cela crée une paire clé-valeur dans le dictionnaire, où la clé (word) est le mot lui-même, et la valeur (word[::-1]) est le mot inversé.
    print(phrase) : Cette ligne imprime la phrase originale, qui est "Hello, how are you ?", sur la console.
    print(word_reverse_mapping) : Cette ligne affiche le dictionnaire word_reverse_mapping sur la console.
        \end{solution}
        

        \question
        DEPART de la classe
Ecrire un programme python pour créer une classe d'étudiants
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q710.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce programme Python définit une classe Student avec des attributs et des méthodes permettant de définir et d'afficher les données des étudiants. Voici une explication du programme :

    classe Étudiant : Il s'agit de la classe principale représentant un étudiant. Elle possède les attributs et méthodes suivants :
        Attributs de la classe :
            id : Permet de stocker l'identifiant de l'étudiant (initialisé à 0 par défaut).
            name : Stocke le nom de l'étudiant (initialisé par défaut à une chaîne vide).
            gender (sexe) : Indique le sexe de l'étudiant (initialisé par défaut comme une chaîne vide).
            total : Stocke les notes totales de l'étudiant (initialisé par défaut comme une chaîne vide).
            per : Stocke le pourcentage de l'étudiant (initialisé à 0 par défaut).
        setData(self, id, name, gender, total, per) : Cette méthode est utilisée pour définir les données d'un étudiant. Elle prend en paramètre l'identifiant, le nom, le sexe, le total des notes et le pourcentage de l'élève et les affecte aux attributs correspondants de l'instance.
        showData(self) : Cette méthode est utilisée pour afficher les données de l'étudiant. Elle affiche l'ID, le nom, le sexe, le total des notes et le pourcentage de l'étudiant.
    Une instance de la classe Student est créée et nommée s.
    La méthode setData est appelée sur l'instance s pour définir les données de l'étudiant. Dans ce cas, l'ID de l'étudiant est fixé à 1, son nom à "Sam Kumar", son sexe à "Male", le total de ses notes à 422 et son pourcentage à 84,44.
    La méthode showData est appelée sur l'instance s pour imprimer les données de l'étudiant.
        \end{solution}
        

        \question
        Écrire un programme python pour créer une classe d'étudiants avec un constructeur et un destructeur.
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q711.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce code Python définit une classe Student avec un constructeur, un destructeur et des méthodes pour définir et afficher les données des étudiants. Voici une explication du code :

    class Student: : Cette ligne définit une classe nommée Student, qui sert de modèle pour la création d'objets étudiants.
    def __init__(self): : Il s'agit de la méthode de construction de la classe Étudiant. Le constructeur est automatiquement appelé lorsqu'une instance de la classe est créée. À l'intérieur du constructeur :
        Des valeurs par défaut sont attribuées aux variables d'instance (attributs) telles que id, name, gender, total et per.
        Ces attributs représentent l'identifiant, le nom, le sexe, le total des notes et le pourcentage de l'étudiant.
    def __del__(self): : Il s'agit de la méthode de destruction de la classe Student. Le destructeur est appelé lorsqu'un objet est sur le point d'être détruit. Dans ce cas, il affiche simplement "Object Destroyed" lorsque l'objet est détruit.
    def setData(self): : Cette méthode permet de définir les données d'une instance d'étudiant. Elle demande à l'utilisateur de saisir des données et définit les valeurs des attributs de l'élève en fonction des données saisies par l'utilisateur.
    def showData(self): : Cette méthode affiche les données de l'élève. Elle imprime les valeurs des attributs de l'étudiant dans la console.
    s = Student() : Cette ligne crée une instance de la classe Student et l'affecte à la variable s. Cette instance représente un étudiant spécifique.
    s.setData() : La méthode setData est appelée sur l'instance s pour définir les données de cet étudiant. L'utilisateur est invité à saisir l'identifiant, le nom, le sexe, le total des notes et le pourcentage de l'élève.
    s.showData() : La méthode showData est appelée sur l'instance s pour afficher les données de l'élève. Elle imprime les valeurs des attributs définis dans la méthode setData.

Lorsque vous exécutez ce programme, il crée un objet Étudiant, définit ses attributs en fonction des données saisies par l'utilisateur, puis affiche les informations relatives à l'étudiant.
        \end{solution}
        

        \question
        Ecrire un programme python pour implémenter des Getters et des Setters dans une classe.
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q712.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce programme Python définit une classe d'étudiant qui encapsule les détails de l'étudiant tels que le nom, le total et le pourcentage. Il démontre l'utilisation des méthodes setter et getter pour définir et récupérer ces attributs. Voici une explication du programme :

    classe Étudiant: : Il s'agit de la définition de la classe Student.
    def __init__(self): : Il s'agit de la méthode de construction de la classe Étudiant. Elle initialise trois variables d'instance : name, total et per avec des valeurs par défaut.
    self.name = "", self.total = "", self.per = 0 : Ces lignes initialisent le nom comme une chaîne vide, le total comme une chaîne vide et per comme 0.
    def setName(self, name): : Il s'agit d'une méthode setter permettant de définir le nom de l'élève.
    self.name = name : L'attribut name est mis à jour avec la valeur passée à la méthode setName.
    def getName(self): : Il s'agit d'une méthode getter permettant de récupérer le nom de l'élève.
    return self.name : L'attribut name est renvoyé lorsque la méthode getName est appelée.
    Des méthodes setter et getter similaires sont définies pour les attributs total et par.
    name = input("Enter a Name :") : Le programme invite l'utilisateur à saisir un nom et la saisie est stockée dans la variable name.
    total = int(input("Enter a Total :")) : Le programme invite l'utilisateur à saisir un total, et la saisie est convertie en un nombre entier et stockée dans la variable total.
    per = float(input("Enter a Percentage :")) : Le programme invite l'utilisateur à saisir un pourcentage, et la donnée est convertie en un nombre flottant et stockée dans la variable per.
    s = Student() : Une instance de la classe Student est créée, représentant un étudiant.
    s.setName(name), s.setTotal(total), s.setPercentage(per) : Les méthodes de définition sont utilisées pour définir le nom, le total et le pourcentage de l'étudiant en fonction des données fournies par l'utilisateur.
    n = s.getName(), t = s.getTotal(), p = s.getPercentage() : Les méthodes Getter sont utilisées pour récupérer le nom, le total et le pourcentage de l'élève.
    print("\nAffichage des détails de l'étudiant") : Un message est imprimé pour indiquer que les détails de l'élève vont être affichés.
    print("Nom :", n), print("Total :", t), print("Pourcentage :", p) : Le nom, le total et le pourcentage de l'étudiant sont affichés sur la console en utilisant les valeurs récupérées par les méthodes getter.

Ce programme démontre l'utilisation des principes orientés objet, de l'encapsulation et des méthodes setter et getter pour gérer et récupérer les informations relatives aux étudiants. Il permet à l'utilisateur de saisir des informations sur l'étudiant et affiche ensuite les détails de l'étudiant.
        \end{solution}
        

        \question
        Écrire un programme python pour mettre en œuvre l'abstraction à l'aide d'une classe abstraite.
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q713.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce programme Python démontre l'utilisation de classes abstraites et de la superposition de méthodes dans la programmation orientée objet. Il définit une classe de base abstraite, Vehicle, et deux sous-classes concrètes, Bike et Car. La classe Vehicle contient deux méthodes abstraites, accelerate et park, qui sont surchargées par les classes enfants afin de fournir des implémentations spécifiques pour différents types de véhicules. Voici une explication du programme :

    classe Véhicule: : Il s'agit de la classe de base abstraite Véhicule. Elle contient deux méthodes abstraites, accelerate et park, qui sont définies mais n'ont pas d'implémentation (indiquée par l'instruction pass). Les méthodes abstraites sont des méthodes qui sont déclarées dans la classe de base mais qui n'ont pas d'implémentation spécifique, et elles doivent être surchargées par les classes enfants.
    classe Vélo(Véhicule): : Il s'agit de la classe Bike, qui hérite de la classe Vehicle. Elle surcharge les méthodes accelerate et park pour fournir un comportement spécifique à un vélo.
    classe Car(Véhicule): : Voici la classe Voiture, qui hérite également de la classe Véhicule. Elle surcharge les méthodes d'accélération et de stationnement pour fournir un comportement spécifique à une voiture.
    def accelerate(self, name): : Dans les classes Bike et Car, la méthode accelerate est implémentée pour accepter un paramètre name et imprimer un message spécifique au type de véhicule, indiquant qu'il accélère.
    def park(self, name): : Dans les classes Bike et Car, la méthode park est implémentée pour accepter un paramètre name et imprimer un message spécifique au type de véhicule, indiquant qu'il est en train de se garer.
    c = Voiture() : Une instance de la classe Voiture est créée et affectée à la variable c.
    c.accelerate("Voiture") : La méthode accelerate est appelée sur l'objet c, en passant "Car" comme paramètre de nom. Elle imprime un message indiquant que la voiture accélère.
    c.park("Voiture") : La méthode park est appelée sur l'objet c, en passant "Voiture" comme paramètre de nom. Elle imprime un message indiquant que la voiture est en train de se garer.
    b = Bike() : Une instance de la classe Bike est créée et assignée à la variable b.
    b.accelerate("Vélo") : La méthode accelerate est appelée sur l'objet b, en passant "Bike" comme paramètre de nom. Elle imprime un message indiquant que le vélo accélère.
    b.park("Vélo") : La méthode park est appelée sur l'objet b, en passant "Bike" comme paramètre de nom. Elle imprime un message indiquant que le vélo est en train de se garer.

Dans ce programme, l'utilisation d'une classe de base abstraite (Véhicule) garantit que toutes les sous-classes (Vélo et Voiture) fournissent des implémentations spécifiques pour les méthodes accelerate et park. Cela vous permet de créer différentes instances de véhicules (vélo et voiture) et d'appeler leurs méthodes spécifiques pour démontrer le comportement de chaque type de véhicule.
        \end{solution}
        

        \question
        Écrire un programme python pour implémenter une interface à l'aide d'une classe
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q714.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce programme Python définit deux classes, Circle et Rectangle, qui héritent d'une classe de base commune, Shape. Le programme calcule les surfaces des cercles et des rectangles en fonction des données saisies par l'utilisateur. Voici une explication du programme :

    Importation du module mathématique : Le programme commence par importer le module mathématique pour accéder à des fonctions mathématiques telles que pi et pow.
    Classe Shape : Il s'agit de la classe de base, qui peut être considérée comme une interface dans ce contexte. Elle définit trois méthodes : input, process et output. Ces méthodes sont des espaces réservés pour des implémentations spécifiques dans les classes dérivées, mais ne sont pas implémentées ici.
    classe Circle(Shape) : Il s'agit de la classe Circle, qui hérite de la classe Shape. Elle représente un cercle et est responsable du calcul de sa surface.
        __init__(self, rad=0.0) : Le constructeur initialise l'objet Circle avec un rayon par défaut de 0,0. Il initialise également une variable de surface à 0,0.
        setdata(self) : Cette méthode invite l'utilisateur à saisir le rayon du cercle et le fixe dans l'attribut radius.
        circle_area(self) : Cette méthode calcule la surface du cercle à l'aide de la formule π * radius^2 et stocke le résultat dans l'attribut area.
        getdata(self) : Cette méthode imprime la surface calculée sur la console.
    classe Rectangle(Forme) : Il s'agit de la classe Rectangle, qui hérite de la classe Shape. Elle représente un rectangle et calcule sa surface.
        __init__(self, len=0, bre=0) : Le constructeur initialise l'objet Rectangle avec des valeurs de longueur et de largeur par défaut de 0. Il initialise également un attribut de surface à 0.
        setdata(self) : Cette méthode invite l'utilisateur à saisir la longueur et la largeur du rectangle et les définit dans les attributs respectifs.
        rect_area(self) : Cette méthode calcule la surface du rectangle en multipliant la longueur et la largeur et stocke le résultat dans l'attribut area.
        getdata(self) : Cette méthode imprime la surface calculée sur la console.
    Création d'instances de cercle et de rectangle :
        c = Circle() : Crée une instance de la classe Circle.
        c.setdata() : Invite l'utilisateur à saisir le rayon et le fixe.
        c.circle_area() : Calcule la surface du cercle.
        c.getdata() : Affiche la surface du cercle.
        r = Rectangle() : Crée une instance de la classe Rectangle.
        r.setdata() : Invite l'utilisateur à saisir la longueur et la largeur et les fixe.
        r.rect_area() : Calcule la surface du rectangle.
        r.getdata() : Affiche la surface du rectangle.

En résumé, ce programme montre comment les classes peuvent hériter d'une classe de base commune (ou d'une interface) et comment chaque classe dérivée fournit ses propres implémentations pour des méthodes spécifiques. Il calcule et affiche les surfaces des cercles et des rectangles en fonction des entrées de l'utilisateur.
        \end{solution}
        

        \question
        Écrire un programme pour l'héritage simple en Python
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q715.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce programme Python démontre l'héritage dans la programmation orientée objet. Il définit deux classes, Détails et Étudiant, où la classe Étudiant hérite de la classe Détails. Voici une explication du programme :

    classe Détails: : Il s'agit de la classe Détails, qui sert de classe mère.
        __init__(self) : La méthode du constructeur initialise trois variables d'instance : name, total et per. Toutes ces variables sont initialement définies à 0 ou à une chaîne vide.
        setData(self, name, total, per) : Cette méthode permet de définir les valeurs des variables d'instance name, total et per.
        showData(self) : Cette méthode affiche les valeurs de name, total et per.
    class Student(Details): : La classe Student est une classe enfant qui hérite de la classe Details. Cela signifie qu'elle hérite des attributs et des méthodes de la classe mère.
        __init__(self) : La méthode du constructeur de la classe Student initialise une variable d'instance supplémentaire, Grade, qui prend initialement la forme d'une chaîne vide.
        setStudent(self, name, total, per, grade) : Cette méthode permet de définir les valeurs de name, total, per et de la nouvelle variable d'instance grade. Elle appelle la méthode setData de la classe mère pour définir les attributs communs.
        showStudent(self) : Cette méthode appelle d'abord la méthode showData de la classe mère pour afficher les détails hérités de Details. Elle affiche ensuite l'attribut grade.
    e = Student() : Une instance de la classe Student est créée et assignée à la variable e.
    e.setStudent("Kim", 430, 86.00, 'B') : La méthode setStudent est appelée sur l'objet e pour définir les détails de l'étudiant, y compris le nom, le total, le pourcentage et la note.
    e.showStudent() : La méthode showStudent est appelée pour afficher les détails de l'étudiant, notamment son nom, son total, son pourcentage et sa note.

Lorsque vous exécutez le programme, il crée une instance de la classe Student, définit les détails de l'étudiant à l'aide de la méthode setStudent, puis affiche ces détails à l'aide de la méthode showStudent. Ce programme illustre le concept d'héritage, dans lequel la classe Student hérite des attributs et des méthodes de la classe Details et les étend avec ses propres attributs et méthodes.
        \end{solution}
        

        \question
        Écrire un programme d'héritage avec deux classes enfantines (dérivées) en Python
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q716.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce programme Python définit trois classes : Détails, Étudiant et Personnel. Ces classes sont utilisées pour collecter et afficher des informations sur les étudiants et les membres du personnel. Voici une explication du programme :

    classe Détails: : Il s'agit de la classe de base, qui contient des attributs et des méthodes communs dont héritent les classes Student et Staff.
        __init__(self) : Le constructeur initialise les attributs idn, name et gender aux valeurs par défaut.
        setDetails(self) : Cette méthode permet de définir les détails d'une personne, notamment son numéro d'identification, son nom et son sexe. Elle recueille ces informations auprès de l'utilisateur par le biais d'une entrée.
        showDetails(self) : Cette méthode permet d'afficher les détails d'une personne, notamment son numéro d'identification, son nom et son sexe.
    class Student(Details): : Il s'agit d'une sous-classe de la classe Details, spécialement conçue pour contenir des informations sur les étudiants.
        __init__(self) : Le constructeur initialise les attributs total et par aux valeurs par défaut. Il appelle également le constructeur de la classe mère (Details) en utilisant super().
        setStudent(self) : Cette méthode recueille des informations supplémentaires relatives aux étudiants, telles que le total des notes et le pourcentage, en utilisant les données fournies par l'utilisateur. Elle appelle également la méthode setDetails de la classe mère pour collecter les détails communs.
        showStudent(self) : Cette méthode affiche tous les détails d'un étudiant, y compris les détails communs (ID, nom et sexe) de la classe Details et les détails spécifiques (notes totales et pourcentage) de la classe Student.
    classe Staff(Details): : Il s'agit d'une autre sous-classe de la classe Détails, conçue pour contenir des informations sur les membres du personnel.
        __init__(self) : Le constructeur initialise les attributs depart et salary aux valeurs par défaut et appelle le constructeur de la classe mère (Details) à l'aide de super().
        setStaff(self) : Cette méthode recueille des informations supplémentaires relatives au personnel, telles que le département et le salaire, en utilisant les données fournies par l'utilisateur. Elle appelle également la méthode setDetails de la classe mère pour collecter les informations communes.
        showStaff(self) : Cette méthode affiche tous les détails d'un membre du personnel, y compris les détails communs (ID, nom et sexe) de la classe Details et les détails spécifiques (département et salaire) de la classe Staff.
    Le programme commence par créer des instances des classes Étudiant et Personnel afin de collecter et d'afficher les informations relatives à un étudiant et à un membre du personnel. Il demande à l'utilisateur de saisir les détails de chacun d'eux, puis affiche les informations.

Ce programme démontre l'utilisation de l'héritage de classe, où les classes Étudiant et Personnel héritent d'attributs et de méthodes communs de la classe Détails. Il montre comment vous pouvez collecter et afficher des informations spécifiques pour différents types d'objets (étudiants et membres du personnel) tout en réutilisant et en personnalisant les fonctionnalités communes fournies par la classe mère.
        \end{solution}
        

        \question
        Écrire un programme pour l'héritage multiple en Python
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q717.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce programme Python démontre le concept d'héritage multiple en créant une classe enfant, Student, qui hérite de deux classes parents, PersonalInfo et AcademicInfo. Le programme recueille les informations personnelles et académiques de l'utilisateur et affiche ensuite les détails combinés de l'étudiant, y compris les informations personnelles et académiques. Voici une explication du programme :

    classe PersonalInfo : Il s'agit de la classe mère des informations personnelles. Elle contient un constructeur __init__ qui initialise les attributs tels que l'identifiant, le nom, le sexe, l'adresse et le contact. Elle comprend également une méthode display_personal_info qui permet d'afficher les informations personnelles.
    classe AcademicInfo : Il s'agit de la classe mère pour les informations académiques. Elle contient un constructeur __init__ qui initialise les attributs tels que la filière et l'année. Elle comprend également une méthode display_academic_info pour afficher les informations académiques.
    classe Student(PersonalInfo, AcademicInfo) : Il s'agit de la classe enfant qui hérite à la fois de PersonalInfo et de AcademicInfo. Elle surcharge le constructeur __init__ pour appeler les constructeurs des deux classes mères. Elle comprend également une méthode display_student_details pour afficher les informations personnelles et académiques.
    Dans la partie principale du programme, l'utilisateur est invité à saisir ses informations personnelles et académiques à l'aide de la fonction input.
    Une instance de la classe Student, nommée student, est créée en fournissant les informations collectées comme arguments au constructeur.
    Enfin, la méthode display_student_details est appelée sur l'objet étudiant pour afficher tous les détails de l'étudiant.

Lorsque vous exécutez ce programme, il collecte et affiche les informations personnelles et académiques d'un étudiant en héritant et en utilisant les méthodes et les attributs des classes mères PersonalInfo et AcademicInfo. Ceci démontre l'héritage multiple, où une classe enfant peut hériter de plusieurs classes parents pour réutiliser leurs attributs et méthodes.
        \end{solution}
        

        \question
        Écrire un programme python pour vérifier les nombres premiers en utilisant une approche orientée objet.
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q718.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce programme Python définit une classe PrimeChecker qui peut être utilisée pour vérifier si un nombre donné est premier ou non. Voici une explication du fonctionnement du programme :

    La classe PrimeChecker est définie et prend un entier num comme paramètre lors de la création d'une instance de la classe.
    La méthode __init__ est le constructeur de la classe et initialise la variable d'instance self.num avec la valeur qui lui a été transmise.
    La méthode is_prime est utilisée pour déterminer si le nombre stocké dans self.num est premier ou non. Elle suit les étapes suivantes :
        Si le nombre est inférieur ou égal à 1, elle renvoie False, car les nombres premiers sont définis comme des entiers positifs supérieurs à 1.
        Si le nombre est égal à 2, il renvoie True, car 2 est le seul nombre premier pair.
        Si le nombre est pair (c'est-à-dire divisible par 2), il renvoie False car les nombres premiers (autres que 2) sont toujours impairs.
        Il vérifie ensuite la divisibilité du nombre à partir de 3 jusqu'à la racine carrée du nombre. Il effectue cette opération dans une boucle avec un pas de 2 pour ne vérifier que les nombres impairs, car les nombres pairs supérieurs à 2 ne peuvent pas être premiers. S'il trouve un diviseur dans cet intervalle, il renvoie False, indiquant que le nombre n'est pas premier.
        Si aucune des conditions ci-dessus n'est remplie, il renvoie True, ce qui indique que le nombre est premier.
    Le programme prend ensuite en compte la saisie d'un nombre par l'utilisateur à l'aide de input() et le convertit en un nombre entier à l'aide de int(). Ce nombre est stocké dans la variable num.
    Une instance de la classe PrimeChecker est créée avec les données de l'utilisateur et est affectée à la variable checker.
    La méthode is_prime de l'instance de checker est appelée. Si la méthode renvoie True, cela signifie que le nombre est premier et un message indiquant que le nombre est premier est imprimé. Si la méthode renvoie False, cela signifie que le nombre n'est pas premier et un message correspondant est imprimé.
        \end{solution}
        

        \question
        Écrire un programme python pour compter le nombre d'objets créés
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q719.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce programme Python définit une classe appelée Student et démontre l'utilisation des variables de classe, de la création d'objets et des méthodes d'instance. Voici une explication du programme :

    classe Étudiant: : Cette ligne définit une classe nommée Student.
    count = 0 : Il s'agit d'une variable de classe nommée count qui est utilisée pour garder une trace du nombre d'objets Student créés. Elle est initialisée à 0.
    def __init__(self, name, age): : Il s'agit de la méthode de construction de la classe Étudiant. Elle est utilisée pour initialiser les attributs d'un objet Étudiant. self est une référence à l'instance de la classe en cours de création, et name et age sont les attributs qui sont définis pour chaque objet.
    self.name = name et self.age = age : Ces lignes définissent les attributs nom et âge de l'objet Étudiant avec les valeurs passées en argument.
    Student.count += 1 : Cette ligne incrémente la variable de classe count de 1 à chaque fois qu'un nouvel objet Etudiant est créé. Cela permet de garder une trace du nombre d'objets Étudiant créés.
    def GetDetails(self): : Il s'agit d'une méthode d'instance de la classe Étudiant, utilisée pour imprimer le nom et l'âge d'un étudiant.
    print("Name :", self.name) et print("Age :", self.age) : Ces lignes sont utilisées pour imprimer le nom et l'âge d'un objet Étudiant lorsque la méthode GetDetails est appelée.
    Quatre instances de la classe Étudiant sont créées :
        s1 = Student("Sam Kumar", 21) : un objet Student est créé avec le nom "Sam Kumar" et l'âge 21.
        s2 = Student("Tiya", 20) : un autre objet Student est créé avec le nom "Tiya" et l'âge de 20 ans.
        s3 = Student("Sathish", 19) : Un autre objet Student est créé avec le nom "Sathish" et l'âge 19.
        s3 = Étudiant("Deepika", 21) : Un autre objet Etudiant est créé avec le nom "Deepika" et l'âge de 21 ans. Notez que cette ligne réaffecte la variable s3, écrasant l'objet précédent créé avec cette variable.
    print("Nombre d'objets : ", Student.count) : Cette ligne imprime le nombre total d'objets Étudiant créés en accédant à la variable de classe count. Elle reflète le nombre d'objets créés, qui dans ce cas est de 3 puisque la variable s3 a été réaffectée.
        \end{solution}
        

        \question
        Ecrire un programme python pour vérifier le numéro Armstrong en utilisant une approche orientée objet.
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q720.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce programme Python définit une classe appelée ArmstrongChecker qui vérifie si un nombre donné est un nombre Armstrong. Voici une explication pas à pas de son fonctionnement :

    La classe ArmstrongChecker est définie par un constructeur __init__, qui prend un argument, num, représentant le nombre à vérifier.
    Dans le constructeur, self.num se voit attribuer la valeur de l'argument num, qui stocke le nombre à vérifier pour être un nombre Armstrong.
    La classe possède une méthode appelée is_armstrong(). Cette méthode vérifie si le nombre stocké dans self.num est un nombre d'Armstrong et renvoie une valeur booléenne (True ou False).
    A l'intérieur de la méthode is_armstrong : a. num_str est calculé en convertissant le nombre en une chaîne de caractères. Cela permet de compter le nombre de chiffres dans le nombre original.
        num_digits est calculé comme la longueur de num_str, ce qui donne le nombre de chiffres dans le nombre original.
        digit_sum est calculé à l'aide d'une expression de générateur. Il calcule la somme de chaque chiffre élevé à la puissance de num_chiffres. Par exemple, si num est 153, digit_sum sera calculé comme suit : (1^3 + 5^3 + 3^3), soit 153.
        Enfin, la méthode renvoie True si digit_sum est égal au nombre original self.num, ce qui indique que le nombre est un nombre Armstrong. Dans le cas contraire, elle renvoie False.
    Le programme prend ensuite en compte la saisie d'un nombre par l'utilisateur en utilisant int(input("Enter a Number : ")) et le stocke dans la variable num.
    Une instance de la classe ArmstrongChecker est créée avec le nombre fourni num comme argument, et l'instance est stockée dans la variable checker.
    Le programme vérifie ensuite si le nombre est un nombre Armstrong en appelant la méthode is_armstrong() de l'objet checker.
    Si le nombre est un nombre d'Armstrong (c'est-à-dire que la méthode renvoie True), il imprime un message indiquant que le nombre est un nombre d'Armstrong. Dans le cas contraire, un message indiquant que le nombre n'est pas un nombre d'Armstrong s'affiche.

Le programme vérifie si un nombre donné est un nombre d'Armstrong en utilisant la définition du nombre d'Armstrong (un nombre est un nombre d'Armstrong si la somme de ses chiffres élevée à la puissance du nombre de chiffres est égale au nombre original). Pour ce faire, il encapsule la logique dans une classe appelée ArmstrongChecker.
        \end{solution}
        

        \question
        Écrire un programme python pour l'héritage multi-niveaux
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q721.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce programme Python définit une hiérarchie de classes avec un héritage à plusieurs niveaux en Python. Voici un aperçu des classes et de leurs relations :

    Personne (classe de base) : Cette classe possède un constructeur __init__ qui initialise les attributs nom et âge. Elle possède également une méthode display_info qui imprime le nom et l'âge.
    Étudiant (classe intermédiaire) : Cette classe hérite de Person et ajoute un nouvel attribut student_id. Elle possède son propre constructeur, qui prend en paramètre le nom, l'âge et l'identifiant de l'étudiant. Le constructeur de la classe Student appelle le constructeur de la classe Person en utilisant super() pour définir le nom et l'âge. Elle possède également une méthode display_student_info, qui appelle la méthode display_info de la classe Person et ajoute les informations relatives à l'identifiant de l'étudiant.
    GraduateStudent (classe dérivée) : Cette classe hérite de la classe Student et ajoute un nouvel attribut research_topic. Elle possède son propre constructeur, qui prend en paramètre le nom, l'âge, l'identifiant de l'étudiant et le sujet de la recherche. Le constructeur de la classe GraduateStudent appelle le constructeur de la classe Student en utilisant super() pour définir le nom, l'âge et l'identifiant de l'étudiant. Il possède également une méthode display_graduate_info, qui appelle la méthode display_student_info de la classe Student et ajoute les informations research_topic.

Vous créez une instance de la classe GraduateStudent avec le nom "Alice", l'âge de 25 ans, le numéro d'étudiant "STU001" et le sujet de recherche "Machine Learning". Vous appelez ensuite la méthode display_graduate_info sur l'objet graduate_student, qui imprime toutes les informations de la classe de base Person, de la classe Student et de la classe GraduateStudent, y compris le sujet de recherche.
        \end{solution}
        

        \question
        Ecrire un programme python pour vérifier le nombre de palindromes en utilisant une approche orientée objet.
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q722.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le programme Python PalindromeChecker est conçu pour vérifier si un nombre donné est un palindrome. Voici une explication du fonctionnement du programme :

    class PalindromeChecker : Il s'agit d'une classe qui définit un vérificateur de palindromes. Elle possède deux méthodes :
        __init__(self, num) : Il s'agit de la méthode du constructeur qui initialise l'objet avec le nombre num.
        is_palindrome(self) : Cette méthode vérifie si le nombre est un palindrome. Pour ce faire, elle convertit d'abord le nombre en une chaîne de caractères (num_str). Ensuite, elle inverse la chaîne en utilisant le découpage (reversed_str = num_str[::-1] ) et vérifie si la chaîne inversée est égale à la chaîne originale. Si c'est le cas, il renvoie True, ce qui indique que le nombre est un palindrome ; sinon, il renvoie False.
    num = int(input("Enter a Number : ")) : Cette ligne de code invite l'utilisateur à saisir un nombre et convertit la saisie de l'utilisateur en un nombre entier, qui est stocké dans la variable num.
    checker = PalindromeChecker(num) : Cette ligne crée une instance de la classe PalindromeChecker avec le nombre saisi par l'utilisateur. La valeur num est transmise comme argument au constructeur, initialisant l'attribut num de l'objet checker.
    if checker.is_palindrome(): : Cette instruction conditionnelle vérifie si la méthode is_palindrome de l'objet checker renvoie True. Si c'est le cas, cela signifie que le nombre saisi est un palindrome et un message indiquant que le nombre est un palindrome s'affiche. Dans le cas contraire, un message indiquant que le nombre n'est pas un palindrome est imprimé.
    Le programme imprime alors "{num} est un nombre palindrome" ou "{num} n'est pas un nombre palindrome" en fonction du résultat de la méthode is_palindrome.

Voici comment fonctionne le programme :

    L'utilisateur est invité à saisir un nombre.
    Le programme crée une instance de la classe PalindromeChecker avec le nombre saisi.
    Il vérifie si le nombre saisi est un palindrome à l'aide de la méthode is_palindrome.
    En fonction du résultat, il imprime un message indiquant si le nombre est un palindrome ou non.

Ce programme démontre le concept d'utilisation d'une classe pour encapsuler la fonctionnalité permettant de vérifier si un nombre est un palindrome, ce qui rend le code plus organisé et réutilisable.
        \end{solution}
        

        \question
        Écrire un programme pour le programme d'enregistrement de la taille des étudiants pour une école en Python
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q723.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le code Python définit une classe appelée SchoolHeightRecords qui vous permet de gérer les enregistrements de taille des élèves. Voici la décomposition du code :

    La classe SchoolHeightRecords est définie avec les méthodes suivantes :
        __init__ : Initialise un dictionnaire vide appelé student_records pour stocker les noms des élèves et leurs tailles correspondantes.
        add_student : Ajoute la taille d'un nouvel élève au dictionnaire student_records.
        remove_student : Supprime l'enregistrement d'un élève du dictionnaire student_records en fournissant le nom de l'élève.
        find_student_height : Permet d'obtenir la taille d'un élève en fournissant son nom. Si l'élève n'est pas trouvé, cette fonction renvoie None.
        display_records : Affiche tous les enregistrements de la taille des élèves stockés dans le dictionnaire.
    Une instance de la classe SchoolHeightRecords est créée avec la variable school_records.
    Un menu est affiché à l'utilisateur avec les options suivantes :
        1. Ajouter la taille de l'élève
        2. Supprimer la taille de l'élève
        3. Trouver la taille d'un élève
        4. Afficher tous les enregistrements
        5. Quitter
    Le programme entre dans une boucle où l'utilisateur est invité à saisir son choix.
    En fonction du choix de l'utilisateur, la méthode correspondante de l'instance SchoolHeightRecords est appelée pour effectuer l'opération souhaitée. L'utilisateur peut ajouter, supprimer, rechercher ou afficher des relevés de taille d'élèves, ou quitter le programme.
    Si l'utilisateur fournit un choix non valide, il en est informé par le message "Choix non valide" et est invité à réessayer.

Le code vous permet de gérer de manière interactive les enregistrements de taille des élèves et il continuera à fonctionner jusqu'à ce que l'utilisateur choisisse de quitter le programme (option 5).

Il convient de noter que les tailles sont stockées sous forme de chaînes de caractères dans le dictionnaire student_records. Si vous devez effectuer des opérations numériques avec les tailles, vous devez les convertir en entiers ou en flottants avant de les utiliser dans les calculs.
        \end{solution}
        

        \question
        Ecrire un programme python pour gérer l'enregistrement d'un magasin de téléphonie (mobile shop) en utilisant la classe
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q724.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le code Python définit deux classes : Phone et PhoneStore, qui permettent de gérer l'inventaire des téléphones d'un magasin. Voici la décomposition du code :

    La classe Phone représente des téléphones individuels. Chaque téléphone possède des attributs pour sa marque, son modèle et son prix. La méthode __init__ initialise ces attributs lorsqu'un nouvel objet téléphone est créé.
    La classe PhoneStore représente l'inventaire des téléphones d'un magasin. Elle possède les méthodes suivantes :
        __init__ : Initialise une liste vide appelée inventaire pour stocker les objets téléphone.
        add_phone : Ajoute un objet téléphone à la liste d'inventaire.
        remove_phone : Supprime un téléphone de l'inventaire en fonction de sa marque et de son modèle. Si le téléphone est trouvé et supprimé, un message de réussite est affiché ; sinon, un message "not found" (introuvable) est affiché.
        find_phone : Recherche un téléphone dans l'inventaire en fonction de sa marque et de son modèle. S'il est trouvé, il renvoie l'objet téléphone ; sinon, il renvoie None.
        display_inventory : Affiche l'inventaire actuel des téléphones, y compris la marque, le modèle et le prix.
    Une instance de la classe PhoneStore est créée avec la variable phone_store.
    Un menu est affiché à l'utilisateur avec les options suivantes :
        1. Ajouter un téléphone à l'inventaire
        2. Supprimer un téléphone de l'inventaire
        3. Trouver un téléphone dans l'inventaire
        4. Afficher l'inventaire
        5. Quitter
    Le programme entre dans une boucle où l'utilisateur est invité à saisir son choix (sous forme de chaîne de caractères).
    En fonction du choix de l'utilisateur, la méthode correspondante de l'instance PhoneStore est appelée pour effectuer l'opération souhaitée. L'utilisateur peut ajouter, supprimer, rechercher ou afficher l'inventaire des téléphones, ou quitter le programme.
    Si l'utilisateur fournit un choix non valide, il est averti par le message "Choix non valide" et invité à réessayer.

Le code convertit les entrées de marque et de modèle en majuscules à l'aide de la méthode .capitalize() avant de les stocker dans les objets téléphone et lors de la recherche dans l'inventaire. Cela permet de s'assurer que la correspondance entre les majuscules et les minuscules est utilisée lors de l'ajout, de la suppression ou de la recherche de téléphones.

Le code vous permet de gérer de manière interactive l'inventaire des téléphones d'un magasin et continuera à fonctionner jusqu'à ce que l'utilisateur choisisse de quitter (option 5).
        \end{solution}
        

        \question
        Écrire un programme python pour additionner deux distances en utilisant les concepts de classe et d'objet
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q725.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce programme Python définit une classe Distance qui représente une distance en kilomètres, mètres et centimètres. La classe fournit des méthodes permettant d'additionner deux distances et d'afficher une distance dans un format lisible par l'homme. Voici une explication du programme :

    classe Distance : Il s'agit de la classe principale représentant une distance. Elle possède les méthodes suivantes :
        __init__(self, km=0, m=0, cm=0) : Le constructeur initialise l'objet avec des valeurs optionnelles pour les kilomètres (0 par défaut), les mètres (0 par défaut) et les centimètres (0 par défaut).
        add(self, other_distance) : Cette méthode prend en paramètre un autre objet Distance, ajoute les composantes correspondantes (kilomètres, mètres et centimètres) et renvoie un nouvel objet Distance.
        display(self) : Cette méthode renvoie une chaîne de caractères formatée représentant la distance.
    Le programme invite ensuite l'utilisateur à saisir deux distances : une pour la distance1 et une pour la distance2. L'utilisateur est invité à saisir la distance en kilomètres, en mètres et en centimètres pour chacune d'entre elles.
    Les objets Distance distance1 et distance2 sont créés avec les valeurs fournies par l'utilisateur.
    La méthode add est appelée sur distance1, en passant distance2 comme paramètre. Il en résulte un nouvel objet Distance result_distance qui représente la somme des deux distances d'entrée.
    Le programme affiche le résultat en appelant la méthode display sur distance_résultat, qui fournit la somme des deux distances dans un format lisible par l'homme.

Lorsque vous exécutez ce programme, il vous permet de saisir deux distances, puis de calculer et d'afficher la somme de ces distances. Le programme se charge d'ajuster les unités si nécessaire, en veillant à ce que le résultat soit affiché correctement en termes de kilomètres, de mètres et de centimètres.
        \end{solution}
        

        \question
        Ecrire un programme python pour trouver la personne la plus âgée de deux personnes en utilisant la classe et l'objet.
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q726.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce programme Python définit une classe Person et une fonction find_elder pour trouver la personne la plus âgée parmi deux individus donnés en fonction de leur âge. Voici une explication du programme :

    classe Personne : Il s'agit de la classe Personne avec un constructeur __init__ qui initialise deux attributs, le nom et l'âge. Elle représente une personne avec un nom et un âge.
    def find_elder(personne1, personne2) : Cette fonction prend deux objets Person, person1 et person2, comme paramètres. Elle compare leurs âges et renvoie la personne la plus âgée. Si les deux personnes ont le même âge, elle renvoie None.
    Le programme crée deux objets Personne, personne1 et personne2, représentant deux individus avec leurs noms et âges respectifs.
    La fonction find_elder est appelée avec ces deux objets Personne et le résultat est stocké dans la variable elder.
    Le programme vérifie ensuite si elder est None. Si c'est le cas, cela signifie que les deux personnes ont le même âge, et il imprime donc "Les deux personnes ont le même âge". Sinon, il imprime le nom et l'âge de la personne la plus âgée.

Lorsque vous exécutez ce programme, il détermine laquelle des deux personnes est la plus âgée en fonction de leur âge et imprime le message correspondant. Si les deux personnes ont le même âge, il indiquera que les deux ont le même âge. Ce programme montre comment définir une classe, créer des objets et comparer leurs attributs pour prendre des décisions basées sur l'état de l'objet.
        \end{solution}
        

        \question
        Écrire un programme python pour le système de gestion bancaire
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q727.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Ce programme Python simule un système de gestion bancaire simple en utilisant la classe Bank. Il permet aux utilisateurs de créer des comptes, de déposer de l'argent, de retirer de l'argent, de vérifier les soldes et de quitter le programme. Voici une explication du programme :

    classe Banque : Il s'agit de la classe principale représentant la banque. Elle possède les méthodes suivantes :
        __init__(self) : Le constructeur initialise un dictionnaire de comptes vide pour stocker les informations relatives aux comptes.
        create_account(self, account_number, account_holder, initial_balance) : Cette méthode crée un nouveau compte et le stocke dans le dictionnaire des comptes. Elle vérifie qu'il n'y a pas de duplication de numéro de compte et que le solde initial n'est pas négatif.
        deposit(self, account_number, amount) : Cette méthode permet d'effectuer des dépôts sur un compte existant, en mettant à jour le solde du compte.
        withdraw(self, account_number, amount) : Cette méthode permet d'effectuer des retraits sur un compte existant, en mettant à jour le solde du compte. Elle vérifie également que le solde est suffisant et que les montants des retraits ne sont pas négatifs.
        check_balance(self, account_number) : Cette méthode vérifie le solde d'un compte existant et renvoie le nom et le solde du titulaire du compte sous la forme d'une chaîne formatée.
    Le programme crée un objet Banque nommé banque.
    Le programme présente un menu à l'utilisateur avec les options suivantes : créer un compte, déposer de l'argent, retirer de l'argent, vérifier le solde et quitter.
    Dans une boucle, le programme lit le choix de l'utilisateur et effectue l'opération sélectionnée :
        Pour "Créer un compte", il recueille les détails du compte et appelle la méthode create_account.
        Pour "Déposer de l'argent", il recueille le numéro de compte et le montant du dépôt et appelle la méthode de dépôt.
        Pour "Retirer de l'argent", il collecte le numéro de compte et le montant du retrait et appelle la méthode de retrait.
        Pour "Vérifier le solde", il collecte le numéro de compte et appelle la méthode check_balance.
        Pour "Quitter", il quitte le programme.
    Le programme assure la validation des entrées et fournit un retour d'information approprié à l'utilisateur.

Lorsque vous exécutez ce programme, il vous permet de simuler un système de gestion bancaire de base en créant des comptes, en déposant de l'argent, en retirant de l'argent et en vérifiant les soldes. Il utilise la classe Banque pour gérer les comptes et les opérations sur les comptes.
        \end{solution}
        

        \question
        Ecrire un programme python pour obtenir les détails de l'étudiant en entrée et imprimer le résultat après la mise à jour des notes.
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q728.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le programme Python pour un système simple de gestion des étudiants. Il vous permet de saisir les coordonnées des étudiants, de mettre à jour les notes des étudiants et d'imprimer les coordonnées des étudiants. Voici un aperçu du fonctionnement du code :

    classe Student : Cette classe définit une classe nommée Student, qui représente le système de gestion des étudiants.
    __init__(self) : Le constructeur initialise un dictionnaire vide appelé student_details en tant que variable d'instance.
    @property input_student_details(self) : Il s'agit d'une méthode de propriété qui vous permet de saisir les détails de l'étudiant. Elle invite l'utilisateur à saisir le numéro de rôle, le nom de l'étudiant et ses notes. Les détails sont stockés dans le dictionnaire student_details sous la clé roll number.
    update_student_marks(self) : Cette méthode permet de mettre à jour les notes d'un élève. Elle invite l'utilisateur à saisir le numéro de rôle de l'élève à mettre à jour, puis les nouvelles notes. Si l'élève est trouvé dans le dictionnaire student_details, ses notes sont mises à jour.
    print_student_details(self) : Cette méthode permet d'imprimer les détails d'un étudiant spécifique. Elle invite l'utilisateur à saisir le numéro de rôle de l'étudiant et, si l'étudiant est trouvé, son numéro de rôle, son nom et ses notes sont imprimés.
    Le programme crée une instance de la classe Étudiant appelée obj.
    Le code entre dans une boucle while qui affiche un menu avec quatre options : saisir les coordonnées de l'élève, mettre à jour les notes de l'élève, imprimer les coordonnées de l'élève et quitter.
    L'utilisateur est invité à saisir son choix (1 à 4) et, en fonction de ce choix, l'une des méthodes de l'instance obj est appelée.
    Si l'utilisateur choisit l'option 4, le programme sort de la boucle et se termine.
    Si l'utilisateur saisit un choix non valide, un message d'erreur s'affiche.
        \end{solution}
        

        \question
        Ecrire un programme python pour les tableaux d'objets
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q729.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le programme Python définit une classe d'étudiants et crée une liste (étudiants) pour stocker les instances de la classe d'étudiants. Il montre également comment accéder aux attributs d'un étudiant et les modifier. Voici la décomposition du code :

    classe Étudiant : Cette classe définit une classe appelée Student, qui représente un étudiant avec des attributs tels que le numéro de rôle, le nom et les notes.
    __init__(self, roll_number, name, marks) : La méthode du constructeur initialise un objet Student avec le numéro de rôle, le nom et les notes fournis.
    __str__(self) : Cette méthode spéciale renvoie une représentation sous forme de chaîne de caractères de l'objet Étudiant, affichant le numéro de rôle, le nom et les notes.
    étudiants = [] : Cette méthode crée une liste vide pour stocker les objets Étudiant.
    Trois étudiants sont créés et ajoutés à la liste des étudiants à l'aide de la méthode append. Chaque étudiant a un numéro de rôle, un nom et des notes uniques.
    Une boucle for itère sur la liste des étudiants et imprime les détails de chaque étudiant à l'aide de la méthode __str__.
    Elle montre ensuite comment accéder aux attributs d'un étudiant spécifique et les modifier. Dans ce cas, il sélectionne le premier étudiant de la liste, modifie son nom et ses notes, et imprime les informations mises à jour.
        \end{solution}
        

        \question
        Ecrire un programme python pour rechercher des objets dans un tableau d'objets en utilisant l'ID
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q730.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le programme définit une classe Étudiant, crée une liste d'objets Étudiant et vous permet de rechercher un étudiant par son numéro d'identification. Voici la décomposition du code :

    classe Étudiant : Cette classe représente un étudiant avec des attributs tels que l'identifiant de l'étudiant, le nom et le pourcentage.
    __init__(self, student_id, name, per) : Le constructeur initialise un objet Student avec l'identifiant, le nom et le pourcentage fournis.
    __str__(self) : Cette méthode spéciale renvoie une représentation sous forme de chaîne de caractères de l'objet Étudiant, affichant l'identifiant, le nom et le pourcentage de l'étudiant.
    Un tableau (liste) d'objets Étudiant est créé et initialisé avec les données de l'étudiant.
    search_student_by_id(student_id) : Cette fonction permet de rechercher un étudiant à partir de son numéro d'identification. Elle parcourt la liste des étudiants et renvoie le premier objet étudiant correspondant à l'identifiant spécifié, ou Aucun si aucune correspondance n'est trouvée.
    Le code imprime tous les identifiants des étudiants de la liste à l'aide d'une boucle for.
    L'utilisateur est invité à saisir l'identifiant de l'étudiant à rechercher.
    La fonction search_student_by_id est appelée avec l'identifiant fourni par l'utilisateur et, si un étudiant correspondant à cet identifiant est trouvé, il est imprimé avec un message "Étudiant trouvé". Si aucun étudiant correspondant n'est trouvé, un message "Étudiant non trouvé" s'affiche.
        \end{solution}
        

        \question
        Écrire un programme python pour l'initialisation du constructeur
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q731.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le programme définit une classe Étudiant et crée trois instances de la classe, chacune représentant un étudiant différent. Il affiche ensuite les détails de chaque étudiant à l'aide de la méthode display_details. Voici la décomposition du code :

    classe Étudiant : Cette classe définit un étudiant avec des attributs tels que le numéro de rôle, le nom et le pourcentage.
    __init__(self, roll_number, name, percent) : Le constructeur initialise un objet Student avec le numéro de rôle, le nom et le pourcentage fournis.
    display_details(self) : Cette méthode permet d'afficher les détails d'un étudiant, y compris son numéro de rôle, son nom et son pourcentage.
    Trois instances de la classe Étudiant (s1, s2 et s3) sont créées et initialisées avec des données différentes pour chaque étudiant.
    Le code affiche ensuite les détails de chaque étudiant en appelant la méthode display_details pour chaque instance.

Voici ce que fait le code :

    Il crée trois objets étudiants avec des données différentes.
    Il imprime les détails de chaque élève à l'aide de la méthode display_details, en affichant leur numéro de rôle, leur nom et leur pourcentage.
        \end{solution}
        

        \question
        Ecrire un programme python pour paramétrer un constructeur et un destructeur.
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q732.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le programme définit une classe Étudiant avec un constructeur et un destructeur. Il crée trois instances de la classe, affiche leurs détails, puis supprime explicitement ces instances pour démontrer la fonctionnalité du destructeur. Voici la décomposition du code :

    classe Étudiant : Cette classe définit un étudiant avec des attributs tels que le numéro de rôle, le nom et le pourcentage.
    __init__(self, roll_number, name, per) : Le constructeur initialise un objet Student avec le numéro de rôle, le nom et le pourcentage fournis.
    display_details(self) : Cette méthode est utilisée pour imprimer les détails d'un étudiant, y compris son numéro de rôle, son nom et son pourcentage.
    del__(self) : Cette méthode spéciale est le destructeur. Elle est automatiquement appelée lorsqu'une instance de la classe est supprimée. Dans ce cas, elle imprime un message indiquant le numéro de rôle de l'étudiant supprimé.
    Trois instances de la classe Étudiant (s1, s2 et s3) sont créées et initialisées avec des données différentes pour chaque étudiant.
    Le code affiche les détails de chaque étudiant en appelant la méthode display_details pour chaque instance.
    Les instances sont explicitement supprimées à l'aide de l'instruction del, qui déclenche la méthode du destructeur __del__.

Voici ce que fait le code :

    Il crée trois objets étudiants avec des détails différents.
    Il imprime les détails de chaque étudiant à l'aide de la méthode display_details.
    Il supprime explicitement chaque objet élève, ce qui déclenche le destructeur et imprime un message indiquant que l'élève est supprimé.
        \end{solution}
        

        \question
        Ecrire un programme python pour ajouter des objets '+' en utilisant l'opérateur
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q733.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le programme python définit une classe ComplexNumber qui représente les nombres complexes. Elle permet de créer des objets de type nombre complexe, de les afficher sous forme de chaînes de caractères et d'effectuer l'addition de deux nombres complexes à l'aide de l'opérateur +. Voici la décomposition du code :

    classe ComplexNumber : Cette classe représente un nombre complexe avec les attributs real et imag, qui représentent respectivement les parties réelle et imaginaire.
    __init__(self, real, imag) : Le constructeur initialise un objet ComplexNumber avec les parties réelle et imaginaire fournies.
    __str__(self) : Cette méthode spéciale renvoie une représentation sous forme de chaîne de caractères du nombre complexe au format "a + bi" où "a" est la partie réelle, "b" la partie imaginaire et "i" l'unité imaginaire.
    __add__(self, other) : Cette méthode spéciale surcharge l'opérateur +, ce qui permet d'additionner deux nombres complexes. Elle additionne les parties réelle et imaginaire séparément et renvoie un nouvel objet ComplexNumber représentant la somme.
    Deux objets de nombres complexes, complex1 et complex2, sont créés avec des parties réelles et imaginaires différentes.
    Le code utilise l'opérateur + pour additionner complex1 et complex2, ce qui produit un nouvel objet ComplexNumber appelé result.
    L'instruction print affiche le résultat de l'addition, qui est la somme des nombres complexes.

Voici ce que fait le code :

    Il crée deux objets nombres complexes avec des parties réelles et imaginaires différentes.
    Il additionne ces nombres complexes à l'aide de l'opérateur +, qui appelle la méthode __add__.
    Il imprime le résultat de l'addition.
        \end{solution}
        

        \question
        Ecrire un programme python pour comparer deux objets en utilisant l'opérateur '>'.
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q734.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le programme python définit une classe Number qui représente un nombre. Il permet de créer des objets Number, de les afficher sous forme de chaînes et d'effectuer une comparaison supérieure à l'aide de l'opérateur >. Voici la décomposition du code :

    classe Number : Cette classe représente un nombre avec une valeur d'attribut.
    __init__(self, value) : Le constructeur initialise un objet Number avec la valeur fournie.
    __str__(self) : Cette méthode spéciale renvoie une représentation sous forme de chaîne de caractères du nombre.
    __gt__(self, other) : Cette méthode spéciale surcharge l'opérateur > (plus grand que), ce qui permet de comparer deux objets Number. Elle vérifie si la valeur de l'objet courant est supérieure à la valeur de l'autre objet.
    Deux objets Number, number1 et number2, sont créés avec des valeurs différentes.
    Le code compare number1 et number2 en utilisant l'opérateur > dans une expression et stocke le résultat dans la variable res.
    En fonction du résultat, le code imprime un message indiquant si nombre1 est supérieur à nombre2.

Voici ce que fait le code :

    Il crée deux objets Number avec des valeurs différentes.
    Il compare les deux nombres à l'aide de l'opérateur >.
    Il imprime un message basé sur le résultat de la comparaison.
        \end{solution}
        

        \question
        Écrire un programme python pour passer des objets en tant qu'arguments et renvoyer des objets à partir d'une fonction
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q735.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le programme python définit une classe MyClass et une fonction process_object. La fonction prend en argument un objet de la classe MyClass, modifie l'objet en doublant sa valeur et renvoie l'objet modifié. Voici la décomposition du code :

    classe MaClasse : Cette classe représente un objet avec une valeur d'attribut.
    __init__(self, value) : Le constructeur initialise un objet MyClass avec la valeur fournie.
    def process_object(obj) : Cette fonction prend un objet obj comme argument, double l'attribut value de l'objet, puis renvoie l'objet modifié.
    Une instance de MyClass est créée et my_obj est initialisé avec une valeur de 10.
    La fonction process_object est appelée avec mon_obj comme argument. Elle modifie mon_obj en doublant son attribut value, et l'objet modifié est renvoyé et assigné à result_obj.
    Le code imprime l'attribut de valeur de l'objet original (mon_obj) et de l'objet modifié (résultat_obj).

Voici ce que fait le code :

    Il crée un objet MyClass avec une valeur initiale de 10.
    Il appelle la fonction process_object, qui modifie l'objet en doublant sa valeur.
    Il imprime l'attribut value de l'objet original et de l'objet modifié.
        \end{solution}
        

        \question
        Ecrire un programme python pour illustrer le fonctionnement des décorateurs
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q736.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            L'utilisation d'un décorateur en Python. Un décorateur est une fonction qui enveloppe une autre fonction pour lui ajouter des fonctionnalités. Dans ce code, vous avez défini une fonction décorateur my_decorator, qui enveloppe la fonction msg. Voici la décomposition du code :

    def my_decorator(func) : Il s'agit de la fonction décoratrice. Elle prend une fonction func en argument et définit une fonction interne appelée wrapper. La fonction wrapper ajoute un comportement avant et après l'appel de func.
    def wrapper() : Il s'agit de la fonction interne du décorateur. Elle ajoute un comportement avant et après l'appel de la fonction originale func.
    À l'intérieur de la fonction wrapper, des instructions d'impression indiquent que quelque chose se passe avant et après l'appel de la fonction d'origine.
    return wrapper : La fonction decorator renvoie la fonction wrapper.
    @my_decorator : Il s'agit d'une syntaxe de décorateur, indiquant que la fonction msg est décorée avec mon_décorateur. Cela signifie que lorsque vous appelez msg, elle sera enveloppée par la fonction wrapper définie dans mon_décorateur.
    def msg() : Il s'agit de la fonction à décorer. Elle imprime simplement "Hello world !".
    Lorsque vous appelez msg(), vous appelez en fait la fonction décorée. Le décorateur my_decorator enveloppe msg, de sorte qu'il imprime les messages supplémentaires avant et après l'impression de "Hello world !

La fonction msg est décorée par le décorateur my_decorator, de sorte que lorsque vous appelez msg(), elle affiche "Quelque chose se passe avant l'appel de la fonction", puis "Hello world !", et enfin "Quelque chose se passe après l'appel de la fonction". Cela montre comment les décorateurs peuvent ajouter un comportement aux fonctions sans modifier leur code source.
        \end{solution}
        

        \question
        Ecrire un programme python pour illustrer le fonctionnement de la méthode abstraite
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q737.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            L'utilisation des classes de base abstraites et de l'héritage en Python. Voici la décomposition du code :

    from abc import ABC, abstractmethod : Cette ligne importe la classe ABC (Abstract Base Class) et le décorateur abstractmethod du module abc. La classe ABC est utilisée pour créer des classes de base abstraites, et le décorateur abstractmethod est utilisé pour déclarer des méthodes abstraites dans ces classes.
    classe Shape(ABC) : Cette classe définit une classe de base abstraite Shape qui hérite de la classe ABC. Elle possède une zone de méthodes abstraites.
    @abstractmethod : Ce décorateur est utilisé pour déclarer la méthode area comme une méthode abstraite. Les méthodes abstraites doivent être implémentées par toute sous-classe concrète de la classe Shape.
    classe Circle(Forme) : Cette classe définit une sous-classe Circle de la classe Shape. Elle implémente la méthode area pour calculer la surface d'un cercle en fonction du rayon.
    classe Rectangle(Forme) : Cette classe définit une autre sous-classe Rectangle de la classe Shape. Elle met en œuvre la méthode area pour calculer la surface d'un rectangle en fonction de sa longueur et de sa largeur.
    Les instances des classes Cercle et Rectangle sont créées en invitant l'utilisateur à saisir les dimensions requises.
    La méthode area est appelée sur les objets Circle et Rectangle pour calculer et imprimer les surfaces du cercle et du rectangle, respectivement.

Voici ce que fait le code :

    Il définit une classe de base abstraite Shape avec une méthode area abstraite.
    Il crée deux sous-classes concrètes, Circle et Rectangle, qui héritent de Shape et implémentent la méthode area.
    Elle invite l'utilisateur à saisir les dimensions d'un cercle et d'un rectangle.
    Il calcule et imprime les aires du cercle et du rectangle à l'aide des méthodes d'aire respectives.
        \end{solution}
        

        \question
        Ecrire un programme python pour convertir les heures en jours
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q738.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le programme python définit une classe HoursToDaysConverter, qui est utilisée pour convertir un nombre d'heures en jours. Voici la décomposition du code :

    class HoursToDaysConverter : Cette classe représente un convertisseur permettant de convertir des heures en jours. Elle possède une méthode __init__ pour initialiser l'attribut hours et une méthode convert_to_days pour effectuer la conversion.
    Dans le bloc try, le code tente d'obtenir le nombre d'heures de l'utilisateur à l'aide de la fonction input. Il convertit l'entrée de l'utilisateur en un nombre flottant et l'affecte à la variable hours_input. Si l'utilisateur saisit une valeur non valide (qui n'est pas un nombre), une exception ValueError est levée et un message d'erreur est imprimé.
    Si l'utilisateur saisit un nombre d'heures valide, une instance de la classe HoursToDaysConverter est créée à partir de la variable hours_input et la méthode convert_to_days est appelée pour effectuer la conversion.
    Le résultat, qui est le nombre de jours, est stocké dans la variable days_result.
    Enfin, le code imprime le nombre original d'heures saisi par l'utilisateur et le nombre équivalent de jours basé sur la conversion.

Voici ce que fait le code :

    Il prend le nombre d'heures saisi par l'utilisateur et tente de le convertir en un nombre flottant.
    Si l'entrée est valide, il convertit le nombre d'heures en jours à l'aide de la classe HoursToDaysConverter.
    Il affiche ensuite le nombre d'heures original et le nombre de jours équivalent.
        \end{solution}
        

        \question
        Écrire un programme python pour rechercher des objets dans un tableau d'objets à l'aide de la méthode filter().
        \par
        \begin{solution}
            \renewcommand{\nomfichier}{q739.py}
            \pythonfile{\chemincode \nomfichier}[][\nomfichier]
            Le programme python définit une classe Personne et une liste d'objets Personne. Il utilise ensuite la fonction filter() pour filtrer les personnes de la liste qui ont plus de 25 ans. Voici la décomposition du code :

    classe Personne : Cette classe définit une personne avec des attributs de nom et d'âge.
    Le code crée une liste d'objets Personne, les personnes, avec des noms et des âges différents.
    def is_older_than_25(person) : Cette fonction définit un critère de filtrage. Elle renvoie True si l'âge de la personne est supérieur à 25 ; sinon, elle renvoie False.
    filter(is_older_than_25, people) : La fonction filter() prend la fonction is_older_than_25 et la liste des personnes, et renvoie un itérable contenant uniquement les objets Person pour lesquels la fonction is_older_than_25 renvoie True.
    liste_personnes_filtrées = liste(personnes_filtrées) : Cette ligne convertit l'itérable filtré en liste. Bien que cette conversion soit facultative, elle est effectuée ici pour faciliter la lecture en boucle des résultats filtrés à plusieurs reprises.
    Le code parcourt ensuite la liste filtrée et imprime le nom et l'âge des personnes âgées de plus de 25 ans.

Voici ce que fait le code :

    Il définit une classe Personne pour représenter les personnes avec leur nom et leur âge.
    Il crée une liste d'objets Personne.
    Il utilise la fonction filter() pour filtrer et extraire les personnes âgées de plus de 25 ans.
    Il convertit le résultat du filtrage en une liste (facultatif).
    Il affiche les noms et les âges des personnes âgées de plus de 25 ans.
        \end{solution}
        
